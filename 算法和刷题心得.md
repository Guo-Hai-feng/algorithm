# æ’åºç®—æ³•

### å¿«é€Ÿæ’åº

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 20//è®¾è®°å½•ä¸è¶…è¿‡20ä¸ª
typedef int KeyType;//è®¾ç½®å…³é”®å­—ä¸ºæ•´å‹
typedef struct {//è®°å½•æ¯ä¸ªè®°å½•ï¼ˆæ•°æ®å…ƒç´ ï¼‰çš„ç»“æ„
	KeyType key;//å…³é”®å­—
	//..å…¶ä»–æ•°æ®é¡¹
}RedType;//Record Type

typedef struct {//å®šä¹‰é¡ºåºæ ‡ç»“æ„
	RedType r[MAXSIZE + 1];//å­˜å‚¨é¡ºåºè¡¨çš„å‘é‡ï¼Œr[0]ä¸€èˆ¬åšå“¨å…µæˆ–ç¼“å†²åŒº
	int length;//é¡ºåºè¡¨çš„é•¿åº¦,ä¸ç®—ç¼“å†²åŒºçš„é•¿åº¦
}SqList;

int Partion(SqList& L, int low, int high) {
	L.r[0] = L.r[low];
	int pivotkey = L.r[low].key;
	while (low < high) {
		while (low < high && L.r[high].key >= pivotkey) --high;
		L.r[low] = L.r[high];
		while (low < high && L.r[low].key <= pivotkey) ++low;
		L.r[high] = L.r[low];
	}
	L.r[low] = L.r[0];
	return low;//æ­¤æ—¶high=low=ä¸­é—´ä½ç½®

}
void QSort(SqList& L, int low, int high) {
	int pivotloc;  
	if (low < high) {
		//é•¿åº¦å¤§äºä¸€
		pivotloc = Partion(L, low, high);
		//å°†L.R[low..high]ä¸€åˆ†ä¸ºäºŒï¼Œpivotlocä¸ºæ¢è½´å…ƒç´ æ’å¥½åºçš„ä½ç½®
		QSort(L, low, pivotloc - 1);//å¯¹ä½å­è¡¨é€’å½’æ’åº
		QSort(L, pivotloc + 1, high);//å¯¹é«˜å­è¡¨è¿›è¡Œé€’å½’æ’åº
	}
}


```

### å¸Œå°”æ’åº

```
#include<iostream>
using namespace std;
#define MAXSIZE 20//è®¾è®°å½•ä¸è¶…è¿‡20ä¸ª
typedef int KeyType;//è®¾ç½®å…³é”®å­—ä¸ºæ•´å‹
typedef struct {//è®°å½•æ¯ä¸ªè®°å½•ï¼ˆæ•°æ®å…ƒç´ ï¼‰çš„ç»“æ„
	KeyType key;//å…³é”®å­—
	//..å…¶ä»–æ•°æ®é¡¹
}RedType;//Record Type

typedef struct {//å®šä¹‰é¡ºåºæ ‡ç»“æ„
	RedType r[MAXSIZE + 1];//å­˜å‚¨é¡ºåºè¡¨çš„å‘é‡ï¼Œr[0]ä¸€èˆ¬åšå“¨å…µæˆ–ç¼“å†²åŒº
	int length;//é¡ºåºè¡¨çš„é•¿åº¦
}SqList;


void Shellnsert(SqList &L, int dk){
	int i, j;
	for (i = dk + 1; i <= L.length; i++) {
		if (L.r[i].key < L.r[i - dk].key) {
			L.r[0] = L.r[i];
			for (j = i - dk; j > 0 && (L.r[0].key < L.r[j].key); j = j - dk) {
				L.r[j + dk] = L.r[j];
			}
			L.r[j + dk] = L.r[0];
		}
	}
}
void ShellSort(SqList& L, int dlta[], int t) {
	//æŒ‰å¢é‡åºåˆ—dlta[0..t-1]å¯¹é¡ºåºè¡¨Låšå¸Œå°”æ’åº
	int k;
	for (k = 0; k < t; ++k) {
		Shellnsert(L, dlta[k]);
	}
}
```

### é€‰æ‹©æ’åº

```
#include<iostream>
using namespace std;
#define MAXSIZE 20//è®¾è®°å½•ä¸è¶…è¿‡20ä¸ª
typedef int KeyType;//è®¾ç½®å…³é”®å­—ä¸ºæ•´å‹
typedef struct {//è®°å½•æ¯ä¸ªè®°å½•ï¼ˆæ•°æ®å…ƒç´ ï¼‰çš„ç»“æ„
	KeyType key;//å…³é”®å­—
	//..å…¶ä»–æ•°æ®é¡¹
}RedType;//Record Type

typedef struct {//å®šä¹‰é¡ºåºæ ‡ç»“æ„
	RedType r[MAXSIZE + 1];//å­˜å‚¨é¡ºåºè¡¨çš„å‘é‡ï¼Œr[0]ä¸€èˆ¬åšå“¨å…µæˆ–ç¼“å†²åŒº
	int length;//é¡ºåºè¡¨çš„é•¿åº¦,ä¸ç®—ç¼“å†²åŒºçš„é•¿åº¦
}SqList;

void selectSort(SqList& L) {
	for (int i = 1; i < L.length; i++) {
		int k = i;
		for (int j = i + 1; j <= L.length; j++) {
			if (L.r[j].key < L.r[k].key) {
				k = j;
			}
		}
		if (k != i) {
			RedType temp;
			temp = L.r[i];
			L.r[i] = L.r[k];
			L.r[k] = temp;
		}
	}
}
```

### å†’æ³¡æ’åº

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 20//è®¾è®°å½•ä¸è¶…è¿‡20ä¸ª
typedef int KeyType;//è®¾ç½®å…³é”®å­—ä¸ºæ•´å‹
typedef struct {//è®°å½•æ¯ä¸ªè®°å½•ï¼ˆæ•°æ®å…ƒç´ ï¼‰çš„ç»“æ„
	KeyType key;//å…³é”®å­—
	//..å…¶ä»–æ•°æ®é¡¹
}RedType;//Record Type

typedef struct {//å®šä¹‰é¡ºåºæ ‡ç»“æ„
	RedType r[MAXSIZE + 1];//å­˜å‚¨é¡ºåºè¡¨çš„å‘é‡ï¼Œr[0]ä¸€èˆ¬åšå“¨å…µæˆ–ç¼“å†²åŒº
	int length;//é¡ºåºè¡¨çš„é•¿åº¦
}SqList;

void bubble_sort(SqList& L) {
	int m, i, j;
	RedType x;//äº¤æ¢æ—¶ä¸´æ—¶å­˜å‚¨
	for (m = 1; m < L.length - 1; m++) {
		for (j = 1; j <= L.length - m; j++) {
			if (L.r[j].key > L.r[j + 1].key) {
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;
			}
		}
	}
}

void bubble_sort2(SqList& L) {
	int m, i, j,flag=1;//å¢åŠ äº†ä¸€ä¸ªæ ‡å¿—
	RedType x;//äº¤æ¢æ—¶ä¸´æ—¶å­˜å‚¨
	for (m = 1; m < L.length - 1&&flag==1; m++) {
		flag = 0;
		for (j = 1; j <= L.length - m; j++) {
			if (L.r[j].key > L.r[j + 1].key) {//å‘ç”Ÿäº¤æ¢æ¬¡åº,flag=1,å¦‚æœæ²¡æœ‰å‘ç”Ÿäº¤æ¢ï¼Œflag=0
				flag = 1;
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;
			}
		}
	}
}
```

### æŠ˜åŠæ’å…¥æ’åº

```
#include<iostream>
using namespace std;
#define MAXSIZE 20//è®¾è®°å½•ä¸è¶…è¿‡20ä¸ª
typedef int KeyType;//è®¾ç½®å…³é”®å­—ä¸ºæ•´å‹
typedef struct {//è®°å½•æ¯ä¸ªè®°å½•ï¼ˆæ•°æ®å…ƒç´ ï¼‰çš„ç»“æ„
	KeyType key;//å…³é”®å­—
	//..å…¶ä»–æ•°æ®é¡¹
}RedType;//Record Type

typedef struct {//å®šä¹‰é¡ºåºæ ‡ç»“æ„
	RedType r[MAXSIZE + 1];//å­˜å‚¨é¡ºåºè¡¨çš„å‘é‡ï¼Œr[0]ä¸€èˆ¬åšå“¨å…µæˆ–ç¼“å†²åŒº
	int length;//é¡ºåºè¡¨çš„é•¿åº¦
}SqList;

void BinsertSort(SqList* L) {
	int i, j;
	for (i = 2; i <= L->length; i++) {//ä¾æ¬¡æ’å…¥ç¬¬2~nä¸ªå…ƒç´ 
		L->r[0] = L->r[i];//å½“å‰æ’å…¥å…ƒç´ å­˜åˆ°çƒ§é¥¼ä½ç½®
		int low = 1, high = i - 1;//é‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾æ³•æ’å…¥ä½ç½®
		while (low <= high) {
			int mid = (low + high) / 2;
			if (L->r[0].key < L->r[mid].key)
				high = mid - 1;
			else low = mid + 1;
		}//å¾ªç¯ç»“æŸï¼Œhigh+1æ˜¯æ’å…¥ä½ç½®
		for (j = i - 1; j >= high + 1; --j) L->r[j + 1] = L->r[j];//ç§»åŠ¨å…ƒç´ 
		L->r[high + 1] = L->r[0];//æ’å…¥åˆ°æ­£ç¡®ä½ç½®
	}
}
```

### ç›´æ¥æ’å…¥æ’åº

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 20//è®¾è®°å½•ä¸è¶…è¿‡20ä¸ª
typedef int KeyType;//è®¾ç½®å…³é”®å­—ä¸ºæ•´å‹
typedef struct {//è®°å½•æ¯ä¸ªè®°å½•ï¼ˆæ•°æ®å…ƒç´ ï¼‰çš„ç»“æ„
	KeyType key;//å…³é”®å­—
	//..å…¶ä»–æ•°æ®é¡¹
}RedType;//Record Type

typedef struct {//å®šä¹‰é¡ºåºæ ‡ç»“æ„
	RedType r[MAXSIZE + 1];//å­˜å‚¨é¡ºåºè¡¨çš„å‘é‡ï¼Œr[0]ä¸€èˆ¬åšå“¨å…µæˆ–ç¼“å†²åŒº
	int length;//é¡ºåºè¡¨çš„é•¿åº¦
}SqList;

void InsertSorted(SqList &L) {
	int i, j;
	for (i = 2; i < L.length; i++) {
		if (L.r->key < L.r[i - 1].key) {//è‹¥"<"é©¬ï¼Œåˆ™éœ€è¦å°†L.r[i]æ’å…¥æœ‰åºå­è¡¨
			L.r[0] = L.r[i];//å¤åˆ¶ä¸ºå“¨å…µ
			for (j = i - 1; L.r[0].key < L.r[j].key; --j) {
				L.r[j + 1] = L.r[j];//è®°å½•åç§»
				//æ³¨æ„ä¸æ˜¯ç§»åŠ¨keyå€¼ï¼Œå› ä¸ºå‡å®šä¸ºæœ‰å…¶ä»–æ•°æ®é¡¹
			}
			L.r[j + 1] = L.r[0];
		}
	}
}

```



### 88åŠ›æ‰£åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„

æ³¨è§£ï¼šè¯¾æœ¬å­¦åˆ°çš„æ˜¯æ„å»ºä¸€ä¸ªé¢å¤–çš„æ•°ç»„ï¼Œæœ¬é¢˜å›ºå®šäº†è¿™ä¸ªç©ºé—´åœ¨num1,**æ‰€ä»¥ä½¿ç”¨å€’å™**å°±å¯ä»¥äº†

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1;
        int j=n-1;
        int k=m+n-1;
        while(i>=0&&j>=0){
            if(nums1[i]>=nums2[j]){
                nums1[k]=nums1[i];
                k--;
                i--;
            }
            else{
                nums1[k]=nums2[j];
                k--;
                j--;
            }
        }
        while(i>=0){
            nums1[k]=nums1[i];
            k--;
            i--;
        }
        while(j>=0){
            nums1[k]=nums2[j];
            k--;
            j--;
        }

    }
};
```

### åŠ›æ‰£LCR075æ•°ç»„çš„ç›¸å¯¹æ’åº

![image-20240229234611341](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234611341.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            if (rank.count(x)) {
                return rank.count(y) ? rank[x] < rank[y] : true;
            }
            else {
                return rank.count(y) ? false : x < y;
            }
        });
        return arr1;
    }
};
//sortå‡½æ•°æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œå‰ä¸¤ä¸ªå‚æ•°æ˜¯æ’åºçš„èµ·ç‚¹å’Œç»ˆç‚¹è¿­ä»£å™¨ï¼Œæœ€åä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰å‡½æ•°ï¼Œç”¨æ¥å®šä¹‰æ’åºè§„åˆ™

/*[&]æ˜¯lambdaè¡¨è¾¾å¼çš„æ•è·åˆ—è¡¨ï¼ˆCapture Listï¼‰ã€‚åœ¨C++ä¸­ï¼Œlambdaè¡¨è¾¾å¼å¯ä»¥æ•è·å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œä»¥ä¾¿åœ¨lambdaå‡½æ•°ä½“ä¸­ä½¿ç”¨ã€‚æ•è·åˆ—è¡¨æŒ‡å®šäº†å¦‚ä½•æ•è·è¿™äº›å˜é‡ã€‚

[&]æ˜¯ä¸€ç§æ•è·åˆ—è¡¨çš„å½¢å¼ï¼Œå…¶ä¸­çš„&è¡¨ç¤ºæ•è·å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„æ‰€æœ‰å˜é‡å¹¶æŒ‰å¼•ç”¨ï¼ˆreferenceï¼‰æ•è·ã€‚è¿™æ„å‘³ç€lambdaå‡½æ•°ä½“ä¸­ä½¿ç”¨çš„å¤–éƒ¨å˜é‡éƒ½æ˜¯é€šè¿‡å¼•ç”¨è®¿é—®çš„ï¼Œå¯¹è¿™äº›å˜é‡çš„ä¿®æ”¹ä¼šå½±å“åˆ°å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„åŸå§‹å˜é‡ã€‚

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œlambdaè¡¨è¾¾å¼ [&](int x, int y) æ•è·äº†æ‰€æœ‰å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œå¹¶ä»¥å¼•ç”¨çš„æ–¹å¼è®¿é—®å®ƒä»¬ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯åœ¨lambdaå‡½æ•°ä½“ä¸­å¯ä»¥ä½¿ç”¨ rank è¿™ä¸ªå¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼Œè€Œä¸éœ€è¦é¢å¤–ä¼ é€’å‚æ•°ã€‚*/

=
```



![image-20240229234951333](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234951333.png)



```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        auto mycmp = [&](int x) -> pair<int, int> {
            return rank.count(x) ? pair{0, rank[x]} : pair{1, x};
        };
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return mycmp(x) < mycmp(y);
        });
        return arr1;
    }
};
```



![image-20240229235107812](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229235107812.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        int n = arr2.size();
        for (int i = 0; i < n; ++i) {
            rank[arr2[i]] = i - n;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return (rank.count(x) ? rank[x] : x) < (rank.count(y) ? rank[y] : y);
        });
        return arr1;
    }
};

```

### å †æ’åº

#### 15å±Šè“æ¡¥æ¯çˆ¬å±±

```c++
#include <iostream>
#include<cmath>
#include<queue>
using namespace std;
//å †ç»´æŠ¤æœ€å€¼+è´ªå¿ƒ
//æ—¶é—´å¤æ‚åº¦nlogn

int main() {
    priority_queue<int>pq;//å¤§æ ¹å †
    int n, p, q; cin >> n>>p >> q;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        pq.push(x);
    }

    while (p || q) {
        int cur = pq.top();
        pq.pop();
        if (p) {
            cur = sqrt(cur);
            p--;
        }
        else if(q){
            cur /= 2;
            q--;
        }
        pq.push(cur);
    }

    int s=0;
    while (!pq.empty()) {
        s += pq.top();
        pq.pop();
    }

    cout << s;

    
    return 0;
}

```

### æ‹“æ‰‘æ’åº

#### 207è¯¾ç¨‹è¡¨

è¯¦æƒ…[æ‹“æ‰‘æ’åº - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/topo/)

### é€†åºå¯¹

ç»™å®šä¸€ä¸ªåºåˆ—ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›ï¼Œå¦‚æœå­˜åœ¨ğ‘ğ‘–>ğ‘ğ‘—ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºé€†åºå¯¹ï¼Œæ±‚é€†åºå¯¹çš„æ•°ç›®ã€‚ æ¯”å¦‚ï¼šğ‘=[4,2,3,1,5]é€†åºå¯¹æœ‰ï¼š(4,2)ã€(4,3)ã€(4,1)ã€(2,1)ã€(3,1)(4,2)ã€(4,3)ã€(4,1)ã€(2,1)ã€(3,1) å…±5å¯¹ã€‚

æˆ‘ç ´é˜²äº†å“ˆå“ˆå“ˆ,è‡ªå·±å†™çš„ä»£ç è¶…æ—¶äº†

![image-20240719110147918](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719110147918.png)

```c++
#include <iostream>
#include <vector>

using namespace std;


long long mergeAndCount(vector<int>& arr, vector<int>& temp, int left, int mid, int right) {
    int i = left; 
    int j = mid + 1; 
    int k = left; 
    long long inv_count = 0; 

    
    while ((i <= mid) && (j <= right)) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        }
        else {
            temp[k++] = arr[j++];

           
            inv_count += (mid + 1) - i;
        }
    }

    
    while (i <= mid)
        temp[k++] = arr[i++];

    
    while (j <= right)
        temp[k++] = arr[j++];

    
    for (i = left; i <= right; i++)
        arr[i] = temp[i];

    return inv_count;
}


long long mergeSortAndCount(vector<int>& arr, vector<int>& temp, int left, int right) {
    long long inv_count = 0;
    if (left < right) {
        int mid = (left + right) / 2;

        
        inv_count += mergeSortAndCount(arr, temp, left, mid);

       
        inv_count += mergeSortAndCount(arr, temp, mid + 1, right);

        
        inv_count += mergeAndCount(arr, temp, left, mid, right);
    }
    return inv_count;
}

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<int> temp(n);
    long long inv_count = mergeSortAndCount(arr, temp, 0, n - 1);

    cout << inv_count << endl;

    return 0;
}


```



# ä½è¿ç®—

### åŠ›æ‰£ä½1çš„ä¸ªæ•°

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;

        // éå†äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æ¯ä¸€ä½
        while (n != 0) {
            // åˆ¤æ–­æœ€ä½ä½æ˜¯å¦ä¸º1
            if (n & 1) {
                count++;
            }
            // å³ç§»ä¸€ä½ï¼Œç»§ç»­åˆ¤æ–­ä¸‹ä¸€ä½
            n >>= 1;
        }

        return count;
    }
};

```



### å¼‚æˆ–è¿ç®—

å¼‚æˆ–è¿ç®—çš„æ€§è´¨å¦‚ä¸‹ï¼š

1. ä»»ä½•æ•°å’Œ0åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœä»ç„¶æ˜¯åŸæ¥çš„æ•°ï¼Œå³ a ^ 0 = aã€‚
2. ä»»ä½•æ•°å’Œå…¶æœ¬èº«åšå¼‚æˆ–è¿ç®—ï¼Œç»“æœæ˜¯0ï¼Œå³ a ^ a = 0ã€‚
3. å¼‚æˆ–è¿ç®—æ»¡è¶³**äº¤æ¢å¾‹å’Œç»“åˆå¾‹**ï¼Œå³ a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = bã€‚
4. å¼‚æˆ–è¿ç®—å¯ä»¥ç”¨æ¥äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼ï¼Œä¾‹å¦‚ï¼ša = a ^ b; b = a ^ b; a = a ^ b;ã€‚

ç»™ä½ ä¸€ä¸ª éç©º æ•´æ•°æ•°ç»„ nums ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚

ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°çº¿æ€§æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•æ¥è§£å†³æ­¤é—®é¢˜ï¼Œä¸”è¯¥ç®—æ³•åªä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´ã€‚

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
       int ans=nums[0];
       if(nums.size()>1)
       {
           for(int i=1;i<nums.size();i++)
           {
               ans=ans^nums[i];
           }
       }

    return ans;
    }
};
```

### åŠ›æ‰£æ±‰æ˜è·ç¦»

int c = 100;

c>>=1//å³ç§»ä¸€ä½ï¼Œè¡¨ç¤ºé™¤äºŒ

c>>=2//å³ç§»ä¸¤ä½ï¼Œè¡¨ç¤ºé™¤4

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int c = x ^ y;
        int count = 0;
        while(c != 0){
            if(c & 1){
                count +=1;
            }
            c>>=1;
        }
        return count;      
    }
};
```

### åŠ›æ‰£é¢ å€’äºŒè¿›åˆ¶ä½

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int count = 32; // ç›´æ¥è®¾ç½®ä¸º32ï¼Œæ— éœ€å¾ªç¯è®¡ç®—
        long sum = 0;
        while (n != 0 && count > 0) {
            if (n & 1) {
                sum |= (1 << (count - 1)); // ä½¿ç”¨ä½è¿ç®—ä»£æ›¿æ±‚å¹‚æ“ä½œ
            }
            count -= 1;
            n >>= 1;
        }
        return sum;
    }
};

```

`sum |= (1 << (count - 1));` æ˜¯ä¸€ä¸ªä½è¿ç®—æ“ä½œï¼Œç”¨äºå°† `sum` çš„ç¬¬ `(count-1)` ä½è®¾ç½®ä¸º1ã€‚(ä»ç¬¬0ä½å¼€å§‹è®¡æ•°)

1. `(count - 1)` è®¡ç®—å‡ºè¦è®¾ç½®çš„ä½çš„ä½ç½®ã€‚åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œæœ€ä½ä½çš„ä½ç½®æ˜¯0ï¼Œä¾æ¬¡é€’å¢ã€‚
2. `1 << (count - 1)` æ˜¯å°†æ•°å­—1å·¦ç§» `(count - 1)` ä½ã€‚è¿™å®é™…ä¸Šæ˜¯åœ¨äºŒè¿›åˆ¶ä¸­å°†1ç§»åŠ¨åˆ°æŒ‡å®šçš„ä½ç½®ï¼Œå…¶ä½™ä½å¡«å……ä¸º0ã€‚
3. `sum |= (1 << (count - 1));` åˆ©ç”¨ `|=` æŒ‰ä½æˆ–ç­‰äºæ“ä½œç¬¦ï¼Œå°† `sum` çš„ç¬¬ `(count-1)` ä½è®¾ç½®ä¸º1ã€‚å¦‚æœ `sum` çš„è¿™ä¸€ä½åŸæœ¬æ˜¯0ï¼Œå®ƒå°†å˜ä¸º1ï¼›å¦‚æœåŸæœ¬æ˜¯1ï¼Œåˆ™ä¿æŒä¸å˜ã€‚

#### æ£€æµ‹å¥‡å¶æ€§

```c++
#include <iostream>

int main() {
    int number;

    std::cout << "Enter an integer: ";
    std::cin >> number;

    if (number & 1) {
        std::cout << "The number is odd." << std::endl;
    }
    else {
        std::cout << "The number is even." << std::endl;
    }

    return 0;
}

```



#### å¾ªç¯ä½ç§»

```c++
#include <iostream>
//ä¸è€ƒè™‘äºŒè¿›åˆ¶è´Ÿæ•°

int leftRotate(unsigned int value, int shift) {
    // ä½¿ç”¨ä½è¿ç®—å®ç°å·¦å¾ªç¯ä½ç§»
    return (value << shift) | (value >> (sizeof(value) * 8 - shift));
}

int main() {
    unsigned int number = 0b110110;  // äºŒè¿›åˆ¶è¡¨ç¤ºä¸º 110110

    // å·¦å¾ªç¯ä½ç§»3ä½
    unsigned int rotatedNumber = leftRotate(number, 3);
    return 0;
}

```



1. `(value << shift)`: è¿™éƒ¨åˆ†å°† `value` å·¦ç§» `shift` ä½ï¼Œå³å°†äºŒè¿›åˆ¶æ•°å·¦ç§» `shift` ä½ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ `value` æ˜¯ `110110`ï¼Œè€Œ `shift` æ˜¯ `3`ï¼Œé‚£ä¹ˆè¿™éƒ¨åˆ†çš„ç»“æœå°±æ˜¯ `110`ã€‚
2. `(value >> (sizeof(value) * 8 - shift))`: è¿™éƒ¨åˆ†æ˜¯å°† `value` å³ç§» `(sizeof(value) * 8 - shift)` ä½ã€‚`sizeof(value)` è¿”å›çš„æ˜¯ `value` å˜é‡æ‰€å ç”¨çš„å­—èŠ‚æ•°ï¼Œé€šå¸¸ä¸º 4ï¼ˆ32 ä½ç³»ç»Ÿï¼‰æˆ– 8ï¼ˆ64 ä½ç³»ç»Ÿï¼‰ã€‚å› æ­¤ï¼Œ`(sizeof(value) * 8)` è¿”å›çš„æ˜¯ `value` å˜é‡æ‰€å ç”¨çš„ä½æ•°ã€‚`(sizeof(value) * 8 - shift)` å°±æ˜¯å‰©ä½™çš„ä½æ•°ï¼Œå³å³ç§»çš„ä½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ `value` æ˜¯ `110110`ï¼Œè€Œ `shift` æ˜¯ `3`ï¼Œé‚£ä¹ˆè¿™éƒ¨åˆ†çš„ç»“æœå°±æ˜¯ `110000000`ã€‚
3. `|`: è¿™æ˜¯æŒ‰ä½æˆ–æ“ä½œç¬¦ï¼Œå®ƒä¼šå°†ä¸¤ä¸ªæ“ä½œæ•°çš„å¯¹åº”ä½è¿›è¡Œæˆ–æ“ä½œï¼Œå³åªè¦æœ‰ä¸€ä¸ªä½æ˜¯ 1ï¼Œç»“æœçš„å¯¹åº”ä½å°±æ˜¯ 1ã€‚

1. 





# å­—ç¬¦ä¸²

### 15å±Šè“æ¡¥æ¯Ræ ¼å¼

é«˜ç²¾åº¦åŠ æ³•åŠ é«˜ç²¾åº¦ä¹˜æ³•åŠ å¿«é€Ÿå¹‚

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0);
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? "0" : ans;
}

int finddot(double d) {
    string dd = to_string(d);
    int i = 0;
    i = dd.find('.');
    return dd.size() - 1 - i;

}

string quickmultiple(int n) {
    string ans = "1";
    string b = "2";
    while (n) {
        if (n & 1) {
            ans = multiple(ans, b);
        }
        b = multiple(b,b);
        
        n >>=1;
    }
    return ans;
}

//å†å†™ä¸€ä¸ªé«˜ç²¾åº¦åŠ æ³•ï¼Œä¸‡ä¸€æ˜¯999.5
int main() {
    int n;
    string d;
    cin >> n >> d;
    int dotindex = d.find('.');
    int count = d.size() - dotindex - 1;
    d.erase(d.begin() + dotindex, d.begin() + dotindex + 1);
    string two = quickmultiple(n);
    string ans = multiple(two, d);
   
    //ä¸æ˜¯ç®€å•çš„å‘ä¸Šå–æ•´
    int judge = ans[ans.size() - count] - '0';
    if (judge > 4) {
        int carry = 1;
        int n = ans.size()-count;
        while (n--) {      
           int sum= ans[n] -'0'+carry;
           ans[n] = sum % 10 + '0';
           carry = sum / 10;
        }
        if (carry != 0) {
            ans.insert(ans.begin(), carry % 10 + '0');
        }

        ans.resize(ans.size() - count);

        cout << ans;
        
    }
    else {
        ans.resize(ans.size() - count);
        cout << ans;

    }
    
    return 0;
}

```





### åå…­è¿›åˆ¶è½¬å…«è¿›åˆ¶

æ•°æ®èŒƒå›´ï¼šä¿è¯æ¯ä¸ªåå…­è¿›åˆ¶æ•°ï¼Œä½æ•°ä¸å¤šä½™100000ä½

ç¬¬ä¸€è¡Œè¾“å…¥nè¡¨ç¤ºæœ‰nä¸ªåå…­è¿›åˆ¶æ•°

ç¬¬2-n+1è¡Œè¾“å…¥åå…­è¿›åˆ¶æ•°



//éœ€è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªæ•°å¤ªå¤§ï¼Œæˆ‘ä»¬åªèƒ½é€šè¿‡å­—ç¬¦ä¸²è¯»å–

```c++
#include<bits/stdc++.h>
using namespace std;
string hextobin(string hexstring) {
	string binstring;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': binstring += "0000";
			break;
		case '1': binstring += "0001";
			break;
		case '2': binstring += "0010";
			break;
		case '3': binstring += "0011"; 
			break;
		case '4': binstring += "0100";
			break;
		case '5': binstring += "0101";
			break;
		case '6': binstring += "0110";
			break;
		case '7': binstring += "0111";
			break;
		case '8': binstring += "1000";
			break;
		case '9': binstring += "1001";
			break;
		case 'A': binstring += "1010";
			break;
		case 'B': binstring += "1011";
			break;
		case 'C': binstring += "1100";
			break;
		case 'D': binstring += "1101";
			break;
		case 'E': binstring += "1110";
			break;
		case 'F': binstring += "1111";
			break;
		}
	}
	return binstring;
}

string bintooct(string binstring){
	string octstring;
	int n=binstring.size();
	string tmp;
	int tmpt;
	for(int i=0;i<n;i+=3){
		tmp=binstring.substr(i,3);
		tmpt=((tmp[0]-'0')*pow(2,2))+((tmp[1]-'0')*pow(2,1))+(tmp[2]-'0');
		octstring+=tmpt+'0';
	}
	return octstring;
}
int main() {
	int n;
	cin >> n;
	string hexstring,binstring,octstring;
	for (int i = 0; i < n; i++) {
		cin >> hexstring;
		binstring=hextobin(hexstring);
		int addzero=3-(binstring.size()%3);
		binstring.insert(0,addzero,'0');
		octstring=bintooct(binstring);
		cout<<octstring<<endl;
	}

	return 0;

}

```



### åå…­è¿›åˆ¶è½¬åè¿›åˆ¶

é¢˜ç›®æ¡ä»¶æ˜¯ä¸å¤§äºå…«ä½çš„åå…­è¿›åˆ¶æ•°ï¼Œå…«ä½çš„æœ€å¤§å€¼æ˜¯FFFFFFFFï¼Œæ°å¥½æ˜¯64ä½intçš„æœ€å¤§å€¼

```c++
#include<bits/stdc++.h>
using namespace std;
int hextodec(string hexstring){
	string decstring;
	int ans;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': ans+=0;
			break;
		case '1': ans+=pow(16,n-i-1);
			break;
		case '2': ans+=2*pow(16,n-i-1);
			break;
		case '3': ans+=3*pow(16,n-i-1); 
			break;
		case '4': ans+=4*pow(16,n-i-1);
			break;
		case '5': ans+=5*pow(16,n-i-1);
			break;
		case '6': ans+=6*pow(16,n-i-1);
			break;
		case '7': ans+=7*pow(16,n-i-1);
			break;
		case '8': ans+=8*pow(16,n-i-1);
			break;
		case '9': ans+=9*pow(16,n-i-1);
			break;
		case 'A': ans+=10*pow(16,n-i-1);
			break;
		case 'B': ans+=11*pow(16,n-i-1);
			break;
		case 'C': ans+=12*pow(16,n-i-1);
			break;
		case 'D': ans+=13*pow(16,n-i-1);
			break;
		case 'E': ans+=14*pow(16,n-i-1);
			break;
		case 'F': ans+=15*pow(16,n-i-1);
			break;
			}
		}
	return ans;	
}



int main() {
	string hexstring;
    int decstring;
    cin >> hexstring;
	decstring=hextodec(hexstring);
	cout<<decstring;

	return 0;

}
```



### åè¿›åˆ¶è½¬16è¿›åˆ¶

é¢˜ç›®è¦æ±‚çš„æ˜¯è¯¥æ•°å­—åœ¨intçš„èŒƒå›´ä¹‹å†…

å·æ‡’åšæ³•ï¼š

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	cout<<hex<<num;
	return 0;

}
```



è¾—è½¬ç›¸é™¤

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	string hexstring="";
	while(num>0){
		int x=num%16;
		switch(x){
			case 0: hexstring.insert(0,"0");
				break;
			case 1: hexstring.insert(0,"1");
				break;
			case 2: hexstring.insert(0,"2");
				break;
			case 3: hexstring.insert(0,"3");
				break;
			case 4: hexstring.insert(0,"4");
				break;
			case 5: hexstring.insert(0,"5");
				break;
			case 6: hexstring.insert(0,"6");
				break;
			case 7: hexstring.insert(0,"7");
				break;
			case 8: hexstring.insert(0,"8");
				break;
			case 9: hexstring.insert(0,"9");
				break;
			case 10: hexstring.insert(0,"A");
				break;
			case 11: hexstring.insert(0,"B");
				break;
			case 12: hexstring.insert(0,"C");
				break;
			case 13: hexstring.insert(0,"D");
				break;
			case 14: hexstring.insert(0,"E");
				break;
			case 15: hexstring.insert(0,"F");
				break;
		}
		num/=16;  
	}
	cout<<hexstring;
	
	return 0;

}
```

å¦‚æœéœ€è¦æ’åºå­—å…¸åºçš„ï¼Œæœ‰æ—¶å€™å¯ä»¥åˆ©ç”¨æ•°ç»„ï¼Œæ•°ç»„ä¸‹æ ‡è¡¨ç¤ºå­—å…¸åºï¼Œå› ä¸º'a'çš„ASCIIç æ˜¯97ï¼Œzçš„ASCIIç æ˜¯122ï¼Œæ‰€ä»¥éƒ½å‡å»97ï¼Œå¾—åˆ°1~25çš„å€¼

### è“æ¡¥æ—¥æœŸé—®é¢˜ï¼ˆ103ï¼‰

![image-20240227213938918](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240227213938918.png)

```c++
#include<iostream>
using namespace std;
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//æ£€æŸ¥æ—¥æœŸæ˜¯å¦åˆæ³•
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
int main() {
	int a, b, c;
	scanf("%d/%d/%d", &a, &b, &c);//ç¬¬ä¸€æ­¥æ ¼å¼è¾“å…¥
	for (int i = 19600101; i <= 20591231; i++) {
		int y = i / 10000;//i/10000çš„æ„æ€æ˜¯ä»åé¢æˆªæ–­å››ä½æ•°ï¼Œèˆå»ï¼Œåªç•™å‰é¢çš„
		int m = i % 10000 / 100;//i%10000çš„æ„æ€æ˜¯ä»åé¢æˆªæ–­å››ä½æ•°ï¼Œåªç•™åé¢çš„
		int d = i % 100;//æ±‚ä¸€ä¸ªæ•°çš„åä¸¤ä½
		if (check(y, m, d)) {
			if ((y % 100 == a && m == b && d == c) || (y % 100 == c && m == b && d == a) ||
				(y % 100 == c && m == a && d == b)) {
				printf("%d-%02d-%02d\n", y, m, d);//æ³¨æ„æ ¼å¼æ‰“å°
			}
		}

	}
}
```

å¸¸è§çš„åˆ¤æ–­æ—¥æœŸæ˜¯å¦åˆæ³•å¯ä»¥ç”¨åˆ°çš„ä»£ç 

```c++
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//æ£€æŸ¥æ—¥æœŸæ˜¯å¦åˆæ³•
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
```



### åŠ›æ‰£åˆ¤æ–­å›æ–‡ä¸²

åˆ¤æ–­ä¸€ä¸ªä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼šåŒæŒ‡é’ˆ

```c++
bool check(string s){
    for(int i=0;j=s.size()-1;i<j;i++,j--){
        if(s[i]!=s[j]) return false;
    }
    return true;
}
```

### è“æ¡¥åˆ·é¢˜ç»Ÿè®¡2098

nçš„å¤§å°ç»™åˆ°äº†10e18,è¦å¼€long long

```c++
#include <iostream>
using namespace std;
typedef long long ll;
int main()
{
  // è¯·åœ¨æ­¤è¾“å…¥æ‚¨çš„ä»£ç 
  ll a,b,n;
  scanf("%lld%lld%lld",&a,&b,&n);
  ll m=a*5+b*2;
  ll wsum=n/m;
  ll ans=wsum*7;
  n%=m;
  int w=1;
  while(n>0){
    if(w==8){
      w=1;
    }
    if(w<=5){//å¦‚æœä»Šå¤©åœ¨å‘¨ä¸€åˆ°å‘¨äº”
      n-=a;
    }
    else{//å¦‚æœä»Šå¤©åœ¨å‘¨æœ«
      n-=b;
    }
    w++;
    ans++;
  }
  printf("%lld",ans);


  return 0;
}
```



### åŠ›æ‰£äº¤æ¢å­—ç¬¦ä¸²

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ s çš„å½¢å¼ç»™å‡ºã€‚

ä¸è¦ç»™å¦å¤–çš„æ•°ç»„åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œä½ å¿…é¡»åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´è§£å†³è¿™ä¸€é—®é¢˜ã€‚

**åŒæŒ‡é’ˆ**

```java
    public void reverseString(char[] s) {
        int length = s.length;
        //ä¸¤ä¸ªæŒ‡é’ˆä¸€ä¸ªä»ç¬¬1ä¸ªï¼Œä¸€ä¸ªä»æœ€åä¸€ä¸ªå¼€å§‹ï¼Œ
        //ä¸¤ä¸¤äº¤æ¢
        int left = 0;
        int right = length - 1;
        while (left < right) {
            swap(s, left++, right--);
        }
    }

    private void swap(char[] array, int i, int j) {
        //ç¬¬1ç§äº¤æ¢æ–¹å¼
        char temp = array[i];
        array[i] = array[j];
        array[j] = temp;

        //ç¬¬2ç§äº¤æ¢æ–¹å¼
//        array[i] = (char) (array[i] + array[j]);
//        array[j] = (char) (array[i] - array[j]);
//        array[i] = (char) (array[i] - array[j]);

        //ç¬¬3ç§äº¤æ¢æ–¹å¼
//        array[i] = (char) (array[i] - array[j]);
//        array[j] = (char) (array[i] + array[j]);
//        array[i] = (char) (array[j] - array[i]);

        //ç¬¬4ç§äº¤æ¢æ–¹å¼
//        array[i] ^= array[j];
//        array[j] ^= array[i];
//        array[i] ^= array[j];
    }


```





```c++
#include<iostream>
#include<vector>
using namespace std;
class Solution {
public:
    void reverseString(vector<char>& s) {
        if (s.empty() || s.size() == 0)
        {
            return;
        }
        reverseStringhelper(s, 0, s.size() - 1);
    }
    void reverseStringhelper(vector<char>& s, int left, int right)
    {
        if (left >= right)
        {
            return;
        }
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        reverseStringhelper(s, ++left, --right);
    }
};
```

### åŠ›æ‰£ç¿»è½¬æ•°å­—

core:**åˆ¤æ–­æ•´æ•°æº¢å‡º**

```java
//ä½•å…¶å¹¸è¿èƒ½å¤Ÿå­¦ä¹ åˆ°å¦‚æ­¤ç¾å¦™çš„ç®—æ³•!!!!
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0) {
            //æ¯æ¬¡å–æœ«å°¾æ•°å­—
            int tmp = x%10;
            //åˆ¤æ–­æ˜¯å¦ å¤§äº æœ€å¤§32ä½æ•´æ•°
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //åˆ¤æ–­æ˜¯å¦ å°äº æœ€å°32ä½æ•´æ•°
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
    }
}
```

### åŠ›æ‰£å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` ï¼Œæ‰¾åˆ° *å®ƒçš„ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦ï¼Œå¹¶è¿”å›å®ƒçš„ç´¢å¼•* ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å› `-1` 

```c++
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<int, int> frequency;
        for (char ch: s) {
            ++frequency[ch];
        }
        for (int i = 0; i < s.size(); ++i) {
            if (frequency[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};

```

### è“æ¡¥å­—ç¬¦ä¸²è½¬åŒ–æˆæ•´æ•°

![image-20240302195337802](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302195337802.png)

1.**å­—ç¬¦ä¸²å»é™¤å‰å¯¼ç©ºæ ¼**

cinè¾“å…¥è‡ªåŠ¨å»é™¤ç©ºæ ¼ï¼ï¼ï¼

**è½¬åŒ–æˆæ•°å­—æ—¶åˆ¤æ–­æº¢å‡º**

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231205163818189.png" alt="image-20231205163818189" style="zoom: 80%;" />



**å®Œæ•´ä»£ç **

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s;
    cin >> s;

    // åˆ¤æ–­æ˜¯å¦ä¸ºç©ºå­—ç¬¦ä¸²
    if (s.empty()) {
        cout << 0;
        return 0;
    }

    int i = 0;
    bool flag = true; // é»˜è®¤ä¸ºæ­£æ•°
    int res = 0;

    // å¤„ç†è´Ÿå·
    if (s[0] == '-') {
        flag = false;
        i++;
    }

    // å»é™¤å‰å¯¼é›¶
    while (i < s.size() && s[i] == '0') {
        i++;
    }

    // å¤„ç†æ•°å­—éƒ¨åˆ†
    while (i < s.size()) {
        int tmp = s[i] - '0';

        // åˆ¤æ–­æ˜¯å¦ä¼šæº¢å‡º
        if ((res > INT_MAX / 10) || (res == INT_MAX / 10 && tmp > INT_MAX % 10)) {
            cout << (flag ? INT_MAX : INT_MIN);
            return 0;
        }

        // æ›´æ–°ç»“æœ
        res = res * 10 + tmp;
        i++;
    }

    cout << (flag ? res : -res);
    return 0;
}

```

**è‡ªåŠ¨æœºåšæ³•**

```python
INT_MAX = 2 ** 31 - 1
INT_MIN = -2 ** 31

class Automaton:
    def __init__(self):
        self.state = 'start'
        self.sign = 1
        self.ans = 0
        self.table = {
            'start': ['start', 'signed', 'in_number', 'end'],
            'signed': ['end', 'end', 'in_number', 'end'],
            'in_number': ['end', 'end', 'in_number', 'end'],
            'end': ['end', 'end', 'end', 'end'],
        }
        
    def get_col(self, c):
        if c.isspace():
            return 0
        if c == '+' or c == '-':
            return 1
        if c.isdigit():
            return 2
        return 3

    def get(self, c):
        self.state = self.table[self.state][self.get_col(c)]
        if self.state == 'in_number':
            self.ans = self.ans * 10 + int(c)
            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)
        elif self.state == 'signed':
            self.sign = 1 if c == '+' else -1

class Solution:
    def myAtoi(self, str: str) -> int:
        automaton = Automaton()
        for c in str:
            automaton.get(c)
        return automaton.sign * automaton.ans


```

### è“æ¡¥ä¸²çš„å¤„ç†

![image-20240208145227753](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208145227753.png)

**1.è¾“å…¥ï¼Œcinå’Œscanfä¸€æ ·ï¼Œä¼šæˆªæ–­ç©ºæ ¼**

**2.è¾“å‡º,è®°å¾—coutè¾“å‡ºå˜é‡æ—¶ä¼šè¾“å‡ºå­—ç¬¦ï¼Œä½†æ˜¯å¦‚æœåªæ˜¯ä¸€ä¸ªè®¡ç®—ç»“æœï¼Œå¦‚cout<<s-32æ­¤æ—¶ä¼šè¾“å‡ºæ•°å­—,æ‰€ä»¥åœ¨æœ¬é¢˜è§£ä¸­è¿›è¡Œäº†ç±»å‹è½¬æ¢**

```c++
#include<iostream>
#include<string>
using namespace std;
void change(char& ch) {
	ch = ch - 32;//æŠŠå°å†™å­—æ¯å¤§å†™
}
int main() {
	string ss;
	getline(cin, ss);//getlineä¹Ÿæ²¡æœ‰æˆªæ–­çš„ç‰¹æ€§ï¼Œå³æ¥æ”¶ç©ºæ ¼
	int len = ss.length();
	if (isalpha(ss[0])) {
		change(ss[0]);
	}
	for (int i = 0, j = 1; i < len; i++, j++) {
		if (ss[i] == ' '&&j<len) {
			if (ss[j] == ' ') continue;
			else {
				//å¦‚æœss[i]æ˜¯ç©ºæ ¼è€Œss[j]ä¸æ˜¯ç©ºæ ¼ï¼Œè¯´æ˜æ˜¯å•è¯å¼€å¤´
				cout << ss[i];
				change(ss[j]);
			}
		}
		else if ((isdigit(ss[i]) && isalpha(ss[j])) || (isalpha(ss[i]) && isdigit(ss[j]))) {
			cout << ss[i] << '_';
		}

		else {
			cout << ss[i];
		}
		
	}
	return 0;
}
```

### è“æ¡¥å¯†æ–‡æœç´¢

![image-20240208180432011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208180432011.png)



```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
map<string, int>mp;
string str, s;
int n;
int main() {
	cin >> str >> n;
	while (n--) {
		cin >> s;
		sort(s.begin(), s.end());
		mp[s]++;
	}
	int ans=0;
	cout << endl;
	for (int i = 0; i <= str.size() - 8; i++) {
		string t = str.substr(i, 8);
		sort(t.begin(), t.end());
		ans += mp[t];
	}

	return 0;
}
```



### å“ˆå¸Œè¡¨å®ä¾‹

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å®šä¹‰å“ˆå¸Œè¡¨çš„èŠ‚ç‚¹ç»“æ„
typedef struct Node {
    char key;
    int count;
    struct Node* next;
} Node;

// å®šä¹‰å“ˆå¸Œè¡¨ç»“æ„
typedef struct {
    Node** array;
    int size;
} HashMap;

// åˆå§‹åŒ–å“ˆå¸Œè¡¨
HashMap* initHashMap(int size) {
    //é—®é¢˜ä¸€
    //å¤´èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨æŒ‡é’ˆï¼Œåˆå§‹åŒ–ä¸ç”¨å¼€è¾Ÿå¤šä½™ç©ºé—´ï¼ï¼ï¼
    HashMap* hashMap = (HashMap*)malloc(sizeof(HashMap));
    if (hashMap == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    hashMap->size = size;
    
    //é—®é¢˜äºŒï¼Œä¸€èˆ¬éƒ½ç”¨ä¸€ä¸ªäºŒç»´æŒ‡é’ˆæ¥å­˜å‚¨å“ˆå¸Œæ¡¶ï¼Œç»è¿‡æˆ‘æµªè´¹çš„æ—¶é—´æ¥çœ‹ï¼Œè¿™æ ·æ„å»ºæ¯”è¾ƒç®€å•ï¼ï¼ï¼
    //æ³¨æ„äºŒç»´æ•°ç»„çš„æ„å»ºå“¦ï¼Œè¿™é‡Œä½¿ç”¨äº†callocå‡½æ•°ä¸€æ¬¡åˆ°ä½äº†ï¼Œå¦åˆ™è¿˜è¦å¤šä¸€ä¸ªforå¾ªç¯æ¥å®ç°äºŒç»´æ•°ç»„çš„åŠ¨æ€åˆ†é…å†…å­˜
    hashMap->array = (Node**)calloc(size, sizeof(Node*));
    if (hashMap->array == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    return hashMap;
}

// å“ˆå¸Œå‡½æ•°ï¼Œç®€å•åœ°è¿”å›å­—ç¬¦çš„ASCIIç å¯¹å“ˆå¸Œè¡¨å¤§å°å–ä½™
int hashFunction(char key, int size) {
    return (int)key % size;
}

// åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾èŠ‚ç‚¹
Node* findNode(HashMap* hashMap, char key) {
    //é¦–å…ˆæ‰¾åˆ°å“ˆå¸Œæ¡¶ä¸­å¯¹åº”çš„çš„ä½ç½®
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];

    //åœ¨è¯¥ä½ç½®ä¸­æ‰¾æ˜¯å¦æœ‰ç¬¦åˆæ¡ä»¶çš„
    while (current != NULL) {
        if (current->key == key) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

// æ’å…¥èŠ‚ç‚¹æˆ–æ›´æ–°è®¡æ•°
void insertOrUpdate(HashMap* hashMap, char key) {
    //è€è§„çŸ©ï¼Œæ‰¾åˆ°å“ˆå¸Œæ¡¶ä¸­å¯¹åº”çš„ä½ç½®
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];
    //æŸ¥æ‰¾ï¼Œçœ‹æ˜¯å¦æ‰¾åˆ°ï¼Œå¦‚æœåŸç»“æ„ä¸­å·²ç»æœ‰äº†ï¼Œå°±è®¡æ•°åŠ ä¸€
    Node* node = findNode(hashMap, key);

    if (node != NULL) {
        // èŠ‚ç‚¹å·²å­˜åœ¨ï¼Œæ›´æ–°è®¡æ•°
        node->count++;
    } 
    //å¦‚æœæ²¡æ‰¾åˆ°ï¼Œéœ€è¦å¤´æ’æ³•åŠ å…¥å“ˆå¸Œæ¡¶å¯¹åº”çš„ä½ç½®ä¸­å»å“¦
    else {
        // èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œæ’å…¥æ–°èŠ‚ç‚¹
        Node* newNode = (Node*)malloc(sizeof(Node));
        if (newNode == NULL) {
            perror("Memory allocation failed");
            exit(EXIT_FAILURE);
        }

        newNode->key = key;
        newNode->count = 1;
        
        //å¤´æ’æ³•
        newNode->next = current;
        hashMap->array[index] = newNode;
    }
}

// ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°
void countCharacters(HashMap* hashMap, const char* str) {
    while (*str != '\0') {
        insertOrUpdate(hashMap, *str);
        str++;
    }
}

// æ‰“å°å“ˆå¸Œè¡¨å†…å®¹
void printHashMap(HashMap* hashMap) {
    printf("Character Counts:\n");
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            printf("'%c': %d\n", current->key, current->count);
            current = current->next;
        }
    }
}

// é‡Šæ”¾å“ˆå¸Œè¡¨çš„å†…å­˜
void freeHashMap(HashMap* hashMap) {
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            Node* next = current->next;
            free(current);
            current = next;
        }
    }
    free(hashMap->array);
    free(hashMap);
}

int main() {
    const char* inputString = "programming";
    int hashMapSize = 10;

    HashMap* hashMap = initHashMap(hashMapSize);

    countCharacters(hashMap, inputString);

    printHashMap(hashMap);

    freeHashMap(hashMap);

    return 0;
}

```



### åŠ›æ‰£67äºŒè¿›åˆ¶æ±‚å’Œ

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int la=a.size();
        int lb=b.size();
        while(la<lb){
            a='0'+a;
            ++la;    
        }
        while(lb<la){
            b='0'+b;
            ++lb;         
        }
        
        int j=b.size()-1;
        for(j;j>0;j--){
            a[j]=a[j]-'0'+b[j];//æŠŠå­—ç¬¦ä¸²è½¬åŒ–æˆæ•°å­—ç›¸åŠ å†è½¬åŒ–å›æ¥
            if(a[j]>='2'){
                a[j]=(a[j]-'0')%2+'0';
                a[j-1]=a[j-1]+1;//æ³¨æ„è¿™é‡Œï¼å­—ç¬¦2å’Œå­—ç¬¦1çš„ASCIIç åªç›¸å·®1

            }            
        }
        
        //æ¶‰åŠåˆ°è¿›ä½é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å•ç‹¬æŠŠç¬¬é›¶ä½æ‹¿å‡ºæ¥ç®—
        a[0]=a[0]-'0'+b[0];
        if(a[0]>='2'){
                a[0]=(a[0]-'0')%2+'0';
                a='1'+a;

            }
            return a;
    }
};
```





### å»é™¤ä¸¤ç«¯ç©ºæ ¼

```c++
int main() {
    string s = "     hello    ";
    int i = 0;
    for (i; s[i] == ' '; i++);
    int j = 0;
    for (j = s.size(); s[j] == ' '; --j);
    int n = j - i + 1;
    s = s.substr(i, n);
    cout << s;
}

```

### å»é™¤é€‚å½“ç©ºæ ¼ï¼Œä½¿å­—ç¬¦ä¸²è¡¨ç¤ºä¸€ä¸ªæ­£ç¡®çš„å¥å­

```c++
#include <iostream>
#include <sstream>
using namespace std;
void trim(string &s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    ä½ å¥½       ä¸–ç•Œ   å·´æ‹‰å·´æ‹‰     ";
    trim(s);
    int i = 0;
    while (i < s.size()) {
        if (s[i] == ' ') {
            int j = i;
            while (s[j] == ' ') j++;
            s.replace(i, j-i, " ");
            i+=1;
            continue;
        }
        i++;      
    }
    cout << s;   
    return 0;
}



```



### åŠ›æ‰£500é”®ç›˜è¡Œ

å˜åŒ–çš„å“ˆå¸Œè¡¨ï¼Œé¢˜è§£è®¾ç½®äº†æ¯ä¸ªå­—æ¯æ‰€åœ¨çš„è¡Œå·ï¼Œä½¿å¾—æŸ¥è¯¢å˜å¾—å¿«æ·

éå†å•¦

```c++
class Solution {
public:
    vector<string> findWords(vector<string>& words) {
        vector<string> ans;
        string rowIdx = "12210111011122000010020202";
        for (auto & word : words) {
            bool isValid = true;
            char idx = rowIdx[tolower(word[0]) - 'a'];
            for (int i = 1; i < word.size(); ++i) {
                if(rowIdx[tolower(word[i]) - 'a'] != idx) {
                    isValid = false;
                    break;
                }
            }
            if (isValid) {
                ans.emplace_back(word);
            }
        }
        return ans;
    }
};

```

### å»é™¤å­—ç¬¦ä¸²æŒ‡å®šå­—ç¬¦

æ¯”å¦‚æˆ‘æƒ³å»é™¤å­—ç¬¦ä¸²é‡Œé¢çš„ç©ºæ ¼

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

void trim(string& s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    ä½ å¥½       ä¸–ç•Œ   å·´æ‹‰å·´æ‹‰     ";
    trim(s);
    int i = 0;
    int k = 0;
    int n = s.size();
    while (i < n) {
        if (s[i] == ' ') k++;
        else s[i - k] = s[i];
        i++;
    }
    s.resize(n - k);
    cout << s;
    return 0;
}
```

### åŠ›æ‰£100330æ“ä½œåå­—ç¬¦ä¸²çš„æœ€çŸ­é•¿åº¦

å…ˆçœ‹ä¸¤ä¸ªä»£ç ï¼Œæˆ‘çœŸçš„ç ´é˜²äº†

```c++
class Solution {
public:
    int minimumLength(string s) {
        int n = s.size();
        unordered_map<char, int>a;
        int i = 0;
        while (i < s.size()) {
            a[s[i]]++;
            if (a[s[i]] == 3) {
                int k = 0;
                for (; s[k] != s[i]; k++);

                s.erase(k, 1);
                s.erase(i - 1, 1);
                a.clear();
                i = 0;

            }
            else i++;

        }

        return s.size();
    }
};
//è¿™ä¸ªæ˜¯ä½ å†™çš„ç‹—å±ä»£ç ï¼Œæ—¶é—´å¤æ‚åº¦å¤ªé«˜äº†
```





```c++
//è¿™ä¸ªæ˜¯åˆ«äººå†™çš„ä»£ç 
//åŸºæœ¬æ€è·¯å°±æ˜¯ï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°ï¼Œå¦‚æœè¯¥å­—ç¬¦å‡ºç°çš„æ¬¡æ•°å°äº3ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦çš„æ•°é‡å°±å…¨éƒ¨ä¿ç•™åœ¨æ“ä½œåçš„æ•°ç»„ä¸­
//å¦‚æœè¿™ä¸ªå­—ç¬¦çš„æ•°é‡å¤§äº3ï¼Œå¹¶ä¸”ä¸ªæ•°ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¼šè¢«åˆ é™¤åˆ°åªä¸º1ä¸ª
//å¦‚æœè¿™ä¸ªå­—ç¬¦çš„æ•°é‡å¤§äº3å¹¶ä¸”ä¸ªæ•°æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¼šè¢«åˆ é™¤åˆ°åªæœ‰2ä¸ª

class Solution {
public:
    int minimumLength(string s) {
        unordered_map<char,int>a;
        int n=s.size();
        for(int i=0;i<n;i++) a[s[i]]++;
        int cnt=0;

        for(auto i:a){
            if(i.second<3) cnt+=i.second;
            else if(i.second%2==1) cnt+=1;
            else cnt+=2;
        }
        return cnt;

    }
};
```



### åŠ›æ‰£100360å°†1ç§»åŠ¨åˆ°æœ«å°¾ä½ç½®çš„æœ€å¤§æ“ä½œæ¬¡æ•°

è¿™ä¸€é“é¢˜å’Œä¸Šé¢é‚£é“é¢˜æˆ‘è®°ä¸€è¾ˆå­ï¼Œç¾è¾±æˆ‘å•Šå•Šå•Šå•Š

æœ¬é¢˜çš„é¢˜è§£å…¶å®ä½ å·²ç»çŸ¥é“å¤§æ¦‚æ€ä¹ˆå†™äº†ï¼Œä½†æ˜¯æ€è·¯è¿˜æ˜¯ä¸å¤Ÿæ¸…æ™°

å…·ä½“è¯·çœ‹åˆ«äººå†™çš„æ¸…æ™°çš„ä»£ç 

```c++
class Solution {
public:
    int maxOperations(string s) {
        int n=s.size();
        int cnt=0;
        int cnt_num1=0;
        for(int i=0;i<n;i++){
            if(s[i]=='1') cnt_num1++;
            else if(i&&s[i-1]=='1'){
                cnt+=cnt_num1;
            }
        }
        return cnt;
        
    }
};
```

### æ‹¬å·åŒ¹é…

```c++
#include<iostream>
#include<string>
using namespace std;
typedef char ElemType;
const int MaxSize = 30;
typedef struct {
	ElemType data[MaxSize];
	int top;
}SqStack;

void init(SqStack*& s) {
	s = (SqStack*)malloc(sizeof(SqStack));
	s->top = -1;
}

void DestoryStack(SqStack*& s) {
	free(s);
}

bool StackEmpty(SqStack* s) {
	return s->top == -1;
}

bool push(SqStack*& s, ElemType e) {
	if (s->top == MaxSize) return false;
	else {
		s->top++;
		s->data[s->top] = e;
		return true;
	}
}

bool pop(SqStack*& s, ElemType& e) {
	if (s->top == -1) return false;
	else {
		s->top--;
		e = s->data[s->top];
		return true;
	}
}

bool GetTop(SqStack* s, ElemType& e) {
	if (s->top == -1) return false;
	e = s->data[s->top];
	return true;
}
bool BracketMatching(string s) {
	SqStack* a;
	init(a);
	int n = s.size();
	for (int i = 0; i < n; i++) {
		char ch = s[i];
		switch (ch) {
		case '(':
		case '[':
		case '{':
			push(a, ch);
			break;
		case ')':
			if (GetTop(a, ch)) {
				if (ch != '(') return false;
				pop(a, ch);
			}
			else return false;
			break;
		case ']':
			if (GetTop(a, ch)) {
				if (ch != '[') return false;
				pop(a, ch);
			}
			else return false;
			break;
		case '}':
			if (GetTop(a, ch)) {
				if (ch != '{') return false;
				pop(a, ch);
			}
			else return false;
			break;
		}
	}
	DestoryStack(a);
	return true;

}
```



# é¡ºåºè¡¨

å“‘èŠ‚ç‚¹dummyï¼Œå¦‚æœé¢˜ç›®ä¸ç»™å“¨å…µèŠ‚ç‚¹çš„è¯ï¼Œå¯ä»¥è‡ªå·±å¼€è¾Ÿä¸€ä¸ªï¼Œè®¡ç®—æ¯”è¾ƒæ–¹ä¾¿

### åŠ›æ‰£237åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹

```c
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
      
        
    }
};
```



### åŠ›æ‰£åˆå¹¶ä¸¤ä¸ªé“¾è¡¨



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
//æˆ‘æ˜¯å°çŒ«æ€ªï¼Œé‡åˆ°å¥½çš„é¢˜è§£åªä¼šå¤§å–Šï¼šå–µï¼ï¼ï¼ï¼ï¼ï¼
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* pstr1 = list1;
    struct ListNode* pstr2 = list2;
    struct ListNode* head = NULL; // ç”¨äºä¿å­˜åˆå¹¶åçš„é“¾è¡¨çš„å¤´æŒ‡é’ˆ
    struct ListNode* tail = NULL; // ç”¨äºä¿å­˜åˆå¹¶åçš„é“¾è¡¨çš„å°¾æŒ‡é’ˆ

    while (pstr1 && pstr2) {
        // æ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨çš„å½“å‰èŠ‚ç‚¹å€¼ï¼Œå°†è¾ƒå°å€¼çš„èŠ‚ç‚¹æ’å…¥åˆå¹¶åçš„é“¾è¡¨
        if (pstr1->val <= pstr2->val) {
            if (tail == NULL) {
                head = tail = pstr1;
            } else {
                tail->next = pstr1;
                tail = pstr1;
            }
            pstr1 = pstr1->next;
        } else {
            if (tail == NULL) {
                head = tail = pstr2;
            } else {
                tail->next = pstr2;
                tail = pstr2;
            }
            pstr2 = pstr2->next;
        }
    }

    // å¤„ç†å‰©ä½™çš„èŠ‚ç‚¹
    if (pstr1 != NULL) {
        if (tail == NULL) {
            head = pstr1;
        } else {
            tail->next = pstr1;
        }
    } else if (pstr2 != NULL) {
        if (tail == NULL) {
            head = pstr2;
        } else {
            tail->next = pstr2;
        }
    }

    return head;
}

```



### å¿«æ…¢æŒ‡é’ˆ

1.å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œå› ä¸ºæ…¢æŒ‡é’ˆèµ°çš„æ­¥æ•°ä¸€å®šæ˜¯å¿«æŒ‡é’ˆçš„ä¸€åŠï¼Œæ‰€ä»¥æ­¤æ—¶æ…¢æŒ‡é’ˆåœ¨é“¾è¡¨ä¸­éƒ¨

2.å¿«æŒ‡é’ˆå…ˆèµ°k-1æ­¥ï¼Œç„¶åæ…¢æŒ‡é’ˆå’Œå¿«æŒ‡é’ˆå†æ¯æ¬¡éƒ½èµ°ä¸€æ­¥ï¼Œå½“å¿«æŒ‡é’ˆåˆ°é“¾è¡¨å°¾éƒ¨æ—¶ï¼Œæ…¢æŒ‡é’ˆæ­¤æ—¶å°±åœ¨é“¾è¡¨çš„å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹

3.å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¦‚æœå¿«æ…¢æŒ‡é’ˆèƒ½ç›¸é‡ï¼Œè¯´æ˜é“¾è¡¨æœ‰ç¯ï¼Œæ­¤æ—¶è®©å¿«æŒ‡é’ˆé‡æ–°å›åˆ°å¤´æŒ‡é’ˆçš„ä½ç½®ç„¶åè®©å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡éƒ½èµ°ä¸€æ­¥ï¼Œä¸‹æ¬¡ç›¸é‡çš„èŠ‚ç‚¹å°±æ˜¯å…¥ç¯èŠ‚ç‚¹

![image-20240302230930445](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302230930445.png)

ç¬¬ä¸€æ¬¡ç›¸é‡ä¹‹åï¼Œå¦‚æœfastå›åˆ°å¤´èŠ‚ç‚¹ï¼Œåˆ™å®ƒèµ°äº†læ­¥æ—¶ï¼Œæ…¢æŒ‡é’ˆèµ°äº†ï¼ˆn-1ï¼‰+c-xæ­¥ï¼Œæ­£å¥½åœ¨å…¥ç¯èŠ‚ç‚¹



4.**fastèµ°3æ­¥ï¼Œ4æ­¥ï¼Œ5æ­¥æˆ–è€…èµ°næ­¥å‘¢ï¼Œè¯·è¯æ˜**

ç»“è®ºï¼šfastèµ°næ­¥nå¦‚æœå¤§äº2ï¼Œä¸ä¸€å®šä¼šç›¸é‡ã€‚

å¦‚æœfastä¸€æ¬¡èµ°ä¸‰æ­¥ã€‚ï¼Œslowè¿›ç¯ä»¥åï¼Œä»–ä»¬çš„è·ç¦»æ˜¯nã€‚

å‡è®¾næ˜¯å¶æ•°ï¼Œåˆ™å®ƒä»¬çš„è·ç¦»å˜åŒ–ï¼šn   n-2   n-4   n-6...2 0,å¦‚æœnæ˜¯å¥‡æ•°ï¼Œå®ƒä»¬çš„è·ç¦»å˜åŒ–ï¼šn   n-2   n-4   n-6...1 -1;æ‰€ä»¥å¦‚æœnæ˜¯å¶æ•°èƒ½è¿½ä¸Šï¼Œnæ˜¯å¥‡æ•°è¿½ä¸ä¸Š

å¦‚æœfastä¸€æ¬¡èµ°4æ­¥ï¼Œåˆ™å®ƒä»¬çš„è·ç¦»å˜åŒ–ä¸ºn   n-3   n-6...åŒä»¥ä¸Šåˆ†æ

### åŠ›æ‰£92ç¿»è½¬é“¾è¡¨2

ç©¿é’ˆå¼•çº¿ï¼Œå…ˆç¿»è½¬ç›®æ ‡é“¾è¡¨ï¼Œåœ¨æŠŠé“¾è¡¨è¿èµ·æ¥

```c++
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // ä¹Ÿå¯ä»¥ä½¿ç”¨é€’å½’åè½¬ä¸€ä¸ªé“¾è¡¨
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // å› ä¸ºå¤´èŠ‚ç‚¹æœ‰å¯èƒ½å‘ç”Ÿå˜åŒ–ï¼Œä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹å¯ä»¥é¿å…å¤æ‚çš„åˆ†ç±»è®¨è®º
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // ç¬¬ 1 æ­¥ï¼šä»è™šæ‹Ÿå¤´èŠ‚ç‚¹èµ° left - 1 æ­¥ï¼Œæ¥åˆ° left èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
        // å»ºè®®å†™åœ¨ for å¾ªç¯é‡Œï¼Œè¯­ä¹‰æ¸…æ™°
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // ç¬¬ 2 æ­¥ï¼šä» pre å†èµ° right - left + 1 æ­¥ï¼Œæ¥åˆ° right èŠ‚ç‚¹
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        // ç¬¬ 3 æ­¥ï¼šåˆ‡æ–­å‡ºä¸€ä¸ªå­é“¾è¡¨ï¼ˆæˆªå–é“¾è¡¨ï¼‰
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // æ³¨æ„ï¼šåˆ‡æ–­é“¾æ¥
        pre->next = nullptr;
        rightNode->next = nullptr;

        // ç¬¬ 4 æ­¥ï¼šåŒç¬¬ 206 é¢˜ï¼Œåè½¬é“¾è¡¨çš„å­åŒºé—´
        reverseLinkedList(leftNode);

        // ç¬¬ 5 æ­¥ï¼šæ¥å›åˆ°åŸæ¥çš„é“¾è¡¨ä¸­
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};


```

### åŠ›æ‰£86åˆ†éš”é“¾è¡¨

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smlDummy = new ListNode(0), *bigDummy = new ListNode(0);
        ListNode *sml = smlDummy, *big = bigDummy;
        while (head != nullptr) {
            if (head->val < x) {
                sml->next = head;
                sml = sml->next;
            } else {
                big->next = head;
                big = big->next;
            }
            head = head->next;
        }
        sml->next = bigDummy->next;
        big->next = nullptr;
        return smlDummy->next;
    }
};

```

### åŠ›æ‰£143é‡æ’é“¾è¡¨

```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        ListNode* mid = middleNode(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    void mergeList(ListNode* l1, ListNode* l2) {
        ListNode* l1_tmp;
        ListNode* l2_tmp;
        while (l1 != nullptr && l2 != nullptr) {
            l1_tmp = l1->next;
            l2_tmp = l2->next;

            l1->next = l2;
            l1 = l1_tmp;

            l2->next = l1;
            l2 = l2_tmp;
        }
    }
};

```

### åŠ›æ‰£82åˆ é™¤é‡å¤å…ƒç´ 

### åŠ›æ‰£155æœ€å°æ ˆ

### åŠ›æ‰£1249ç§»é™¤æ— æ•ˆçš„æ‹¬å·

æ€è·¯ï¼šå¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œé‚£ä¹ˆå°±å…¥æ ˆï¼Œå¦‚æœæ˜¯å³æ‹¬å·ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼Œæ ˆä¸ºç©ºï¼Œè¯´æ˜ä¹‹å‰çš„æ‹¬å·å®Œå…¨åŒ¹é…ï¼Œåˆ é™¤å³å¯ï¼Œå¦‚æœæ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜æ ˆé¡¶çš„å·¦æ‹¬å·å’Œè¯¥å³æ‹¬å·åŒ¹é…ï¼Œå‡ºæ ˆå·¦æ‹¬å·

```c++
class Solution {
public:
    string minRemoveToMakeValid(string s) {
        stack<int> braket;
        int sLen = s.size();
        for(int i =0; i<sLen ; ++i){
            if(s[i] == '(' || s[i] == ')'){
                if(s[i] == '(') braket.push(i);
                else if(braket.empty()) {
                    s.erase(i,1);
                    --sLen;//è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ„æ€çš„å†™æ³•
                    //ä¸€èˆ¬æ¥è¯´å› ä¸ºåˆ é™¤å­—ç¬¦ä¸²å…ƒç´ ä¹‹åï¼Œå­—ç¬¦ä¸²å¤§å°ä¼šæ”¹å˜ï¼Œæ‰€ä»¥forå¾ªç¯çš„æ¡ä»¶åº”è¯¥æ˜¯
                    //i<s.size()
                    //ä½†æ˜¯è¿™ä¸ªæ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜
                    //æ‰€ä»¥ä½¿ç”¨è¿™ä¸ªå˜é‡
                    --i;
                }
                else braket.pop();
            }
        }
        while(!braket.empty()){
            int i = braket.top();
            s.erase(i,1);
            braket.pop();
        }
        return s;
    }
};
```

### åŠ›æ‰£227åŸºæœ¬è¿ç®—å™¨

ä¸å¤šè¯´ï¼Œå®¡é¢˜ï¼Œé¢˜ç›®å·²ç»åŠ ç²—æ ‡é»‘äº†æ¡ä»¶ï¼Œæ²¡æœ‰è´Ÿæ•°ï¼Œæ²¡æœ‰æ‹¬å·ï¼Œç®€åŒ–æ¿çš„æ±‚åç¼€è¡¨è¾¾å¼å†æ±‚å€¼

æ³¨æ„æ ¹æ®åç¼€è¡¨è¾¾å¼æ±‚å€¼çš„æ—¶å€™ï¼Œ

int a=pop();

int b=pop();

ç»“æœéƒ½æ˜¯b-aã€‚è¿˜æœ‰é™¤é›¶é”™è¯¯çš„è§„é¿

### åŠ›æ‰£1441

æ ˆçš„ç‰¹ç‚¹ï¼Œå…ˆè¿›çš„å…ƒç´ ä¸€å®šå…ˆå‡ºï¼Œæ‰€ä»¥å¯¹äºä¸¥æ ¼é€’å¢åºåˆ—ï¼Œæƒ³è¦æ„å»º135è¿™æ ·çš„æ•°ç»„ï¼Œå¿…é¡»è¦è¿›æ ˆ2ï¼Œå†å‡ºæ ˆ2ï¼Œè¿›æ ˆ4ï¼Œå†å‡ºæ ˆ4è¿™æ ·

### è¿”å›å…ƒç´ ç¬¬Kå¤§å…ƒç´ 

```c++
#include<bits/stdc++.h>
int main(){
    priority_queue<int>a;
    vector<int>b;
    for(int num:b){
        a.push(num);
        if(a.size()>k) a.pop();
    }
    return a.top();
}
```

### åŠ›æ‰£2ä¸¤æ•°ç›¸åŠ 



# æ•°å­¦/è®¾è®¡

### æœ€å°å…¬å€æ•°

æ•°å­¦ä¸Šï¼šæ±‚A  Bçš„æœ€å°å…¬å€æ•°=A*B/GCD(æœ€å¤§å…¬çº¦æ•°)

### æœ€å¤§å…¬çº¦æ•°

è¾—è½¬ç›¸é™¤ç®—æ³•

è¾—è½¬ç›¸é™¤æ³•ä¸€èˆ¬æŒ‡æ¬§å‡ é‡Œå¾—ç®—æ³•ã€‚æ˜¯æŒ‡ç”¨äºè®¡ç®—ä¸¤ä¸ªéè´Ÿæ•´æ•°aï¼Œbçš„æœ€å¤§å…¬çº¦æ•°ã€‚é‚£ä¹ˆè¾—è½¬ç›¸é™¤æ³•çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ

1ã€ åŸç†ï¼šè®¾ä¸¤æ•°ä¸ºaã€b(ab)ï¼Œç”¨gcd(aï¼Œb)è¡¨ç¤ºaï¼Œbçš„æœ€å¤§å…¬çº¦æ•°ï¼Œr=a(mod b)ä¸ºaé™¤ä»¥bçš„ä½™æ•°ï¼Œkä¸ºaé™¤ä»¥bçš„å•†ï¼Œå³aÃ·b=kã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚rã€‚è¾—è½¬ç›¸é™¤æ³•å³æ˜¯è¦è¯æ˜gcd(aï¼Œb)=gcd(bï¼Œr)ã€‚

2ã€ ç¬¬ä¸€æ­¥ï¼šä»¤c=gcd(aï¼Œb)ï¼Œåˆ™è®¾a=mcï¼Œb=ncã€‚

3ã€ ç¬¬äºŒæ­¥ï¼šæ ¹æ®å‰æå¯çŸ¥r=a-kb=mc-knc=(m-kn)cã€‚

4ã€ ç¬¬ä¸‰æ­¥ï¼šæ ¹æ®ç¬¬äºŒæ­¥ç»“æœå¯çŸ¥cä¹Ÿæ˜¯rçš„å› æ•°ã€‚

5ã€ ç¬¬å››æ­¥ï¼šå¯ä»¥æ–­å®šm-knä¸näº’è´¨(å‡è®¾m-kn=xdï¼Œn=yd(d1)ï¼Œåˆ™m=kn+xd=kyd+xd=(ky+x)dï¼Œåˆ™a=mc=(ky+x)cdï¼Œb=nc=ycdï¼Œåˆ™aä¸bçš„ä¸€ä¸ªå…¬çº¦æ•°cdcï¼Œæ•…céaä¸bçš„æœ€å¤§å…¬çº¦æ•°ï¼Œä¸å‰é¢ç»“è®ºçŸ›ç›¾)ï¼Œå› æ­¤cä¹Ÿæ˜¯bä¸rçš„æœ€å¤§å…¬çº¦æ•°ã€‚

6ã€ ä»è€Œå¯çŸ¥gcd(bï¼Œr)=cï¼Œç»§è€Œgcd(aï¼Œb)=gcd(bï¼Œr)ã€‚

7ã€ è¯æ¯•ã€‚ä»¥ä¸Šæ­¥éª¤çš„æ“ä½œæ˜¯å»ºç«‹åœ¨åˆšå¼€å§‹æ—¶râ‰ 0çš„åŸºç¡€ä¹‹ä¸Šçš„ã€‚å³mä¸näº¦äº’è´¨ã€‚

```c++
//è¾—è½¬ç›¸é™¤æ³•
int main() {
	int a;
	int b;    
	printf("è¯·è¾“å…¥ä¸¤ä¸ªæ­£æ•´æ•°ï¼š");
	scanf("%d %d", &a, &b);
	int k = 0;
	while (k = a % b) {
		a = b;
		b = k;
	}
	printf("æœ€å¤§å…¬çº¦æ•°ä¸º:%d\n", b);
	return 0;
}
```



### åŸƒæ°ç­›

è´¨æ•°ç­›æ˜¯ä¸€ç§ç”¨äº**æ‰¾å‡ºä¸€å®šèŒƒå›´å†…æ‰€æœ‰è´¨æ•°çš„ç®—æ³•**ã€‚å…¶ä¸­æœ€è‘—åçš„æ˜¯åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼æ–¯ç­›æ³•ï¼ˆSieve of Eratosthenesï¼‰ã€‚è¿™ä¸ªç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ä»å°åˆ°å¤§ä¾æ¬¡æ ‡è®°å¹¶åˆ é™¤æ¯ä¸ªæ•°çš„å€æ•°ï¼Œæœ€ç»ˆå‰©ä¸‹çš„æœªè¢«æ ‡è®°çš„æ•°å°±æ˜¯è´¨æ•°ã€‚

äºŒåˆ·ï¼Œè®°å¾—åœ¨åˆ†é…ç©ºé—´æ—¶å¤šåˆ†é…ä¸€ä¸ª

è¯¥ç®—æ³•çš„æ€æƒ³æ˜¯ï¼šè´¨æ•°çš„ä¸ªæ•°ä¸€å®šä¸æ˜¯è´¨æ•°

100ä»¥å†…çš„è´¨æ•°çš„ä¸ªæ•°æ˜¯25ä¸ª

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	//è´¨æ•°ç­›
	vector<int>arr(101,1);
	int n;
	cin>>n;
	arr[2]=true;
	for(int i=2;i*i<=n;i++){
		if(arr[i]==1){
			for(int j=i*i;j<=n;j+=i){
				arr[j]=0;
			}
		}
	}
	
	for(int i=2;i<=n;i++){
		if(arr[i]) cout<<i<<' ';
	}
    return 0;
}

```





### æ¬§æ‹‰ç­›

æ¬§æ‹‰ç­›æ³•çš„ä¸»è¦æ€æƒ³æ˜¯æ¯ä¸ªåˆæ•°åªä¼šè¢«å®ƒçš„æœ€å°è´¨å› æ•°æ ‡è®°ä¸€æ¬¡ï¼Œè¿™æ ·å¯ä»¥å‡å°‘é‡å¤æ“ä½œï¼Œä»è€Œæé«˜æ•ˆç‡ã€‚



```c++
#include <iostream>
#include <vector>
using namespace std;
vector<int> eulerSieve(int n) {
    vector<bool> is_prime(n + 1, true);  // åˆå§‹åŒ–å¸ƒå°”æ•°ç»„
    vector<int> primes;  // å­˜å‚¨è´¨æ•°çš„æ•°ç»„

    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);  
        }


        for (int j = 0; j < primes.size() && primes[j] * i <= n; ++j) {
            //é¦–å…ˆå¯¹äºè´¨æ•°35ï¼Œå®ƒçš„å› å­æœ‰1 5 7 35ï¼Œå®ƒçš„æœ€å°è´¨å› å­æ˜¯5
            
            is_prime[primes[j] * i] = false;  // æ ‡è®°åˆæ•°
            //å¦‚æœièƒ½å¤Ÿæ•´é™¤primes[j],é‚£ä¹ˆæ ¹æ®ä¸Šä¸€è¡Œä»£ç ï¼Œå¯¹äºä»»ä½•å¤§äºprimes[j]çš„è´¨æ•°primes[k]
            //å…¶ä¹˜ç§¯primes[k]*iä¼šè¢«åç»­çš„è´¨æ•°æ ‡è®°ï¼Œæ‰€ä»¥åœæ­¢å¾ªç¯ï¼Œé¿å…å¾ˆå¤šä¸å¿…è¦çš„æ ‡è®°
            //åŒæ—¶ä¹Ÿä½¿ä¸€ä¸ªåˆæ•°åªè¢«æ ‡è®°ä¸€æ¬¡
            if (i % primes[j] == 0) {
                break;  // å¦‚æœ i èƒ½è¢« primes[j] æ•´é™¤ï¼Œè·³å‡ºå¾ªç¯
            }
        }
    }
    return primes;
}

int main() {
    int n;
    cout << "è¯·è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•° nï¼š";
    cin >> n;

    vector<int> primes = eulerSieve(n);

    cout << "å°äºç­‰äº " << n << " çš„è´¨æ•°æœ‰ï¼š";
    for (int prime : primes) {
        cout << prime << " ";
    }
    cout << endl;

    return 0;
}

```



### 



### çº¦æ•°é—®é¢˜

$$
36=2^2*3^2\\é‚£ä¹ˆ36çš„çº¦æ•°ä¸ªæ•°=ï¼ˆ2+1ï¼‰*ï¼ˆ2+1ï¼‰
\\36çš„çº¦æ•°ä¹‹å’Œ=(2^0+2^1+2^2)*(3^0+3^1+3^2)
$$



#### æ±‚ä¸€ä¸ªæ•°çš„å…¨éƒ¨çº¦æ•°

çº¦æ•°çš„æ¦‚å¿µå¾ˆç®€å•ï¼Œå¦‚æœa èƒ½å¤Ÿæ•´é™¤b ï¼Œé‚£ä¹ˆa æ˜¯ bçš„çº¦æ•°ï¼Œ bæ˜¯ açš„å€æ•°ã€‚

æ±‚ä¸€ä¸ªæ•°çš„æ‰€æœ‰çº¦æ•°ï¼Œç®—æ³•æ€æƒ³å’Œæ±‚è´¨æ•°ä¸€æ ·ï¼Œå¦‚æœiæ•´é™¤n,é‚£ä¹ˆn/iä¹Ÿæ•´é™¤n

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

const int N = 1e5 + 5;


vector<int>get_divisors(int n) {
	vector<int>res;
	for (int i = 1; i <= n / i; i++) {
		if (n % i == 0) {
			res.push_back(i);
			if (i != n / i) res.push_back(n/i);  // è¿™ä¸ªåˆ¤æ–­æ˜¯é˜²æ­¢åŠ ä¸¤æ¬¡ n/i è¿›å»
		}
	}
	//sort(res.begin(), res.end());  // å¦‚æœä¸è¦æ±‚æ’åºï¼Œä¹Ÿå¯ä»¥ä¸ç”¨ã€‚
	return res;
	
}
int main() {
	int n;
	cin >> n;
	vector<int>res=get_divisors(n);
	for (auto i : res) cout << i << " ";
	return 0;
}
```



#### æ±‚ä¸€ä¸ªæ•°çš„çº¦æ•°çš„ä¸ªæ•°

![image-20240725171217346](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240725171217346.png)

```c++
#include <iostream>
#include<unordered_map>
using namespace std;
const int MOD = 1e9 + 7;
using namespace std;
  
unordered_map<int, int> mp;

void get_cnt(int n) {
	for (int i = 2; i <= n / i; i++) {  // åˆ†è§£è´¨å› æ•°
		while (n % i == 0) {
			n /= i;
			mp[i]++;  // ç»Ÿè®¡è¿™ä¸ªè´¨å› æ•°çš„æŒ‡æ•°
		}
	}
	if (n > 1) mp[n]++;  // å•ç‹¬å¤„ç†æ¯” n/i å¤§çš„è´¨å› å­
}

int main() {
	int n, x;
	long long res = 1;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		get_cnt(x);
	}

	for (auto i : mp) res = res * (i.second + 1) % MOD;  // è®¡ç®—ç»“æœ
	cout << res;
	return 0;
}
```



#### çº¦æ•°ä¹‹å’Œ

![image-20240725173415720](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240725173415720.png)

åˆå§‹æ—¶ï¼Œ`sum = 1`ã€‚

ç¬¬ä¸€æ¬¡å¾ªç¯ï¼š`sum = (1 * a + 1) % MOD = (a + 1) % MOD`ã€‚

ç¬¬äºŒæ¬¡å¾ªç¯ï¼š`sum = ((a + 1) * a + 1) % MOD = (a^2 + a + 1) % MOD`ã€‚

ç¬¬ä¸‰æ¬¡å¾ªç¯ï¼š`sum = ((a^2 + a + 1) * a + 1) % MOD = (a^3 + a^2 + a + 1) % MOD`ã€‚

```c++
#include <iostream>
#include<unordered_map>
using namespace std;
const int MOD = 1e9 + 7;
unordered_map<int, int> mp;
void get_cnt(int num) {
	for (int i = 2; i <= num; i++) {
		while (num % i == 0) {
			mp[i]++;
			num /= i;
		}
	}

	//è¿™é‡Œå¿˜è®°äº†ï¼ï¼ï¼
	if (num > 1) mp[num]++;
}

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int temp;
		cin >> temp;
		get_cnt(temp);
	}
	long long res = 1;
	for (auto i : mp) {
		long long sum = 1, a = i.first, b = i.second;
		while (b--) {
			sum = (sum * a + 1) % MOD;
		}
		res = (res * sum) % MOD;
	}

	cout << res;

	return 0;
}
```



### æŠŠæ•°å­—è½¬åŒ–æˆå­—ç¬¦ä¸²

```c++
#include <iostream>
#include <string>

std::string intToString(int number) {
    // å¤„ç†ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœæ•°å­—æ˜¯0ï¼Œç›´æ¥è¿”å›å­—ç¬¦ä¸²"0"
    if (number == 0) {
        return "0";
    }

    std::string result;  // ç”¨äºå­˜å‚¨æœ€ç»ˆçš„å­—ç¬¦ä¸²ç»“æœ

    // å¤„ç†è´Ÿæ•°æƒ…å†µ
    if (number < 0) {
        result.push_back('-');
        number = -number;  // å°†è´Ÿæ•°è½¬æ¢ä¸ºæ­£æ•°è¿›è¡Œå¤„ç†
    }

    // é€ä½æå–æ•°å­—å¹¶è½¬æ¢ä¸ºå­—ç¬¦ï¼Œç„¶åæ‹¼æ¥åˆ°ç»“æœå­—ç¬¦ä¸²ä¸­
    while (number > 0) {
        char digit = '0' + (number % 10);  // æå–æœ€åä¸€ä½æ•°å­—å¹¶è½¬æ¢ä¸ºå­—ç¬¦
        result.insert(result.begin(), digit);  // åœ¨å­—ç¬¦ä¸²çš„å¼€å¤´æ’å…¥å­—ç¬¦
        number /= 10;  // å»æ‰å·²ç»å¤„ç†çš„æœ€åä¸€ä½æ•°å­—
    }

    return result;
}

int main() {
    int number = -12345;
    std::string str_number = intToString(number);

    std::cout << "Number as string: " << str_number << std::endl;

    return 0;
}

```

### åŠ›æ‰£ç½—é©¬æ•°å­—è½¬æ¢

é¢˜å¹²è¢«ä½ åƒæ‰äº†ï¼Œå•Šå•Šå•Šå•Šå•Šï¼Œé•¿ç‚¹å¿ƒå§å•Šå•Šå•Šå•Šå•Š

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int>a;
        a['I'] = 1;
        a['V'] = 5;
        a['X'] = 10;
        a['L'] = 50;
        a['C'] = 100;
        a['D'] = 500;
        a['M'] = 1000;
        int i = 0;
        int num = 0;
        int len = s.length() - 1;
        for (i = 0; i < len; i++) {
            char temp1 = s[i];
            char temp2 = s[i + 1];   
            int num1 = a[temp1];
            int num2 = a[temp2];
            if (num1 >= num2) {
                num += num1;
            }
            else {
                num -= num1;
            }
        }
        num +=a[s[i]];
        return num;


    }
};
```

### åŠ›æ‰£12æ•´æ•°è½¬ç½—é©¬æ•°å­—

```c++
class Solution {
public:
    string intToRoman(int num) {
        vector<int>nums = { 1000,900,500,400,100,90,50,40,10,9,5,4,1 };
        vector<string>roman = { "M","CM","D","CD","C",
        "XC","L","XL","X","IX","V","IV","I" };
        int n = nums.size();
        string res;
        for (int i = 0; i < n; i++) {
            while (num >= nums[i]) {
                num -= nums[i];
                res += roman[i];
            }
        }

        return res;
    }
};
```



### æ´—ç‰Œç®—æ³•

[å¡ç‰Œå¤§å¸ˆï¼šç©è½¬â€œæ´—ç‰Œç®—æ³•â€ï¼Œå¹¸è¿å¥³ç¥åœ¨å¾®ç¬‘ (*^_^*) - æ˜é‡‘ (juejin.cn)](https://juejin.cn/post/6984925268754317320)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime> // ç”¨äºè·å–å½“å‰æ—¶é—´æˆ³

class Solution {
private:
    std::vector<int> original_nums;
    std::vector<int> current_nums;

public:
    Solution(const std::vector<int>& nums) {
        original_nums = nums;
        current_nums = nums;
        // ä½¿ç”¨å½“å‰æ—¶é—´æˆ³ä½œä¸ºç§å­ï¼Œä»¥å¢åŠ éšæœºæ€§
        srand(static_cast<unsigned>(time(nullptr)));
    }

    std::vector<int> reset() {
        current_nums = original_nums;
        return original_nums;
    }

    std::vector<int> shuffle() {
        int len = current_nums.size();

        while (len > 1) {
            int randIndex = rand() % len;
            --len;

            // äº¤æ¢å…ƒç´ 
            std::swap(current_nums[len], current_nums[randIndex]);
        }

        return current_nums;
    }
};

int main() {
    // ç¤ºä¾‹ç”¨æ³•
    std::vector<int> nums = {1, 2, 3, 4, 5};
    Solution obj(nums);

    std::cout << "Initial Array: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> shuffled = obj.shuffle();
    std::cout << "Shuffled Array: ";
    for (int num : shuffled) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> resetted = obj.reset();
    std::cout << "Resetted Array: ";
    for (int num : resetted) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

`static_cast<unsigned>` æ˜¯ C++ ä¸­çš„é™æ€ç±»å‹è½¬æ¢ï¼ˆstatic castï¼‰ã€‚åœ¨è¿™ä¸ªä¸Šä¸‹æ–‡ä¸­ï¼Œ`unsigned` æ˜¯ä¸€ç§æ•´æ•°ç±»å‹ï¼Œè€Œ `static_cast<unsigned>` ç”¨äºå°†æŸä¸ªå€¼è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°ç±»å‹ã€‚

å…·ä½“æ¥è¯´ï¼Œ`static_cast<unsigned>` å°†å…¶åçš„è¡¨è¾¾å¼è½¬æ¢ä¸º `unsigned` ç±»å‹ã€‚è¿™æ ·çš„è½¬æ¢å¯èƒ½ç”¨äºé¿å…è­¦å‘Šæˆ–é”™è¯¯ï¼Œæˆ–è€…æ˜¯ä¸ºäº†æ»¡è¶³ç‰¹å®šçš„ç±»å‹è¦æ±‚ã€‚

åœ¨å‰è¿°ä»£ç ä¸­ï¼Œ`static_cast<unsigned>(time(nullptr))` å°† `time(nullptr)` çš„è¿”å›å€¼è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°ç±»å‹ `unsigned`ã€‚è¿™æ˜¯å› ä¸º `srand` å‡½æ•°æ¥å—çš„å‚æ•°ç±»å‹æ˜¯ `unsigned int`ï¼Œä¸ºäº†åŒ¹é…è¿™ä¸ªç±»å‹ï¼Œè¿›è¡Œäº†ç›¸åº”çš„ç±»å‹è½¬æ¢ã€‚

### åŠ›æ‰£3178

é‡åˆ°è¿™ç§æ•°å­¦çš„å°±è¦æƒ³èµ·é«˜ä¸­çš„æ€æƒ³



### 100340ä¸‰è§’å½¢çš„æœ€å¤§é«˜åº¦

$$
ç­‰å·®æ•°åˆ—çš„æ±‚å’Œå…¬å¼ï¼šS_n=\frac{(a_1+a_n)n}{2}\\
ç­‰æ¯”æ•°åˆ—çš„æ±‚å’Œå…¬å¼ï¼šS_n=\frac{a_1(1-q^n)}{1-q}
$$



### åˆ¤æ–­ä¸‰ä¸ªé¡¶ç‚¹æ˜¯å¦æ„æˆç›´è§’ä¸‰è§’å½¢

é¢˜ç›®é“¾æ¥ï¼šhttps://atcoder.jp/contests/abc362/tasks/abc362_b

éœ€è¦æ³¨æ„çš„æ˜¯ï¼šä½ çš„é¢˜è§£å†™æˆäº†æ•´å‹ï¼Œä½†æ˜¯sqrt powå‡½æ•°è¿˜æ˜¯é‡‡ç”¨doubleç±»å‹æ‰æ˜¯æ­£ç¡®çš„ï¼Œç„¶ååˆ¤æ–­ä¸¤ä¸ªdoubleç±»å‹çš„æ•°æ®æ˜¯å¦ç›¸ç­‰æ˜¯ç›¸å‡ï¼Œå·®å€¼æ˜¯å¦å°äº1e-6

```c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;

int main() {
    vector<vector<int>> arr(3, vector<int>(2, 0));
    for (int i = 0; i < 3; i++) {
        cin >> arr[i][0] >> arr[i][1];
    }

    // è®¡ç®—ä¸‰è¾¹çš„é•¿åº¦
    double a = sqrt(pow(arr[0][0] - arr[1][0], 2) + pow(arr[0][1] - arr[1][1], 2));
    double b = sqrt(pow(arr[1][0] - arr[2][0], 2) + pow(arr[1][1] - arr[2][1], 2));
    double c = sqrt(pow(arr[0][0] - arr[2][0], 2) + pow(arr[0][1] - arr[2][1], 2));

    // æ¯”è¾ƒå¹³æ–¹å€¼æ¥åˆ¤æ–­æ˜¯å¦æ˜¯ç›´è§’ä¸‰è§’å½¢
    if (abs(pow(a, 2) + pow(b, 2) - pow(c, 2)) < 1e-6 || 
        abs(pow(a, 2) + pow(c, 2) - pow(b, 2)) < 1e-6 || 
        abs(pow(b, 2) + pow(c, 2) - pow(a, 2)) < 1e-6) {
        cout << "Yes";
    } else {
        cout << "No";
    }

    return 0;
}

```

### åŠ›æ‰£zå­—å½¢å˜æ¢

è®¾ç½®ä¸€ä¸ªå˜é‡è¡¨ç¤ºå½“å‰çš„æ–¹å‘ï¼Œgoingdown,å½“goingdownçš„å€¼ä¸ºtrueæ—¶è¡¨ç¤ºå½“å‰æ–¹å‘æ˜¯å‘ä¸‹çš„ï¼Œåä¹‹æ˜¯å‘ä¸Šçš„



```c++
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1) return s;
        bool goingdown=false;
        vector<string> rows(min(numRows,int(s.size())));
        int currow=0;
       
        for(char c:s){
            rows[currow]+=c;
            if(currow==0||currow==numRows-1) goingdown=!goingdown;
            currow+=goingdown?1:-1;
        }

        string res;
        for(auto i:rows) res+=i;
        return res;
       
  
    }
};
```

### ISBNç¼–ç 

æ¯ä¸€æœ¬æ­£å¼å‡ºç‰ˆçš„å›¾ä¹¦éƒ½æœ‰ä¸€ä¸ª ISBN å·ç ä¸ä¹‹å¯¹åº”ï¼ŒISBN ç åŒ…æ‹¬ 99 ä½æ•°å­—ã€11 ä½è¯†åˆ«ç å’Œ 33 ä½åˆ†éš”ç¬¦ï¼Œå…¶è§„å®šæ ¼å¼å¦‚ `x-xxx-xxxxx-x`ï¼Œå…¶ä¸­ç¬¦å· `-` å°±æ˜¯åˆ†éš”ç¬¦ï¼ˆé”®ç›˜ä¸Šçš„å‡å·ï¼‰ï¼Œæœ€åä¸€ä½æ˜¯è¯†åˆ«ç ï¼Œä¾‹å¦‚ `0-670-82162-4`å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„ ISBN ç ã€‚ISBN ç çš„é¦–ä½æ•°å­—è¡¨ç¤ºä¹¦ç±çš„å‡ºç‰ˆè¯­è¨€ï¼Œä¾‹å¦‚ 00 ä»£è¡¨è‹±è¯­ï¼›ç¬¬ä¸€ä¸ªåˆ†éš”ç¬¦ `-` ä¹‹åçš„ä¸‰ä½æ•°å­—ä»£è¡¨å‡ºç‰ˆç¤¾ï¼Œä¾‹å¦‚ 670670 ä»£è¡¨ç»´äº¬å‡ºç‰ˆç¤¾ï¼›ç¬¬äºŒä¸ªåˆ†éš”ç¬¦åçš„äº”ä½æ•°å­—ä»£è¡¨è¯¥ä¹¦åœ¨è¯¥å‡ºç‰ˆç¤¾çš„ç¼–å·ï¼›æœ€åä¸€ä½ä¸ºè¯†åˆ«ç ã€‚

è¯†åˆ«ç çš„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š

é¦–ä½æ•°å­—ä¹˜ä»¥ 11 åŠ ä¸Šæ¬¡ä½æ•°å­—ä¹˜ä»¥ 22 â€¦â€¦ä»¥æ­¤ç±»æ¨ï¼Œç”¨æ‰€å¾—çš„ç»“æœ modâ€Š11mod11ï¼Œæ‰€å¾—çš„ä½™æ•°å³ä¸ºè¯†åˆ«ç ï¼Œå¦‚æœä½™æ•°ä¸º 1010ï¼Œåˆ™è¯†åˆ«ç ä¸ºå¤§å†™å­—æ¯ ğ‘‹*X*ã€‚ä¾‹å¦‚ ISBN å·ç  `0-670-82162-4` ä¸­çš„è¯†åˆ«ç  44 æ˜¯è¿™æ ·å¾—åˆ°çš„ï¼šå¯¹ `067082162` è¿™ 99 ä¸ªæ•°å­—ï¼Œä»å·¦è‡³å³ï¼Œåˆ†åˆ«ä¹˜ä»¥ 1,2,â€¦,91,2,â€¦,9 å†æ±‚å’Œï¼Œå³ 0Ã—1+6Ã—2+â€¦â€¦+2Ã—9=1580Ã—1+6Ã—2+â€¦â€¦+2Ã—9=158ï¼Œç„¶åå– 158â€Šmodâ€Š11158mod11 çš„ç»“æœ 44 ä½œä¸ºè¯†åˆ«ç ã€‚

ä½ çš„ä»»åŠ¡æ˜¯ç¼–å†™ç¨‹åºåˆ¤æ–­è¾“å…¥çš„ ISBN å·ç ä¸­è¯†åˆ«ç æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœæ­£ç¡®ï¼Œåˆ™ä»…è¾“å‡º `Right`ï¼›å¦‚æœé”™è¯¯ï¼Œåˆ™è¾“å‡ºä½ è®¤ä¸ºæ˜¯æ­£ç¡®çš„ ISBN å·ç ã€‚

è¾“å…¥æ ¼å¼

ä¸€ä¸ªå­—ç¬¦åºåˆ—ï¼Œè¡¨ç¤ºä¸€æœ¬ä¹¦çš„ ISBN å·ç ï¼ˆä¿è¯è¾“å…¥ç¬¦åˆ ISBN å·ç çš„æ ¼å¼è¦æ±‚ï¼‰ã€‚

è¾“å‡ºæ ¼å¼

ä¸€è¡Œï¼Œå‡å¦‚è¾“å…¥çš„ ISBN å·ç çš„è¯†åˆ«ç æ­£ç¡®ï¼Œé‚£ä¹ˆè¾“å‡º `Right`ï¼Œå¦åˆ™ï¼ŒæŒ‰ç…§è§„å®šçš„æ ¼å¼ï¼Œè¾“å‡ºæ­£ç¡®çš„ ISBN å·ç ï¼ˆåŒ…æ‹¬åˆ†éš”ç¬¦ `-`ï¼‰ã€‚

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    string s;
    cin >> s;
    int n = s.size();
    int sum = 0;
    for (int i = 0,j=1; i < n - 1; i++) {
        if (s[i] != '-') {
            sum += (s[i] - '0') * j;
            j++;
        }
    }

    sum = sum % 11;
    char t;
    if (sum == 10) t = 'X';
    else  t = sum + '0';

    if (t == s[n - 1]) cout << "Right";
    else {
        s[n - 1] = t;
        cout << s;
    }
   
    return 0;
}

```

### å‘ä¸Šå–æ•´çš„ç®—æ³•

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (dividend == 0) return 0;
        int cnt = 0;
        if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {
            while (dividend > 0 && cnt <= 2147483647) {     
                dividend -= divisor;
                 cnt++;         
            }
            return cnt;
      }
        else {
            int a = abs(dividend);
            int b = abs(divisor);
          
            while (a > 0&&cnt<=2147483647) {
                
                a -= b;
                cnt++;
            }
            return cnt==2147483647?-2147483648:-cnt;
        }

    }
};
int main() {
	Solution a;
    cout << a.divide(10,3);	
}

```

### åŠ›æ‰£29ä¸¤æ•°ç›¸é™¤

æ³¨æ„ä»£ç ä¸­tempå’Œmultiplierçš„æ•°æ®ç±»å‹æ˜¯long long 

å› ä¸ºæœ‰ä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„æ•°æ®(2147483648 2)

åœ¨ä¹˜2è¿‡ç¨‹ä¸­è¿™ä¸¤ä¸ªå€¼ä¼šçˆ†int

å› ä¸ºä¸¤ä¸ªæ•°æ®åªåœ¨intèŒƒå›´å†…ï¼Œæ‰€ä»¥åªå­˜åœ¨æœ€å°è´Ÿæ•°é™¤ä»¥-1çš„æ—¶å€™ä¼šçˆ†int,è¿™ç§æƒ…å†µè¦å•ç‹¬æ‹å‡ºæ¥å†™

å‡ ç§ç‰¹æ®Šæƒ…å†µï¼š

1.è¢«é™¤æ•°æ˜¯0ï¼Œåˆ™ç­”æ¡ˆæ˜¯0

2.é™¤æ•°æ˜¯1ï¼Œåˆ™ç­”æ¡ˆæ˜¯è¢«é™¤æ•°

3.é™¤æ•°æ˜¯-1 å½“è¢«é™¤æ•°æ˜¯æœ€å°è´Ÿæ•°çš„æ—¶å€™ï¼Œè¿”å›æœ€å¤§æ­£æ•°ï¼Œå…¶ä»–æƒ…å†µè¿”å›è¢«é™¤æ•°çš„ç›¸åæ•°

4.å…¶ä»–æƒ…å†µï¼Œè¦ç¬¦å·æ˜¯ç›¸åŒçš„è¿˜æ˜¯ç›¸å¼‚çš„ï¼Œå¦‚æœæ˜¯ç›¸å¼‚çš„è¿˜è¦å–å

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (dividend == 0) return 0;
        if (divisor == 1) return dividend;
        if (divisor == -1) {
            if (dividend == INT_MIN) return INT_MAX;
            else return -dividend;
        }

        long long a = labs(dividend);
        long long b = labs(divisor);
        int result = 0;
        bool nevigate = (dividend < 0) ^ (divisor < 0);
        while (a >= b) {
            long long temp = b;
            long long multiplier = 1;
            while ((temp << 1) <= a) {
                temp <<= 1;
                multiplier <<= 1;
            }

            a -= temp;
            result += multiplier;
        }

        if (nevigate) result = -result;
        return result;

    }
};

int main() {
    Solution a;
    cout << a.divide(2147483647,2);
}

```

### å°æ–‡çš„å¥½æ•°ç»„

![image-20240720202041905](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240720202041905.png)

æˆ‘ç´¯äº†ï¼Œè¿™ä¹ˆç®€å•çš„é¢˜ç›®ä½ ä¸ä¼šå†™

```c++
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

int main() {

    int n;
   cin >> n;
    vector<int> arr(n, 0);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    int i = 0;
    for (int i = 0; i < n; i++) {
        if (i != 0&&arr[i] < arr[i - 1]) {
            cout<< n << endl;
            return 0;
        }
    }
   
    cout<< 0 << endl;
    

    

    return 0;
}

```



# åŠ¨æ€è§„åˆ’

### æœ€ä¼˜äºŒå‰æœç´¢æ ‘

```c++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// å®šä¹‰ binarysearchtree å‡½æ•°
double binarysearchtree(int n, vector<double>& p, vector<double>& q) {
    vector<vector<double>> e(n + 2, vector<double>(n + 1, 0)); // æœŸæœ›ä»£ä»·è¡¨
    vector<vector<double>> w(n + 2, vector<double>(n + 1, 0)); // æ¦‚ç‡å’Œè¡¨

    // åˆå§‹åŒ–
    for (int i = 1; i <= n + 1; ++i) {
        e[i][i - 1] = q[i - 1];
        w[i][i - 1] = q[i - 1];
    }

    // å¡«è¡¨
    for (int l = 1; l <= n; ++l) { // å­æ ‘é•¿åº¦ä» 1 åˆ° n
        for (int i = 1; i <= n - l + 1; ++i) {
            int j = i + l - 1;
            e[i][j] = INT_MAX;
            w[i][j] = w[i][j - 1] + p[j] + q[j];
            for (int r = i; r <= j; ++r) { // å°è¯•ä»¥ r ä¸ºæ ¹
                double cost = e[i][r - 1] + e[r + 1][j] + w[i][j];
                if (cost < e[i][j]) {
                    e[i][j] = cost;
                }
            }
        }
    }

    return e[1][n]; // è¿”å›æœ€å°æœŸæœ›ä»£ä»·
}

int main() {
    int n = 4; // é”®çš„ä¸ªæ•°
    vector<double> p = {0.15, 0.10, 0.05, 0.10}; // æ¯ä¸ªé”®çš„æ¦‚ç‡
    vector<double> q = {0.05, 0.10, 0.05, 0.05, 0.10}; // æ¯ä¸ªä¼ªé”®çš„æ¦‚ç‡

    double min_cost = binarysearchtree(n, p, q);
    cout << "The minimum expected cost of the optimal binary search tree is: " << min_cost << endl;

    return 0;
}

```



### æ–æ³¢é‚£å¥‘æ•°åˆ—

```c++
int func(int n) {
    if (n == 0 || n == 1) return 1;
    else {
        vector<int>dp(n);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n-1];
    }
}

//æ»šåŠ¨æ•°ç»„
int func1(int n) {
    if (n == 0 || n == 1) return 1;
    else {
        int sum = 0;
        int dp0 = 1, dp1 = 1;
        for (int i = 2; i < n;i++) {
            sum = dp0 + dp1;
            dp0 = dp1;
            dp1 = sum;
        }
        return sum;
    }
}

```



### åŠ›æ‰£çˆ¬æ¥¼æ¢¯

æ ¹æ®æ¨ç†å¾—å‡ºï¼šçˆ¬ä¸Šç¬¬nçº§å°é˜¶çš„æ–¹æ¡ˆæ•°=çˆ¬ä¸Šn-1çº§å°é˜¶çš„æ–¹æ¡ˆæ•°+çˆ¬ä¸Šn-2çº§å°é˜¶çš„æ–¹æ¡ˆæ•°

**é€’å½’ï¼ˆdfsï¼‰**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        return climbStairs(n-1)+climbStairs(n-2);

    }
};
```



**è®°å¿†åŒ–é€’å½’**

```c++
class Solution {
public:
    int climbStairs(int n) {
        int *mem=new int[n+1];//åˆ›å»ºè®°å¿†æ•°ç»„
        //è®°å¿†æ•°ç»„ä¸­å­˜å‚¨çš„æ˜¯ç¬¬içº§å°é˜¶éœ€è¦çš„æ­¥æ•°ï¼Œå½“éœ€è¦ä½¿ç”¨çš„æ—¶å€™æ˜¯ç›´æ¥ä½¿ç”¨å³å¯
        //ç©ºé—´æ¢æ—¶é—´
        return func(n,mem);

    }
    
    int func(int n,int*mem){
        if(mem[n]>0){
            return mem[n];
        }
        if(n==1){
            mem[1]=1;
        }
        
        else if(n==2){
            mem[2]=2;
        }
        
        else{
            mem[n]=func(n-1,mem)+func(n-2,mem);
        }
        return mem[n];
    }
};
```

**åŠ¨æ€è§„åˆ’(é€’æ¨)**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int*mem=new int[n+1];
        mem[1]=1;
        mem[2]=2;
        for(int i=3;i<=n;i++){
            mem[i]=mem[i-1]+mem[i-2];
        }
        return mem[n];

    }
};
```



**æ»šåŠ¨æ•°ç»„**

ä¼˜åŒ–äº†åŠ¨æ€è§„åˆ’ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦æœ€åä¸€ä¸ªnçº§å°é˜¶çš„è§£ï¼Œä¸éœ€è¦å…¶ä»–çš„ï¼Œæ‰€ä»¥è¿™äº›è¢«ç»†åŒ–çš„å­é—®é¢˜è¢«è¦†ç›–ä¹Ÿå¯ä»¥

```c++
class Solution {
public:
    int climbStairs(int n) {
              if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int first=1;
        int second=2;
        int third;
        for(int i=3;i<=n;i++){
            third=first+second;
            first=second;
            second=third;

        }
        return third;

    }
};
```

**é€šé¡¹å…¬å¼çŸ©é˜µå½¢å¼**

æ–æ³¢é‚£å¥‘æ•°åˆ—çš„çŸ©é˜µè¡¨è¾¾ï¼š

![image-20240207173623609](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173623609.png)

![image-20240207173936045](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173936045.png)



```c++
class Solution {
public:
    //è¯¥å‡½æ•°æ¨¡æ‹ŸçŸ©é˜µç›¸ä¹˜
    vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {
        vector<vector<long long>> c(2, vector<long long>(2));
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }
        return c;
    }
    

    vector<vector<long long>> matrixPow(vector<vector<long long>> a, int n) {
        vector<vector<long long>> ret = {{1, 0}, {0, 1}};//è¿™é‡Œåˆ©ç”¨å•ä½çŸ©é˜µå’Œä»»ä½•çŸ©é˜µç›¸ä¹˜éƒ½ç­‰äº1æ¥åˆå§‹åŒ–
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    int climbStairs(int n) {
        vector<vector<long long>> ret = {{1, 1}, {1, 0}};
        vector<vector<long long>> res = matrixPow(ret, n);
        return res[0][0];
    }
};

```

**Binet's  Formula**

å°±æ˜¯ç”¨æ•°å­¦çš„æ–¹æ³•è§£çŸ©é˜µMçš„næ¬¡æ–¹ï¼Œä½ ä»¬æ•°å­¦å¥½çš„åˆ°åº•è¦æ€ä¹ˆæ ·

![image-20240207175746964](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175746964.png)

![image-20240207175813215](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175813215.png)

### ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n=cost.size();
        vector<int>dp(n+1);
        dp[0]=0;
        dp[1]=0;
        for(int i=2;i<=n;i++){
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }

        return dp[n];

    }
};==
```

### ä¸åŒè·¯å¾„

æ±‚äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹æ•°ç›®

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
using namespace std;

int func(int x,int y,int endx,int endy) {
    if (x > endx || y > endy) return 0;
    if (x == endx && y == endy) return 1;
    return func(x + 1, y,endx,endy) + func(x, y + 1,endx,endy);



}
int main() {
    cout << func(0,0, 2,2);
}
```



### ä¸åŒè·¯å¾„II

```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        //dp[i][j]è¡¨ç¤ºæœºå™¨äººåˆ°è¾¾(i,j)çš„å…¨éƒ¨è·¯å¾„
        int n=obstacleGrid.size();
        int m=obstacleGrid[0].size();
        vector<vector<int> >dp(n,vector<int>(m,0));
        if(obstacleGrid[0][0]==1) dp[0][0]=0;
        else dp[0][0]=1;

        for(int j=1;j<m;j++){
            if(obstacleGrid[0][j]==1) dp[0][j]=0;
            else dp[0][j]=dp[0][j-1];
        }
        for(int i=1;i<n;i++){
            if(obstacleGrid[i][0]==1) dp[i][0]=0;
            else dp[i][0]=dp[i-1][0];
        }

        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(obstacleGrid[i][j]==1) dp[i][j]=0;
                else dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }

        return dp[n-1][m-1];
       

    }
};
```



### æ•´æ•°æ‹†åˆ†

```c++
//å¯ä»¥æŠŠä¸€ä¸ªæ•´æ•°æ‹†è§£æˆä¸¤ä¸ªæ•°ã€ä¸‰ä¸ªå’Œä¸‰ä¸ªä»¥ä¸Šçš„æ•°

//æ‰€ä»¥é€’æ¨å…¬å¼ä¸­ï¼Œè¿˜è¦æœ‰j*(i-j)
class Solution {
public:
    int integerBreak(int n) {
        vector<int>dp(n + 1);
        dp[0] = 0;
        dp[1] = 0;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
                
                
            }
        }
        return dp[n];

    }
};

```

### æ±‚ç»„åˆæ•°

$$
C\binom{n}{m}= C\binom{n}{m-1}+C\binom{n-1}{m-1}
$$

```c++
long long func(int n, int m) {
    if (m == 0 && n == 0) return 1;
    if (m == n) return 1;
    if (n == 0) return 1;
    return func(n, m - 1) + func(n - 1, m - 1);
}

long long func2(int n, int m) {
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

  
    for (int i = 0; i <= n; i++) dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (i == j) dp[i][j] = 1;
            else {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
    }

    return dp[n][m];
}
```

### ä¸åŒçš„äºŒå‰æœç´¢æ ‘

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<long long>dp(n+1);
        dp[0]=1;
        
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
        
    }
};
```





### 01èƒŒåŒ…é—®é¢˜

æ¯ä»¶ç‰©å“åªèƒ½é€‰æ‹©ä¸€æ¬¡



```c++
#include<iostream> 
#include<vector>
using namespace std;
const int N=1010;
int dp[N];
int volum[N];
int values[N];
int f[N][N];
int main(){
	int n,v;//ç‰©å“æ•°å’ŒèƒŒåŒ…èƒ½å­˜æ”¾çš„æœ€å¤§é‡é‡
	cin>>n>>v;
	for(int i=1;i<=n;i++){
		cin>>volum[i]>>values[i];
	}
	
	//f(x,w),wä»£è¡¨çš„æ˜¯èƒ½é€‰çš„ç‰©å“æ•°ç›®ï¼Œwä»£è¡¨çš„æ˜¯èƒŒåŒ…çš„å®¹é‡
	//æœ€ç»ˆè¾“å‡ºf(n,v); 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=v;j++){
			if(j<volum[i]) f[i][j]=f[i-1][j];
			else{
				f[i][j]=max(f[i-1][j],f[i-1][j-volum[i]]+values[i]);
			}
			
		} 
	}
	
	cout<<f[n][v];
	return 0;	
	 
} 

```



#### 01èƒŒåŒ…ä¸€ç»´æ•°ç»„

dp[j]ä»£è¡¨çš„æ˜¯å½“ç‰©å“æ•°ç›®ä¸ºiçš„æ—¶å€™ï¼ŒèƒŒåŒ…å®¹é‡ä¸ºjæ—¶èƒ½å¾—åˆ°çš„æœ€å¤§ä»·å€¼

è¿›è¡Œå€’å™æ˜¯è¦ä¿è¯æ¯ä¸ªç‰©å“åªè¢«æ·»åŠ äº†ä¸€æ¬¡

å…ˆéå†ç‰©å“ï¼Œå†éå†èƒŒåŒ…ä¿è¯ç‰©å“åªæ·»åŠ ä¸€æ¬¡



```c++
#include<iostream>
using namespace std;
int dp[1010];
int v[1010];//ä»£è¡¨ç‰©å“çš„ä½“ç§¯æ•°ç»„
int w[1010];//ä»£è¡¨ç‰©å“çš„ä»·å€¼æ•°ç»„ 
int main(){
	int n,m;//n,måˆ†åˆ«ä»£è¡¨ç‰©å“æ•°ç›®å’ŒèƒŒåŒ…å®¹é‡
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i];
	} 
	
	for(int i=1;i<=n;i++){
		for(int j=m;j>=v[i];j--){
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);		
		}	
    }	
	cout<<dp[5];	
	return 0;	
} 
```

#### 416åˆ†å‰²ç­‰å’Œå­é›†

è¿™é‡Œçš„ç‰©å“ä½“ç§¯å’Œä»·å€¼éƒ½æ˜¯num[i]

æœ¬é¢˜æ˜¯æ±‚èƒ½å¦è£…æ»¡ä¸€ä¸ªèƒŒåŒ…

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if(sum%2!=0) return false;
        int n=nums.size();
        int a=sum/2;

        vector<int>dp(a+1);
        dp[0]=0;

        for(int i=0;i<n;i++){
            for(int j=a;j>=nums[i];j--){
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }

        
        return dp[a]==a;



    }
};
```



#### 1049æœ€åä¸€å—çŸ³å¤´çš„é‡é‡

æœ¬é¢˜æ˜¯æ±‚èƒŒåŒ…çš„æœ€å¤§ä»·å€¼

å¦‚æœæŠŠçŸ³å¤´åˆ†æˆä¸¤ç»„ï¼Œé‚£ä¹ˆæœ€åå‰©ä¸‹çš„å·®å€¼æ˜¯ä¸¤ç»„çŸ³å¤´æ€»é‡é‡çš„å·®å€¼

æ‰€ä»¥åªéœ€è¦æŠŠçŸ³å¤´åˆ†æˆå°½å¯èƒ½ç›¸ç­‰çš„ä¸¤ç»„å³å¯

å¦‚ä½•æŠŠçŸ³å¤´åˆ†æˆå°½å¯èƒ½ç›¸ç­‰çš„ä¸¤ç»„ï¼Ÿåˆ›é€ ä¸€ä¸ªèƒŒåŒ…å®¹é‡ä¸ºsum/2çš„èƒŒåŒ…ï¼Œæ±‚å‡ºèƒŒåŒ…çš„æœ€å¤§ä»·å€¼

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum=accumulate(stones.begin(),stones.end(),0);
        int n=stones.size();
        int a=sum/2;
        //sum/=2;
        vector<int>dp(a+1);
        dp[0]=0;
        for(int i=0;i<n;i++){
            for(int j=a;j>=stones[i];j--){
                dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }

        return abs((sum-dp[a])-dp[a]);

    }
};
```



#### ç›®æ ‡å’Œ

æœ¬é¢˜æ±‚è£…æ»¡èƒŒåŒ…æœ‰å¤šå°‘ç§æ–¹æ³•

```c++
class Solution {
public:

    int findTargetSumWays(vector<int>& nums, int target) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if((sum+target)%2==1||(sum+target<0)) return 0;
        int left=(sum+target)/2;
        int n=nums.size();
        vector<int>dp(left+1);
        dp[0]=1;
        for(int i=0;i<n;i++){
            for(int j=left;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
            }
        }
        return dp[left];

    }
};
```



#### äºŒç»´01èƒŒåŒ…

å¦‚æœé‡‡ç”¨é¡ºåºéå†ï¼Œå½“æˆ‘ä»¬æ›´æ–° `f[j][k]` æ—¶ï¼Œ`f[j - v[i]][k - m[i]]` å¯èƒ½å·²ç»åŒ…å«äº†å½“å‰ç‰©å“ `i` çš„è´¡çŒ®ï¼Œè¿™æ ·åœ¨è®¡ç®—æ—¶ä¼šå‡ºç°é‡å¤ä½¿ç”¨ç‰©å“ `i` çš„æƒ…å†µã€‚

å€’åºéå†ç¡®ä¿åœ¨æ›´æ–° `f[j][k]` æ—¶ï¼Œ`f[j - v[i]][k - m[i]]` è¿˜æ²¡æœ‰è¢«å½“å‰ç‰©å“ `i` æ›´æ–°è¿‡ï¼Œä»è€Œä¿è¯ç‰©å“ `i` åªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚

```c++
#include <bits/stdc++.h>

using namespace std;

int n, V, M;
const int N = 1e3 + 5;
int v[N], m[N], w[N], f[N][N];

signed main () {
    cin >> n >> V >> M;
    for (int i = 1; i <= n; i ++) {
        cin >> v[i] >> m[i] >> w[i];//ä½“ç§¯ï¼Œé‡é‡ï¼Œä»·å€¼
    }
    
    
    //f[V][M]è¡¨ç¤ºèƒŒåŒ…ä½“ç§¯ä¸ºV,è´¨é‡ä¸ºçš„æ—¶å€™ï¼Œæ‰€èƒ½å­˜æ”¾çš„æœ€å¤§ä»·å€¼
    //ä¸æ–­æ›´ç»†f[V][M],å½“içš„å€¼å˜ä¸ºNçš„æ—¶å€™ï¼Œæ˜¯è¦æ±‚çš„ç­”æ¡ˆ    
    for (int i = 1; i <= n; i ++)
        for (int j = V; j >= v[i]; j --)
            for (int k = M; k >= m[i]; k --)
                f[j][k] = max (f[j - v[i]][k - m[i]] + w[i], f[j][k]);//åŠ¨æ€è½¬ç§»æ–¹ç¨‹ï¼Œ01 èƒŒåŒ…çš„æ€è·¯
    cout << f[V][M];
}


```

#### åŠ›æ‰£ä¸€å’Œé›¶

æœ¬é¢˜æ˜¯æ±‚ ç»™å®šèƒŒåŒ…å®¹é‡ï¼Œè£…æ»¡èƒŒåŒ…æœ€å¤šæœ‰å¤šå°‘ä¸ªç‰©å“ã€‚

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len=strs.size();
        vector<vector<int>>dp(m+1,vector<int>(n+1,0));
        dp[0][0]=0;
        for(int i=0;i<len;i++){
            int a=0,b=0;
            for(auto i:strs[i]){
                if(i=='0') a++;
                else b++;
            }
            for(int j=m;j>=a;j--){
                for(int k=n;k>=b;k--){
                    dp[j][k]=max(dp[j][k],dp[j-a][k-b]+1);
                }
            }
        }
        return dp[m][n];

    }
};
```





### å®Œå…¨èƒŒåŒ…

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
}
```



#### 518é›¶é’±å…‘æ¢II

å®Œå…¨èƒŒåŒ…å…ˆéå†ç‰©å“å†éå†èƒŒåŒ…å¾—åˆ°çš„æ˜¯ç»„åˆæ•°ï¼Œå› ä¸ºå…ˆéå†ç‰©å“ï¼Œä¿è¯äº†ç‰©å“æ•°ç»„é å‰çš„ç‰©å“å…ˆè¢«é€‰æ‹©

å…ˆéå†èƒŒåŒ…å†éå†ç‰©å“å¾—åˆ°çš„æ˜¯æ’åˆ—æ•°ã€‚å› ä¸ºç¬¬äºŒå±‚å¾ªç¯ä¸­æ¯ä¸€ä¸ªç‰©å“éƒ½ä¼šè¢«é€‰ä¸€æ¬¡ï¼Œè¢«é€‰ä¸­æ„å‘³ç€æ”¾åœ¨æ’åˆ—å¼€å¤´ï¼Œæ‰€ä»¥æ˜¯æœ‰é¡ºåºå˜åŒ–çš„ã€‚

```c++
class Solution {
public:
int change(int amount, vector<int>& coins) {
vector<int> dp(amount + 1, 0);
dp[0] = 1;
for (int i = 0; i < coins.size(); i++) { // éå†ç‰©å“
for (int j = coins[i]; j <= amount; j++) { // éå†èƒŒåŒ…
dp[j] += dp[j - coins[i]];
 }
 }
return dp[amount];
 }
};
```

#### åŠ›æ‰£é›¶é’±å…‘æ¢

æœ¬é¢˜æ±‚æœ€å°æ•°

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n=coins.size();
        vector<long long>dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<n;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]=min(dp[j],dp[j-coins[i]]+1);

            }
        }

        return dp[amount]==INT_MAX?-1:dp[amount];

    }
};
```

#### å•è¯æ‹†åˆ†

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string>wordset(wordDict.begin(),wordDict.end());
        int n=s.size();
        int len=wordDict.size();
        vector<bool>dp(n+1,false);
        dp[0]=true;//ç©ºå­—ç¬¦ä¸²
        for(int i=1;i<=n;i++){
            for(int j=0;j<i;j++){
                string temp=s.substr(j,i-j);
                if(wordset.find(temp)!=wordset.end()&&dp[j]){
                    dp[i]=true;
                }
            }
        }
        return dp[n];
       
    }
};
```

è®°å¿†åŒ–æœç´¢

```c++
class Solution {
private:
bool backtracking (const string& s,
const unordered_set<string>& wordSet,
vector<bool>& memory,
int startIndex) {
if (startIndex >= s.size()) {
return true;
 }
// å¦‚æœmemory[startIndex]ä¸æ˜¯åˆå§‹å€¼äº†ï¼Œç›´æ¥ä½¿â½¤memory[startIndex]çš„ç»“æœ
if (!memory[startIndex]) return memory[startIndex];
for (int i = startIndex; i < s.size(); i++) {
string word = s.substr(startIndex, i - startIndex + 1);
if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory,
i + 1)) {
return true;
 }
 }
memory[startIndex] = false; // è®°å½•ä»¥startIndexå¼€å§‹çš„â¼¦ä¸²æ˜¯ä¸å¯ä»¥è¢«æ‹†åˆ†çš„
return false;
 }
public:
bool wordBreak(string s, vector<string>& wordDict) {
unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
vector<bool> memory(s.size(), 1); // -1 è¡¨ç¤ºåˆå§‹åŒ–çŠ¶æ€
return backtracking(s, wordSet, memory, 0);
 }
};
```







### èƒŒåŒ…é—®é¢˜æ±‚æ–¹æ¡ˆæ•°ã€å…·ä½“æ–¹æ¡ˆ

[èƒŒåŒ…é—®é¢˜æ±‚æ–¹æ¡ˆæ•°ã€å…·ä½“æ–¹æ¡ˆ-CSDNåšå®¢](https://blog.csdn.net/qq_43851311/article/details/128981355?ops_request_misc=&request_id=&biz_id=102&utm_term=èƒŒåŒ…é—®é¢˜æœ€ä½³æ–¹æ¡ˆæ•°&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128981355.142^v100^pc_search_result_base1&spm=1018.2226.3001.4187)

#### è´§å¸ç³»ç»Ÿ

ç»™ä½ ä¸€ä¸ªnç§é¢å€¼çš„è´§å¸ç³»ç»Ÿï¼Œï¼Œæ±‚ç»„æˆé¢å€¼ä¸ºmçš„è´§å¸æœ‰å¤šå°‘ç§

```c++
//æ¨åˆ°è¿‡ç¨‹
//dp[i][j]==dp[1][j]+dp[i[j-v[i]]]
//æˆ‘ä»¬å¯ä»¥çŸ¥é“dp[i-1][j]è¡¨ç¤ºä¸é€‚ç”¨å½“å‰é¢å€¼çš„è´§å¸æ‰€æœ‰çš„æ–¹æ¡ˆæ•°ï¼Œå†åŠ ä¸Šä½¿ç”¨äº†è¯¥è´§å¸çš„æ–¹æ¡ˆæ•°å°±æ˜¯æ‰€æ±‚çš„
//ä½¿ç”¨äº†è¯¥è´§å¸çš„æ–¹æ¡ˆæ•°ç­‰äºdp[i][j-v[i]],å³æˆ‘ä»¬é»˜è®¤ä½¿ç”¨äº†ä¸€æ¬¡v[i]è´§å¸ï¼Œç°åœ¨æ€»é¢å€¼å˜æˆäº†j-v[i]
#include<iostream>
using namespace std;
int money[1010];
long long dp[1010][1010];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>money[i];
		dp[i][0]=1;
	}
	


	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){	
			if(j<money[i]) dp[i][j]=dp[i-1][j];
			else dp[i][j]=dp[i-1][j]+dp[i][j-money[i]];
		}
	}
	cout<<dp[n][m];

    return 0;
}

```



#### ACWing278

```c++
#include<iostream>
using namespace std;
long long dp[10010];
int num[110];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>num[i];
    }
    
    dp[0]=1;//æ˜¾ç„¶ä»€ä¹ˆéƒ½ä¸é€‰ä¹Ÿæ˜¯ä¸€ç§æ–¹æ¡ˆæ•°
    for(int i=1;i<=n;i++){
        for(int j=m;j>=num[i];j--){
            dp[j]=dp[j]+dp[j-num[i]];
        }
    }
    
    cout<<dp[m];
   
    return 0;
}
```



#### ACWing1023

```c++
#include<iostream>
using namespace std;
int money[]={0,1,2,5,10};
int dp[1010];
int main()
{
	int n;
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=4;i++){
		for(int j=money[i];j<=n;j++){
			dp[j]=dp[j]+dp[j-money[i]];
		}
	}
	cout<<dp[n];
    return 0;
}


```

### æ‰“å®¶åŠ«èˆII

å¦‚ä½•æŠŠç¯å½¢è½¬åŒ–æˆçº¿æ€§ï¼Œè¿™æ˜¯æœ€å›°éš¾çš„åœ°æ–¹ã€‚

```c++
class Solution {
public:
    int func(vector<int>nums,int start,int end){
        int n=nums.size();
        vector<int>dp(n);
        dp[start]=nums[start];
        dp[start+1]=max(nums[start],nums[start+1]);
        for(int i=start+2;i<n;i++){
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }

        return dp[end];
    }
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];
        if(n==2) return max(nums[0],nums[1]);
        int res1=func(nums,0,n-2);
        int res2=func(nums,1,n-1);
        return max(res1,res2);


    }
};
```

### åŠ›æ‰£æ‰“å®¶åŠ«èˆIII

æ ‘å½¢DPå…¥é—¨

æœ¬è´¨ä¸Šè¿˜æ˜¯äºŒå‰æ ‘çš„é€’å½’è¿ç®—ï¼Œé‡‡ç”¨åç»­éå†çš„æ–¹å¼

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>func(TreeNode*root){
        if(root==nullptr) return vector<int>{0,0};

        vector<int>left=func(root->left);
        vector<int>right=func(root->right);
        vector<int>dp(2,0);
        dp[0]=max(right[0],right[1])+max(left[0],left[1]);
        dp[1]=root->val+left[0]+right[0];
        return vector<int>{dp[0],dp[1]};

       

    }
    int rob(TreeNode* root) {
        vector<int>dp=func(root);
        return max(dp[0],dp[1]);




    }
};
```

### ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸ

æœ¬é¢˜å¯ä»¥ä½¿ç”¨æš´åŠ›è§£æ³•



```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0],dp[n-1][1]);
        

    }
};
```

### ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸII

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2,0));
        dp[0][0]=-prices[0];
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0],dp[n-1][1]);


    }
};
```

### ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸIII

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(5,0));
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[0][2]=0;
        dp[0][3]=-prices[0];
        dp[0][4]=0;
        for(int i=1;i<n;i++){
            dp[i][0]=dp[i-1][0];
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
            dp[i][2]=max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4]=max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }

        return dp[n-1][4];

    }
};
```

### ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸIV

æœ¬é¢˜æ˜¯ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸIIIçš„å»¶ç”³ï¼Œå…¶å®é¢˜ç›®æ²¡æœ‰å˜åŒ–ï¼Œä¸æ¶‰åŠåŠ¨æ€è§„åˆ’æ€è·¯çš„åˆ›æ–°ï¼Œåªæ˜¯ä¸çŸ¥é“å¦‚ä½•æŠŠkè¡¨è¾¾å‡ºæ¥

æ¯æ¬¡ä¹°å–ï¼Œéƒ½æœ‰ä¹°åˆ°å’Œå–å‡ºä¸¤ç§çŠ¶æ€ï¼Œè®¾è®¡å˜é‡jï¼Œj+1è¡¨ç¤ºä¹°åˆ°ï¼Œj+2è¡¨ç¤ºå–å‡ºï¼Œæ‰€ä»¥jæ˜¯+=2å˜åŒ–çš„

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2*k+1,0));
        for(int j=0;j<2*k;j++){
            if(j%2==0) dp[0][j]=0;
            else dp[0][j]=-prices[0];
        }

        for(int i=1;i<n;i++){
            for(int j=0;j<2*k;j+=2){
                dp[i][j+1]=max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
                dp[i][j+2]=max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
            }
        }

        return dp[n-1][2*k];

    }
};
```

### ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸå«å†·å†»æœŸ

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(4,0));
        dp[0][0]=-prices[0];//0è¡¨ç¤ºæŒè‚¡
        dp[0][1]=0;//1è¡¨ç¤ºä¿æŒå–å‡ºçŠ¶æ€
        dp[0][2]=0;//2è¡¨ç¤ºå½“å¤©å–å‡º
        dp[0][3]=0;//3è¡¨ç¤ºå†·å†»æœŸ
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],
            max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));
            dp[i][1]=max(dp[i-1][1],dp[i-1][3]);
            dp[i][2]=dp[i-1][0]+prices[i];
            dp[i][3]=dp[i-1][2];
        }

        return max(dp[n-1][3],max(dp[n-1][1],dp[n-1][2]));

    }
};
```

### ä¹°è‚¡ç¥¨çš„æœ€ä½³æ—¶æœŸå«æ‰‹ç»­è´¹

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(3,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        dp[0][2]=-fee;
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],
            max(dp[i-1][2]-prices[i],dp[i-1][1]-prices[i]));
            dp[i][1]=max(dp[i-1][2],dp[i-1][1]);
            dp[i][2]=dp[i-1][0]+prices[i]-fee;
        }

        return max(dp[n-1][1],dp[n-1][2]);

    }
};
```

### æœ€é•¿é€’å¢å­åºåˆ—

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n=nums.size();
        vector<int>dp(n,1);
       
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=max(dp[j]+1,dp[i]);
                }           
            }
            
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

### æœ€é•¿è¿ç»­é€’å¢å­åºåˆ—

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        vector<int>dp(n, 1);
        for (int i = 1; i < n; i++) {
            if(nums[i-1]<nums[i]){
                dp[i]=dp[i-1]+1;
            }       
        }
        return *max_element(dp.begin(), dp.end());
    }
};

```

### æœ€é•¿é‡å¤å­æ•°ç»„

çœ‹è®²ä¹‰çš„é¢˜è§£

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n1=nums1.size();
        int n2=nums2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        int res=0;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                if(dp[i][j]>res) res=dp[i][j];
            }
        }
        return res;
    }
};
```

### æœ€é•¿å…¬å…±å­åºåˆ—

è®¾dp[i] [j]æ˜¯ä»¥text1[0â€¦i-1],text2[0..j-1]ä¸ºç»“å°¾çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ã€‚

å¯¹äºtext1 =â€œabcdeâ€ å’Œtext2=â€œaceâ€,å¦‚æœtext1[i-1]==text2[j-1],æ¯”å¦‚ï¼Œåˆ™æˆ‘ä»¬åªéœ€è¦çœ‹ä¸Šä¸€ç§çŠ¶æ€dp[i-1] [j-1]+1

å¦‚æœtext1[i-1]!=text2[j-1],åˆ™æˆ‘ä»¬è¿˜éœ€è¦åˆ¤æ–­ä¸¤ç§æƒ…å†µ

æ¯”å¦‚abc aceä¸­c!=e,é‚£æˆ‘ä»¬è¿˜éœ€è¦æ¯”è¾ƒabcå’Œac,abå’Œaceæ‰å¯ä»¥åˆ¤æ–­å‡ºæœ€é•¿å…¬å…±åºåˆ—çš„é•¿åº¦

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1=text1.size(),n2=text2.size();
        int a;
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        int res=0;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(text1[i-1]==text2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n1][n2];

    }
};
```

### åŠ›æ‰£1036ä¸ç›¸äº¤çš„çº¿

å’Œæœ€é•¿å…¬å…±å­åºåˆ—ä¸€ä¸ªå¥—è·¯å•¦

```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n1=nums1.size();
        int n2=nums2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(nums1[i-1]==nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n1][n2];

    }
};
```

### åŠ›æ‰£53æœ€å¤§è¿ç»­å­æ•°ç»„å’Œ

ç®€ç®€å•å•çš„å•¦

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>dp(n);
        dp[0]=nums[0];
        for(int i=1;i<n;i++){
            dp[i]=max(nums[i],dp[i-1]+nums[i]);
        }

        return *max_element(dp.begin(),dp.end());

    }
};
```

### åŠ›æ‰£392åˆ¤æ–­å­åºåˆ—é—®é¢˜

æœ¬é¢˜å’Œæœ€é•¿å…¬å…±å­åºåˆ—éå¸¸çš„ç›¸ä¼¼ï¼Œæ˜¯åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—

åœ¨æœ€é•¿å…¬å…±å­åºåˆ—é—®é¢˜ä¸­ï¼Œå¦‚æœå½“å‰æ¯”è¾ƒçš„å…ƒç´ ä¸ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬è¦åˆ†åˆ«è®¨è®ºåˆ é™¤ä¸¤å­—ç¬¦ä¸²å½“å‰å­—ç¬¦ä¹‹åçš„æœ€é•¿å…¬å…±å­åºåˆ—

ä½†æ˜¯åœ¨è¿™ä¸€é¢˜ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å›ºå®šçš„ï¼Œå› ä¸ºè¦æ»¡è¶³è¯¥å­—ç¬¦ä¸²æ˜¯å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸²çš„æ¯ä¸€ä¸ªå­—æ¯éƒ½éœ€è¦æ˜¯å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—ï¼Œå¦‚æœä¹Ÿåˆ é™¤è¯¥å­—ç¬¦ä¸²çš„å­—ç¬¦ï¼Œæœ‰å¯èƒ½å‡ºç°ï¼šabcdefg    aideè¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œåä¸€ä¸ªå­—ç¬¦ä¸²å°±ä¸æ˜¯å‰ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n1=s.size();
        int n2=t.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(s[i-1]==t[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=dp[i][j-1];
            }
        }

        return dp[n1][n2]==n1;

    }
};
```

### åŠ›æ‰£115ä¸åŒçš„å­åºåˆ—

çœ‹é¢˜è§£ï¼Œé¢˜è§£å†™çš„å¾ˆæ¸…æ¥š

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        int n1=s.size();
        int n2=t.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;i++) dp[i][0]=1;
        for(int i=1;i<=n2;i++) dp[0][i]=0;
        dp[0][0]=1;
        int a=1e9+7;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(s[i-1]==t[j-1])
                {
                    dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%a;
                } 
                else dp[i][j]=(dp[i-1][j])%a;
            }
        }

        return dp[n1][n2];

    }
};
```

### åŠ›æ‰£583ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ

æœ¬é¢˜çš„dp[i] [j]çš„å«ä¹‰æ˜¯ï¼šä»¥i-1ç»“å°¾ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²word1,å’Œä»¥j-1ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²word2,åˆ é™¤å­—ç¬¦ç›¸åŒçš„æœ€å°æ­¥æ•°

æ³¨æ„å®šä¹‰ï¼ï¼ï¼

æ‰€ä»¥å¦‚æœword1[i]==word2[j],é‚£ä¹ˆè¿™ä¸ªå­—æ¯ä¸ç”¨åˆ é™¤ï¼Œçœ‹å‰é¢çš„å­—ç¬¦å°±å¯ä»¥

å¦‚æœä¸ç›¸åŒï¼Œå¯ä»¥è€ƒè™‘åˆ é™¤ä¸¤å­—ç¬¦ä¸²çš„ä»»æ„ä¸€ä¸ªå­—ç¬¦

å¯¹äºdp[i] [0]è¡¨ç¤ºçš„æ˜¯å¦‚æœword2æ˜¯ç©ºä¸²ï¼Œåˆ™word1éœ€è¦åˆ é™¤æ‰€æœ‰å­—ç¬¦æ‰èƒ½ä¸ä¹‹ç›¸åŒ¹é…

ä¸æ­¤ç›¸åŒçš„è¿˜æœ‰dp[0] [j]

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=0;i<=n1;i++) dp[i][0]=i;
        for(int j=0;j<=n2;j++) dp[0][j]=j;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1);
            }
        }

        return dp[n1][n2];
    }
};
```

### åŠ›æ‰£72ç¼–è¾‘è·ç¦»

é¢˜è§£è®²çš„æŒºå¥½çš„

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=0;i<=n1;i++) dp[i][0]=i;
        for(int j=0;j<=n2;j++) dp[0][j]=j;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=min(min(dp[i][j-1]+1,dp[i-1][j]+1),dp[i-1][j-1]+1);
                }

            }
        }

        return dp[n1][n2];

    }
};
```

### åŠ›æ‰£647å›æ–‡å­ä¸²

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240712180757705.png" alt="image-20240712180757705" style="zoom:67%;" />

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int n=s.size();
        int res=0;
        vector<vector<bool>>dp(n,vector<bool>(n,false));
        for(int i=n-1;i>=0;i--){
            for(int j=n-1;j>=i;j--){
                if(s[i]==s[j]){
                    if(j-i<=1){
                        dp[i][j]=true;
                        res++;
                    }
                    else{
                        if(dp[i+1][j-1]==true){
                             dp[i][j]=true;
                             res++;
                        }
                        else dp[i][j]=false;
                    }
                }
            }
        }

        return res;


    }
};
```

### åŠ›æ‰£516æœ€é•¿å›æ–‡å­åºåˆ—

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n=s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++)
            dp[i][i] = 1;
        for (int i = n - 1; i >= 0; i--) {
            for (int j =i+1 ; j <n; j++) {//éå†é¡ºåºä»å·¦å¾€å³ï¼Œä»ä¸‹å¾€ä¸Š
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

### 5åŠ›æ‰£æœ€é•¿å›æ–‡å­ä¸²

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        string res = s.substr(0, 1);
        int maxlen = 1;
        vector<vector<bool>>dp(n, vector<bool>(n, false));

        for (int i = 0; i < n; i++) dp[i][i] = true;

        for (int i = n - 1; i >= 0; i--) {
            for (int j =i+1; j<n; j++) {
                if (s[i] == s[j]) {
                    if (j - i == 1) {
                        dp[i][j] = true;
                        if (j - i + 1 > maxlen) {
                            maxlen = j - i + 1;
                            res = s.substr(i, j - i + 1);
                        }
                    }

                    else {
                        if (dp[i + 1][j - 1] == true) {
                            dp[i][j] = true;
                            if (j - i + 1 > maxlen) {
                                maxlen = j - i + 1;
                                res = s.substr(i, j - i + 1);
                            }
                        }
                    }
                }
            }
        }

        return res;
    }
};
```



### ç¡¬å¸é—®é¢˜

ç¡¬å¸é—®é¢˜å¯ä»¥è´ªå¿ƒçš„æƒ…å†µé€šå¸¸åŒ…æ‹¬ä»¥ä¸‹å‡ ç§ï¼š

1. æ¯ä¸€ç§é¢å€¼çš„ç¡¬å¸éƒ½å¯ä»¥æ— é™ä½¿ç”¨ï¼šå¦‚æœæ¯ç§é¢å€¼çš„ç¡¬å¸æ•°é‡æ˜¯æ— é™çš„ï¼Œå¹¶ä¸”é¢å€¼ä¹‹é—´æ»¡è¶³æŸç§å…³ç³»ï¼Œæ¯”å¦‚æ¯ç§é¢å€¼éƒ½æ˜¯å‰ä¸€ç§é¢å€¼çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•ã€‚
2. é¢å€¼ä¹‹é—´æ»¡è¶³æŸç§æ€§è´¨ï¼šå¦‚æœç¡¬å¸çš„é¢å€¼ä¹‹é—´å­˜åœ¨æŸç§ç‰¹æ®Šçš„å…³ç³»ï¼Œæ¯”å¦‚æ˜¯ç­‰æ¯”æ•°åˆ—ã€æ–æ³¢é‚£å¥‘æ•°åˆ—ç­‰ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥ä½¿ç”¨è´ªå¿ƒç®—æ³•ã€‚
3. æœ€ä¼˜å­ç»“æ„æ€§è´¨ï¼šç¡¬å¸é—®é¢˜çš„æœ€ä¼˜è§£å¯ä»¥ç”±å­é—®é¢˜çš„æœ€ä¼˜è§£ç»„åˆè€Œæˆï¼Œè€Œä¸”å­é—®é¢˜ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œä¸å­˜åœ¨ä¾èµ–å…³ç³»ã€‚

å½“æˆ‘ä»¬è¦å‡‘å‡ºw=15ï¼Œé¦–å…ˆé¢ä¸´ä¸‰ç§æƒ…å†µçš„é€‰æ‹©

å½“æˆ‘ä»¬é€‰æ‹©äº†ä»·å€¼ä¸º1çš„ç¡¬å¸æ—¶ï¼Œé—®é¢˜è½¬åŒ–æˆäº†1+å‡‘å‡ºä»·å€¼ä¸º14çš„é—®é¢˜

å½“æˆ‘ä»¬é€‰æ‹©äº†ä»·å€¼ä¸º5çš„ç¡¬å¸çš„æ—¶å€™ï¼Œé—®é¢˜è½¬åŒ–æˆäº†1+å‡‘å‡ºä»·å€¼ä¸º10çš„é—®é¢˜

å½“æˆ‘ä»¬é€‰æ‹©äº†ä»·å€¼ä¸º11çš„ç¡¬å¸çš„æ—¶å€™ï¼Œé—®é¢˜è½¬åŒ–æˆäº†å‡‘å‡ºä»·å€¼ä¸º4çš„é—®é¢˜



![image-20240402214153424](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402214153424.png)



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int dp[100], i;
    dp[0] = 0;//f(0)çš„æƒ…å†µï¼Œä»·å€¼ä¸º0é‚£æˆ‘ä»¬è¿˜å‡‘ä¸ªé›†è´¸å•Šï¼Œç¡¬å¸æ•°ç›´æ¥ä¸º0å³å¯
    int cost;
    for (int i = 1; i <= 15; i++) {
        cost = 9999;
        if (i - 1 >= 0) cost = min(cost, dp[i - 1] + 1);//è¡¨ç¤ºæˆ‘ä»¬ä½¿ç”¨äº†æ­¤ç¡¬å¸ä¸€æ¬¡ï¼Œæ‰€ä»¥åŠ ä¸€
        if (i - 5 >= 0) cost = min(cost, dp[i - 5] +1);
        if (i - 11 >= 0)cost = min(cost, dp[i - 11] + 1);
        dp[i] = cost;
        printf("dp[%d]=%d\n", i, dp[i]);
    }


    return 0;
}

```

![image-20240402215125353](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402215125353.png)



















### åŠ›æ‰£53æœ€å¤§å­æ•°ç»„å’Œ

çœ‹é¢˜è§£ï¼Œå†™çš„å¾ˆç²¾å½©



### åŠ›æ‰£æ¯”ç‰¹ä½è®¡æ•°

æ–¹æ³•ä¸€å°±æ˜¯éå†æ•°ç»„ï¼Œæ¯ä¸€æ¬¡éƒ½è®¡ç®—x&(x-1)å˜æˆé›¶æ‰€éœ€è¦çš„æ¬¡æ•°ï¼Œä½†æ˜¯è¿™æœ‰å¾ˆå¤šé‡å¤è®¡ç®—

æ‰€ä»¥åŠ¨æ€è§„åˆ’

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};


```





### åŠ›æ‰£1668æœ€å¤§é‡å¤å­å­—ç¬¦ä¸²

KMPç®—æ³•





# é€’å½’è°ƒç”¨

### ç›´æ¥æ’å…¥æ’åº

```c++
#include<iostream>
#include<vector>
using namespace std;
void func(vector<int>& array, int n, int i) {
	if (i == 0) return;
	func(array, n, i - 1);
	if (array[i] < array[i - 1]) {
		int tmp = array[i];
		int j = i - 1;
		do {
			array[j + 1] = array[j];
			j--;
		} while (j >= 0 && array[j] > tmp);
	}
	

} 

```

### 0/1èƒŒåŒ…

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 10;
vector<int>x(N, 0);
int func(vector<int>value, vector<int>weight, int i, int rw) {
	int n = value.size();
	if (i >= n || rw < 0) return 0;
	int max1 = 0;
	int max2 = 0;
	if (rw >= weight[i]) {
		max1 = func(value, weight, i + 1, rw - weight[i])+value[i];
	}

	max2 = func(value, weight, i + 1, rw);

	if (max1 > max2) {
		x[i] = 1;
		return max1;
	}
	else {
		x[i] = 0;
		return max2;
	}
	

}

void knap(vector<int>value, vector<int>weight, int i, int rw) {
	int result = func(value, weight, 0, rw);
	int n = value.size();
	cout << "æ–¹æ¡ˆä¸º:" <<endl;
	int sum = 0;
	for (int i = 0; i < n; i++) {
		if (x[i] == 1) {
			cout << "ç‰©å“ " << i << ":" << "ä»·å€¼: " << value[i] << "é‡é‡: " << weight[i] << endl;
			sum += value[i];
		}
	}

	cout << "æ€»ä»·å€¼:"<<sum << endl;
}
int main() { 
	vector<int>value = { 4,4,3,1 };
	vector<int>weight = { 5,3,2,1 };
	int rw = 6;
	knap(value, weight, 0, rw);

}
```



### æ±‚è§£ç®€å•è¡¨è¾¾å¼

```
#include<iostream>
#include<string>
using namespace std;
class Solution {
	string text;
	int n;
public:
	int func1(string s) {
		text = s;
		n = s.size();
		int i = 0;
		return func2(s, i, n);
	}

	int func2(string s, int& i, int n) {
		int answer = 0;
		int sgn = 1;
		while (i < n) {
			if (s[i] == '(') {
				i++;
				int sd= func2(s, i, n);
				answer += sd;
			}
			else if (s[i] == '-') {
				sgn = -1;
				i++;	
			}

			else if (s[i] - '0' >= 0 && s[i] - '0' <= 9) {
				int d = 0;
				while (i < n && (s[i] - '0' >= 0 && s[i] - '0' <= 9)) {
					d = d * 10 + (s[i] - '0');
					i++;
				}
				answer +=d*sgn;
			}
			else if (s[i] == '+') {
				sgn = 1;
				i++;
			}
			else {
				i++;
				return answer;
			}

		}
		return answer;	
	}	
};

int main() {
	Solution a;
	cout<<a.func1("(4+5+(2-3)-2");
	return 0;
}
```





# é€’æ¨æ±‚è§£

### ä¾‹é¢˜1

![image-20240313044505011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044505011.png)



åªæœ‰ä¸€æ ¹æŠ˜çº¿çš„æƒ…å†µ

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044533512.png" alt="image-20240313044533512" style="zoom:50%;" />

æœ‰ä¸¤æ ¹æŠ˜çº¿çš„æƒ…å†µ

![image-20240313045453327](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045453327.png)

å¯çŸ¥ä¸€æ ¹æŠ˜çº¿ä¼šä¸å¦ä¸€ä¸ªæŠ˜ç°æœ‰4ä¸ªäº¤ç‚¹

æ‰€ä»¥çŠ¶æ€è½¬ç§»æ–¹ç¨‹  f(n)=4*(n-1)+1,å…¶ä¸­(n-1)æ˜¯äº¤ç‚¹æ•°ï¼Œäº¤ç‚¹æ•°åŠ ä¸€å°±æ˜¯çº¿æ®µæ•°

### éª¨ç‰Œé“ºæ»¡é—®é¢˜



![image-20240313045653763](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045653763.png)

è¿™ä¸€é¢˜çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—

å‡è®¾f(n-1)å·²ç»çŸ¥é“ï¼Œé‚£ä¹ˆæœ‰ä¸¤ç§æƒ…å†µ

ç¬¬ä¸€ç§æ˜¯æœ€åä¸€ä¸ªæ ¼å­æ”¾æ•°æ¡ï¼Œé‚£ä¹ˆåªæœ‰è¿™ä¸€ç§æ”¾æ³•ï¼Œæ€»å…±æœ‰f(n-1)ç§

ç¬¬äºŒç§æ˜¯æœ€åä¸¤ä¸ªæ ¼å­æ”¾æ¨ªæ¡ï¼Œå› ä¸ºä¸Šé¢ä¸¤ä¸ªå„è‡ªæ”¾äº†æ¨ªæ¡ï¼Œé‚£ä¹ˆä¸‹é¢é‚£ä¸¤ä¸ªæ ¼å­ä¹Ÿåªèƒ½æ”¾æ¨ªæ¡ï¼Œä¹Ÿåªæœ‰ä¸€ç§æ–¹æ³•ï¼Œæ€»å…±æœ‰f(n-2)ç§

æ‰€ä»¥f(n)=f(n-1)+f(n-2)



![image-20240313045940604](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045940604.png)





![image-20240313050000122](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050000122.png)



<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050438505.png" alt="image-20240313050438505" style="zoom:50%;" />

çŠ¶æ€è½¬ç§»æ–¹ç¨‹f(n)=f(n-1)+f(n-2)+f(n-4)



![image-20240313050730568](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050730568.png)





# ç©·ä¸¾æ³•

### æ±‚å›æ–‡ä¸²çš„ä¸ªæ•°

ç©·ä¸¾çš„æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒé«˜

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<set>
using namespace std;
bool ispal(string& s, int i, int j) {
	int low = i, high = j;
	while (i <= j) {
		if (s[i] != s[j]) return false;
		i++;
		j--;
	}

	return true;
}
int countSubstring(string& s) {
	int n = s.size();
	set<string>myset;
	for (int i = 0; i < n; i++) {
		for (int j = i; j < n; j++) {
			if(ispal(s, i, j)) myset.insert(s.substr(i, j - i + 1));
		}
	}

	return myset.size();
}


int main() {
	string s = "mokkori";
	cout << countSubstring(s);
	
}
```



ä¼˜åŒ–ç®—æ³•

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<set>
using namespace std;
void cnt(set<string>&myset,int n,string& s, int l, int r) {
	
	while (l>=0&&r<n&&s[l]==s[r]) {
		myset.insert(l, r - l + 1);
		l--;
		r++;
	}

	
}
int countSubstring(string& s) {
	set<string>myset;
	int n = s.size();
	for (int c = 0; c < n; c++) {
		cnt(myset, n, s, c, c);
	}

	for (int c = 0; c < n-1; c++) {
		cnt(myset, n, s, c, c + 1);
	}

	return myset.size();
}


int main() {
	string s = "mokkori";
	cout << countSubstring(s);
	
}
```



### æ±‚å¹‚é›†

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>> pset1(int n) {		//è§£æ³•1
	vector<vector<int>> ps;				//å­˜æ”¾å¹‚é›†
	for (int i = 0; i < (1 << n); i++) {			//æ‰§è¡Œ2^næ¬¡
		vector<int> e;
		for (int j = 0; j < n; j++) {
			if (i & (1 << j))
				e.push_back(j + 1);
		}
		ps.push_back(e);
	}
	return ps;
}
void powerset1(int n) {
	vector<vector<int>> ps;
	ps = pset1(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}


vector<vector<int>> pset2(int n) {				//æ±‚å¹‚é›†ç®—æ³•2
	vector<vector<int>> ps;							//å­˜æ”¾å¹‚é›†
	vector<int> e;
	ps.push_back(e);										//æ·»åŠ {}ç©ºé›†åˆå…ƒç´ 
	for (int i = 1; i <= n; i++) {								//å¾ªç¯æ·»åŠ 1ï½n
		vector<vector<int>> A = ps;					//Aå­˜æ”¾ä¸Šä¸€æ­¥å¾—åˆ°çš„å¹‚é›†
		for (auto it = A.begin(); it != A.end(); ++it)
			(*it).push_back(i);							//åœ¨Açš„æ¯ä¸ªé›†åˆå…ƒç´ æœ«å°¾æ·»åŠ i
		for (auto it = A.begin(); it != A.end(); ++it)
			ps.push_back(*it);							//å°†Açš„æ¯ä¸ªé›†åˆå…ƒç´ æ·»åŠ åˆ°psä¸­
	}
	return ps;
}

void powerset2(int n) {
	vector<vector<int>> ps;
	ps = pset2(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}

vector<vector<int>> pset3(int n) {			//è§£æ³•3
	vector<vector<int>> ps;				//å­˜æ”¾å¹‚é›†
	vector<int> e;
	ps.push_back(e);						//æ·»åŠ {}ç©ºé›†åˆå…ƒç´ 
	for (int i = 1; i <= n; i++) {				//å¾ªç¯æ·»åŠ 1ï½n
		int m = ps.size();
		for (int j = 0; j < m; j++) {
			vector<int> e = ps[j];			//å–å‡ºe=ps[j]
			e.push_back(i);					//åœ¨eçš„æœ«å°¾æ·»åŠ i
			ps.push_back(e);				//å†å°†eæ·»åŠ åˆ°psä¸­ 
		}
	}
	return ps;
}

void powerset3(int n) {
	vector<vector<int>> ps;
	ps = pset3(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}


vector<vector<int>> pset4(int n) {		//è§£æ³•3ï¼šé€’å½’ç®—æ³• 
	if (n == 0)
		return { {} };
	vector<vector<int>> ps;				//å­˜æ”¾å¹‚é›†
	ps = pset4(n - 1);						//æ±‚æ±‚å‡º1-n-1çš„å¹‚é›†ps 
	int m = ps.size();
	for (int j = 0; j < m; j++) {
		vector<int> e = ps[j];			//å–å‡ºe=ps[j]
		e.push_back(n);					//åœ¨eçš„æœ«å°¾æ·»åŠ n
		ps.push_back(e);				//å†å°†eæ·»åŠ åˆ°psä¸­ 
	}
	return ps;
}

void powerset4(int n) {
	vector<vector<int>> ps;
	ps = pset4(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}

int main() {
	int n = 3;
	printf("1ï½%dçš„å¹‚é›†\n", n);
	printf("  è§£æ³•1: "); powerset1(n);
	printf("  è§£æ³•2: "); powerset2(n);
	printf("  è§£æ³•3: "); powerset3(n);
	printf("  è§£æ³•4: "); powerset4(n);
	return 0;
}

```

### 0/1èƒŒåŒ…é—®é¢˜

```c++
#include<iostream>
#include<vector>
using namespace std;
void func(vector<int>value,vector<int>weight,int n,int maxweight) {
	int maxv = 0;
	int maxw = 0;
	int maxi;
	
	for (int choose = 0; choose < (1 << n); choose++) {
		int sumv = 0, sumw = 0;
		for (int j = 0; j < n; j++) {
			if (choose & (1 << j)) {
				sumv += value[j];
				sumw += weight[j];
			}
		}

		if (sumw <= maxweight && sumv >= maxv) {
			maxv = sumv;
			maxw = sumw;
			maxi = choose;
		}
	}

	cout << "æœ€ä½³æ–¹æ¡ˆ: " << endl;
	cout << "é€‰ä¸­ç‰©å“:{";
	//æŠŠæ•°å­—içš„äºŒè¿›åˆ¶ä½æ•°æ˜¾ç¤ºå‡ºæ¥
	for (int i = 0; i < n; i++) {
		if (maxi & (1 << i)) {
			cout << i << " ";
		}
	}

	cout << "}" << endl;
	cout << "æ€»é‡é‡ä¸º:"<<maxw<<" æ€»ä»·å€¼ä¸º:" << maxv << endl;
	
}

int main() {
	vector<int>value = {4,4,3,1};
	vector<int>weight = {5,3,2,1};
	int n = 4;
	int maxweight=6;
	func(value, weight, n,maxweight);
	
}

```



### å…¨æ’åˆ—

è¿­ä»£å’Œå¢é‡

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>>res(int n){
	vector<vector<int>>ps = { {1} };
	//é‡‡ç”¨è¿­ä»£çš„ç®—æ³•
	for (int i = 2; i <= n; i++) {
		vector<vector<int>>temp = ps;
		ps.clear();
		for (auto it = temp.begin(); it != temp.end(); it++) {
			vector<int>e= (*it);
			for (int j = e.size(); j >=0; j--) {
				vector<int>el = e;
				auto place = el.begin() + j;
				el.insert(place, i);
				ps.push_back(el);
			}
			
		}
	}

	return ps;
}
int main() {
	vector<vector<int>>ps = res(3);
	for (int i = 0; i < ps.size(); i++) {
		for (int j = 0; j < ps[i].size(); j++) {
			cout << ps[i][j] << " ";
		}

		cout << endl;
	}
}
```



é€’å½’åšæ³•

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>>res(int n){
	if(n==1) return { {1} };
	vector<vector<int>>ps = res(n - 1);

	vector<vector<int>>temp = ps;
	ps.clear();
	for (auto it = temp.begin(); it != temp.end(); it++) {
		vector<int>e= (*it);
		for (int j = e.size(); j >=0; j--) {
			vector<int>el = e;
			auto place = el.begin() + j;
			el.insert(place, n);
			ps.push_back(el);
		}
		
	}
	 
	return ps;
}
int main() {
	vector<vector<int>>ps = res(3);
	for (int i = 0; i < ps.size(); i++) {
		for (int j = 0; j < ps[i].size(); j++) {
			cout << ps[i][j] << " ";
		}

		cout << endl;
	}
}
```



STL

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<int>e;
	vector<vector<int>>ps;
	for (int i = 1; i <= n; i++) e.push_back(i);
	do {
		ps.push_back(e);
	} while (next_permutation(e.begin(), e.end()));
	for (int i = 0; i < ps.size(); i++) {
		for (int j = 0; j < ps[i].size(); j++) {
			cout << ps[i][j] << " ";
		}

		cout << endl;
	}
}
```

### ä»»åŠ¡åˆ†é…é—®é¢˜

```c++
#include<iostream>
#include<vector>
using namespace std;
#define INF 0x3f3f3f3f
vector<vector<int>> perm1(int n) {						//ç®—æ³•1ï¼šè¿­ä»£æ±‚0ï½n-1çš„å…¨æ’åˆ—
	vector<vector<int>> pm={{0}};						//å­˜æ”¾å…¨æ’åˆ—
	for (int i=1;i<n;i++) {										//å¾ªç¯æ·»åŠ 2ï½n
		vector<vector<int>> pm1=pm;
		pm.clear();
		for (auto it=pm1.begin();it!=pm1.end();it++) {
			vector<int> e=(*it);									//å–å‡ºpm1ä¸­ä¸€ä¸ªå…ƒç´ e
			for (int j=e.size();j>=0;j--) {						//åœ¨eçš„æ¯ä¸ªä½ç½®æ’å…¥i
				vector<int> e1=e;
				auto it=e1.begin()+j;							//æ±‚å‡ºæ’å…¥ä½ç½®
				e1.insert(it,i);										//æ’å…¥æ•´æ•°i
				pm.push_back(e1);								//æ·»åŠ åˆ°pmä¸­
			}
		}
	}
	return pm;
}
void allocate(vector<vector<int>>& c) { //æ±‚ä»»åŠ¡åˆ†é…é—®é¢˜çš„æœ€ä¼˜æ–¹æ¡ˆ
	int n=c.size();
	vector<vector<int>> pm=perm1(n);
	vector<int> bestx;					//æœ€ä¼˜åˆ†é…æ–¹æ¡ˆ 
	int mincost=INF;						//æœ€å°æˆæœ¬ 
	for (int f=0;f<pm.size();f++) {		//æ±‚æ¯ä¸ªåˆ†é…æ–¹æ¡ˆçš„æˆæœ¬
		vector<int> x=pm[f];				//å–å½“å‰åˆ†é…æ–¹æ¡ˆx 
		int cost=0;
		for (int i=0;i<x.size();i++)	//äººå‘˜iåˆ†é…ä»»åŠ¡ps[f][i] 
			cost+=c[i][x[i]];

		printf("åˆ†é…æ–¹æ¡ˆ:x=ï¼ˆ");
		for(int k=0;k<x.size();k++)
			printf("%d ",x[k]);
		printf("ï¼‰ æ€»æˆæœ¬=%d\n",cost);			
			
		if (cost<mincost) {				//æ¯”è¾ƒæ±‚æœ€å°æˆæœ¬çš„æ–¹æ¡ˆ
			mincost=cost;
			bestx=x;
		}
	}
	printf("æœ€ä¼˜æ–¹æ¡ˆ:\n");
	for (int i=0;i<bestx.size();i++)
		printf("   äººå‘˜%dåˆ†é…ä»»åŠ¡%d\n",i,bestx[i]);
	printf("   æ€»æˆæœ¬=%d\n",mincost);
}
int main() {
	freopen("abc.out","w",stdout); 
	vector<vector<int>> c={{9,2,7,8},{6,4,3,7},{5,8,1,8},{7,6,9,4}};
	allocate(c);
	return 0;
}
```



### æ—…è¡Œå•†é—®é¢˜

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
#define INF 0x3f3f3f3f
void disppath(vector<int>&x,int plen,int s) {	//è¾“å‡ºä¸€æ¡è·¯å¾„x
	printf("%d",s);
	for(int i=0;i<x.size();i++)
		printf("->%d",x[i]);
	printf("->%d è·¯å¾„é•¿åº¦=%d\n",s,plen); 
} 
void TSP(vector<vector<int>> &A,int s) {
	int n=A.size();
	int bestlen=INF;			//å­˜æ”¾æœ€çŸ­è·¯å¾„é•¿åº¦ 
	vector<int> bestx,x;		//bestxå­˜æ”¾æœ€çŸ­è·¯å¾„ 
   	for(int i=0;i<n;i++) {		//å°†ésçš„é¡¶ç‚¹æ·»åŠ åˆ°xä¸­ 
   		if(i!=s)
   			x.push_back(i);
   	}
    printf("TSPæ±‚è§£\n");
    int cnt=0;						//ç´¯è®¡ç´¯è®¡æ•° 
  	do {
     	int curlen=0,u=s,j=0;
       	while(j<x.size()) {
          	int v=x[j];
            curlen+=A[u][v];			//å¯¹åº”ä¸€æ¡è¾¹<u,v>
            u=v;
            j++;
        }
        curlen+=A[u][s];
        printf("  è·¯å¾„%d:   ",++cnt); disppath(x,curlen,s); 
        if(curlen<bestlen) {			//æ¯”è¾ƒæ±‚æœ€çŸ­è·¯å¾„ 
        	bestlen=curlen;
        	bestx=x;
        }
    } while(next_permutation(x.begin(),x.end()));
    printf("  æœ€çŸ­è·¯å¾„:"); disppath(bestx,bestlen,s);
}

int main() {
	//freopen("abc.out","w",stdout);
	vector<vector<int>> A={{0,8,5,36}, {6,0,8,5}, {8,9,0,5}, {7,7,8,0}};
	int s=0;
	TSP(A,s);
	return 0;
}

```







### æœ€å¤§è¿ç»­å­åºåˆ—å’Œ

ä½¿ç”¨å‰ç¼€å’Œ

```
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int func(vector<int>array,int n) {
	vector<int>psum(n + 1, 0);
	psum[0] = 0;
	for (int i = 1; i <= n; i++) {
		psum[i] = psum[i - 1] + array[i-1];
	}

	int maxsum = 0;
	int cursum = 0;
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j <= n; j++) {
			cursum = psum[j] - psum[i];
			maxsum = max(maxsum, cursum);
		}
	}

	return maxsum;
}
```



ä¼˜åŒ–ç®—æ³•

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int func(vector<int>array,int n) {
	int maxsum = 0;
	int cursum = 0;
	for (int i = 0; i < n; i++) {
		cursum += array[i];
		if (cursum >= maxsum) maxsum = cursum;
		if (cursum < 0) cursum = 0;	
	}

	return max(maxsum,0);
}
```





### **æ•°çš„è´¨å› æ•°åˆ†è§£**

```c++
#include <iostream>
using namespace std;
int a[101] = { 0 };
int main() {
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		if (a[i] == 0) {
			for (int j = i * 2; j <= n; j += i) {
				a[j] = 1;
			}
		}
	}
	//ä¸€ä¸ªæ•°çš„è´¨å› æ•°åªèƒ½åœ¨æ¯”è¿™ä¸ªæ•°å°çš„è´¨æ•°ä¸­å»æ‰¾
	int i = 2;
	while (n >= 1&&i<=n) {
		if (a[i] == 0 && n % i == 0) {
			cout << i << " ";
			n = n / i;
		}
		else {
			i++;
		}
	}
}
```



### æœ‰ä¸€ä¸ªè¾¹é•¿ä¸ºnã€mçš„æ£‹ç›˜ï¼Œæ±‚æ£‹ç›˜å†…æœ‰å¤šå°‘ä¸ªæ­£æ–¹å½¢å’Œé•¿æ–¹å½¢

æšä¸¾æ­£æ–¹å½¢çš„è¾¹é•¿å°±å¯ä»¥å¾—åˆ°æ‰€æœ‰çš„æ­£æ–¹å½¢

æ–¹å½¢æ˜¯ç”±ä¸¤æ¡æ¨ªçº¿å’Œä¸¤æ¡ç«–çº¿ç»„æˆçš„

é€‰æ‹©ä¸¤æ¡æ¨ªçº¿å’Œä¸¤æ¡ç«–çº¿æ’åˆ—ç»„åˆ

n+1æ¡æ¨ªçº¿ï¼Œm+1æ¡ç«–çº¿

æ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯0(n),è¿˜æœ‰æ•°å­¦çš„æ—¶é—´å¤æ‚åº¦ä¸ºo(1)çš„ç®—æ³•

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

long long computeCombinations(int n, int k) {
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));

    for (int i = 0; i <= n; i++) dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            if (i == j) dp[i][j] = 1;
            else {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
    }

    return dp[n][k];
}

int main() {
    int rows, cols;
    cin >> rows >> cols;

    // Calculate the number of squares
    long long numSquares = 0;
    int minSide = min(rows, cols);
    for (int sideLength = 1; sideLength <= minSide; sideLength++) {
        numSquares += (rows + 1 - sideLength) * (cols + 1 - sideLength);
    }

    // Calculate the number of rectangles
    long long numLineCombinationsRows = computeCombinations(rows + 1, 2);
    long long numLineCombinationsCols = computeCombinations(cols + 1, 2);
    long long numRectangles = numLineCombinationsRows * numLineCombinationsCols - numSquares;

    cout << "Number of squares: " << numSquares << endl;
    cout << "Number of rectangles: " << numRectangles << endl;

    return 0;
}

```

### è¯´è°è€…çš„æ•°é‡

![image-20240718144521697](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718144521697.png)

å¯¹äºæœ¬é¢˜ï¼Œåªéœ€è¦éå†å¯èƒ½è¯´è°çš„äººçš„æ•°é‡ï¼Œæ¯”å¦‚å‡å®šæœ‰ä¸€ä¸ªäººè¯´è°ï¼Œå†éå†æ¯ä¸ªäººçš„ä¿¡æ¯ï¼Œå¦‚æœaè¯´è‡³å°‘æœ‰ä¸¤ä¸ªäººè¯´è°ï¼Œä½†æ˜¯å®é™…ä¸Šå‡è®¾çš„æ˜¯1ä¸ªäººè¯´è°ï¼Œé‚£ä¹ˆè¿™ä¸ªäººå°±è¯´è°äº†ï¼Œè®°å½•è¯´è°çš„äººæ•°++ï¼Œæœ€ååˆ¤æ–­è¯´è°çš„äººå’Œå‡å®šè¯´è°çš„äººæ˜¯å¦ç›¸ç­‰

![55b3a75ff7bcb8b606ad9af733e52c1](D:\WeChat Files\wxid_aaaljrtur35n22\FileStorage\Temp\55b3a75ff7bcb8b606ad9af733e52c1.jpg)

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int>arr(n+1, 0);
        for (int i = 1; i <= n; i++) {
            cin >> arr[i];
        }
        int flag = 1;

        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 1; j <= n; j++) {
               
                if (arr[j] > i) cnt++;
            }
            if (cnt == i) {
                flag = 0;
                cout << cnt << endl;
                break;
            }
        }

        if (flag == 1) cout << -1 << endl;
       
    }

    
    return 0;
}

```

### ç å¿ƒç®—æµ‹éªŒ

ç å¿ƒç®—æ˜¯ä¸€ç§é€šè¿‡åœ¨è„‘ä¸­æ¨¡æ‹Ÿç®—ç›˜å˜åŒ–æ¥å®Œæˆå¿«é€Ÿè¿ç®—çš„ä¸€ç§è®¡ç®—æŠ€æœ¯ã€‚ç å¿ƒç®—è®­ç»ƒï¼Œæ—¢èƒ½å¤Ÿå¼€å‘æ™ºåŠ›ï¼Œåˆèƒ½å¤Ÿä¸ºæ—¥å¸¸ç”Ÿæ´»å¸¦æ¥å¾ˆå¤šä¾¿åˆ©ï¼Œå› è€Œåœ¨å¾ˆå¤šå­¦æ ¡å¾—åˆ°æ™®åŠã€‚

æŸå­¦æ ¡çš„ç å¿ƒç®—è€å¸ˆé‡‡ç”¨ä¸€ç§å¿«é€Ÿè€ƒå¯Ÿç å¿ƒç®—åŠ æ³•èƒ½åŠ›çš„æµ‹éªŒæ–¹æ³•ã€‚ä»–éšæœºç”Ÿæˆä¸€ä¸ªæ­£æ•´æ•°é›†åˆï¼Œé›†åˆä¸­çš„æ•°å„ä¸ç›¸åŒï¼Œç„¶åè¦æ±‚å­¦ç”Ÿå›ç­”ï¼šå…¶ä¸­æœ‰å¤šå°‘ä¸ªæ•°ï¼Œæ°å¥½ç­‰äºé›†åˆä¸­å¦å¤–ä¸¤ä¸ªï¼ˆä¸åŒçš„ï¼‰æ•°ä¹‹å’Œï¼Ÿ

æœ€è¿‘è€å¸ˆå‡ºäº†ä¸€äº›æµ‹éªŒé¢˜ï¼Œè¯·ä½ å¸®å¿™æ±‚å‡ºç­”æ¡ˆã€‚

è¾“å…¥æ ¼å¼ï¼š

å…±ä¸¤è¡Œï¼Œç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° nï¼Œè¡¨ç¤ºæµ‹è¯•é¢˜ä¸­ç»™å‡ºçš„æ­£æ•´æ•°ä¸ªæ•°ã€‚

ç¬¬äºŒè¡Œæœ‰ nä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸¤ä¸ªæ­£æ•´æ•°ä¹‹é—´ç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œè¡¨ç¤ºæµ‹è¯•é¢˜ä¸­ç»™å‡ºçš„æ­£æ•´æ•°ã€‚

è¾“å‡ºæ ¼å¼ï¼š

ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæµ‹éªŒé¢˜ç­”æ¡ˆã€‚

å¯¹äº 100% çš„æ•°æ®ï¼Œ3â‰¤ğ‘›â‰¤100ï¼Œæµ‹éªŒé¢˜ç»™å‡ºçš„æ­£æ•´æ•°å¤§å°ä¸è¶…è¿‡ 10,000ã€‚



æœ¬é¢˜çš„è§£é¢˜æ€è·¯æ˜¯ï¼šæœ¬é¢˜çš„æ•°æ®èŒƒå›´æ¯”è¾ƒå°ï¼Œæ‰€ä»¥åªè¦éå†å³å¯ã€‚



```c++
#include <iostream>
#include <vector>
#include <string>
#include<unordered_map>
using namespace std;


int main() {
    int n;
    cin >> n;
    vector<int>arr(n, 0);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    unordered_map<int, bool>is_in;
    for (int i = 0; i < n-1; i++) {
        for (int j = i + 1; j < n; j++) {
            is_in[arr[i] + arr[j]] = true;
        }
    }
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (is_in[arr[i]]) cnt++;
    }

    cout << cnt;
    return 0;
}

```

### å¯¼å¼¹æ‹¦æˆª

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718174148777.png" alt="image-20240718174148777" style="zoom: 80%;" />

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718174219904.png" alt="image-20240718174219904" style="zoom: 80%;" />

è°å®¶å¥½äººæ±‚å¯¼å¼¹çš„æœ€è¿œåŠå¾„çš„æ€»å’Œå•Šç¥ç»ç—…ï¼Œä¸åº”è¯¥æ±‚æ‰€æœ‰åŠå¾„æ€»å’Œå—

è´ªå¿ƒ+æšä¸¾

é¦–å…ˆå‡è®¾æ‰€æœ‰å¯¼å¼¹éƒ½ç”±ä¸€åº§æ‹¦æˆªå¡”æ‹¦æˆªï¼Œæ¥ç€æŠŠæœ€è¿œçš„åŠå¾„ç»™å¦ä¸€ä¸ªæ‹¦æˆªå¡”ï¼Œå¦‚æœå¾—åˆ°çš„ä»£ä»·æ¯”è¾ƒå°ï¼Œå°±é‡‡ç”¨å½“å‰åšæ³•

ä¸»è¦æ˜¯ï¼Œä½ èŠ±äº†å¾ˆé•¿æ—¶é—´åœ¨æ±‚åŠå¾„æ€»å’Œä¸Šä½†æ˜¯æœ¬é¢˜æ±‚çš„æ˜¯æœ€è¿œåŠå¾„æ€»å’Œã€‚

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int distance(int la, int lb, int lx, int ly) {
    int x = abs(la - lx);
    int y = abs(lb - ly);
    return x * x + y * y;
}

struct point {
    int x;
    int y;
    int distance;
};

bool compare(point& a, point& b) {
    return a.distance > b.distance;
}
int main() {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    int n;
    cin >> n;
    vector<vector<int>>map(n, vector<int>(2, 0));
    vector<point>distances1;
    int distances2=0;

    long long res = 0;
    for (int i = 0; i < n; i++) {
        cin >> map[i][0] >> map[i][1];
        int temp1 = distance(x1, y1, map[i][0], map[i][1]);

        distances1.push_back({ map[i][0],map[i][1],temp1 });


    }



    sort(distances1.begin(), distances1.end(), compare);
    res = distances1[0].distance;
    for (int i = 0; i < distances1.size()-1;i++) {
        int x = distances1[i].x;
        int y = distances1[i].y;
        int temp;
        if (distances2==0) {
            temp = distance(x2, y2, x, y);
            distances2 = temp;
        }
        else {
           temp = max(distances2, distance(x2, y2, x, y));
           distances2 = temp;
        }

        res = min(res, (long long)distances1[i + 1].distance + temp);

    }

  
    cout << res;


    return 0;
}




```

# åˆ†æ²»æ³•

### äºŒè·¯å½’å¹¶æ’åº

```c++
#include<iostream>
#include<vector>
using namespace std; 
void disp(vector<int>&a,int s,int t) {		//è¾“å‡ºa[s..t]å…ƒç´ 
	printf("[ ");
	for (int i=s;i<=t;i++)
		printf("%d ",a[i]);
	printf("]\n");
}
void merge(vector<int>&a,int low,int mid,int high) { //å°†a[low..mid]å’Œa[mid+1..high]å½’å¹¶ä¸ºä¸€ä¸ªæœ‰åºå­åºåˆ—a[low..high]
	vector<int> tmp(high-low+1);		//åˆ†é…ä¸´æ—¶ç©ºé—´
	int i=low,j=mid+1,k=0;
	while (i<=mid && j<=high) {			//ä¸¤ä¸ªæœ‰åºè¡¨å‡æœªéå†å®Œæ—¶å¾ªç¯
		if (a[i]<=a[j]) {				//å½’å¹¶è¾ƒå°å…ƒç´ a[i]
			tmp[k]=a[i];
			i++;k++; 
		}
		else {							//å½’å¹¶è¾ƒå°å…ƒç´ a[j]
			tmp[k]=a[j];
			j++;k++; 
		}
	}
	while (i<=mid) {			//å½’å¹¶æœ‰åºè¡¨1çš„ä½™ä¸‹å…ƒç´ 
		tmp[k]=a[i];
		i++;k++; 
	}
	while (j<=high) {			//å½’å¹¶æœ‰åºè¡¨2çš„ä½™ä¸‹å…ƒç´ 
		tmp[k]=a[j];
		j++;k++;
	}
	for (k=0,i=low;i<=high;k++,i++) 		//å°†tmpå…ƒç´ å¤åˆ¶å›aä¸­
		a[i]=tmp[k];
}
void mergesort(vector<int>&a,int low,int high) {	//å®ç°a[low..high]çš„äºŒè·¯å½’å¹¶æ’åº
	if (low<high) {					//å­åºåˆ—æœ‰ä¸¤ä¸ªæˆ–ä»¥ä¸Šå…ƒç´ 
		int mid=(low+high)/2;			//å–ä¸­é—´ä½ç½®		
		printf("å·¦åºåˆ—: ");disp(a,low,mid); 
		mergesort(a,low,mid);			//å¯¹a[low..mid]å­åºåˆ—æ’åº
		printf("æ’åºå·¦åºåˆ—: ");disp(a,low,mid); 

		printf("å³åºåˆ—: ");disp(a,mid+1,high); 
		mergesort(a,mid+1,high);		//å¯¹a[mid+1..high]å­åºåˆ—æ’åº
		printf("æ’åºå³åºåˆ—: ");disp(a,mid+1,high); 
		merge(a,low,mid,high);			//å°†ä¸¤å­åºåˆ—åˆå¹¶ä¸ºä¸€ä¸ªæœ‰åºåºåˆ— 
		printf("åˆå¹¶ç»“æœ: ");disp(a,low,high); 

	}
}
void mergesort(vector<int>&a) {			//açš„äºŒè·¯å½’å¹¶ç®—æ³•
	int n=a.size();
	mergesort(a,0,n-1);
}
int main() {
	vector<int> a={2,5,1,7,10,6,9,4,3,8};
	int n=a.size();
	printf("æ’åºå‰:"); disp(a,0,n-1);
	mergesort(a);
	printf("æ’åºå:"); disp(a,0,n-1);
	return 0;
}

```

### æœ€å¤§è¿ç»­å­åºåˆ—å’Œ

```c++
#include<iostream>
#include<vector>
using namespace std;
int func(vector<int>Arr, int low, int high) {
	if (low == high) {
		return max(Arr[low], 0);
	}

	int mid = (low + high) / 2;
	int maxleftsum = func(Arr, low, mid);
	int maxrightsum = func(Arr,mid + 1, high);


	int maxleftbordersum =0;
	int maxrightbordersum = 0;

	int leftsum = 0;
	int rightsum = 0;
	for (int i = mid; i >= low; i--) {
		leftsum += Arr[i];
		if(leftsum > maxleftbordersum) maxleftbordersum = leftsum;
	}
	
	for (int i = mid + 1; i <= high; i++) {
		rightsum += Arr[i];
		if (rightsum > maxrightbordersum) maxrightbordersum =rightsum;
	}

	int maxmid = maxleftbordersum + maxrightbordersum;
	int ans = max(max(maxleftsum, maxrightsum), maxmid);
	return max(ans, 0);


}
int main() {
	vector<int>array = { -2,11,-4,13,-5,2 };
	cout << func(array, 0, 5);
}

```

### æ£‹ç›˜è¦†ç›–é—®é¢˜

```c++
#include<iostream>
using namespace std;
#define MAX 1025
int k;							//æ£‹ç›˜å¤§å°
int x,y;						//ç‰¹æ®Šæ–¹æ ¼çš„ä½ç½®
int board[MAX][MAX];
int tile=1;									//Lå‹éª¨ç‰Œçš„ç¼–å·,ä»1å¼€å§‹
void chessboard(int tr,int tc,int dr,int dc,int size) {
	if(size==1) return;						//é€’å½’å‡ºå£
	int t=tile++;							//å–ä¸€ä¸ªLå‹éª¨ï¼Œå…¶ç‰Œå·ä¸ºtile
	int s=size/2;							//åˆ†å‰²æ£‹ç›˜
	//è€ƒè™‘å·¦ä¸Šè§’è±¡é™
	if(dr<tr+s && dc<tc+s)					//ç‰¹æ®Šæ–¹æ ¼åœ¨æ­¤è±¡é™ä¸­
		chessboard(tr,tc,dr,dc,s);
	else {									//æ­¤è±¡é™ä¸­æ— ç‰¹æ®Šæ–¹æ ¼
		board[tr+s-1][tc+s-1]=t;				//ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å³ä¸‹è§’
		chessboard(tr,tc,tr+s-1,tc+s-1,s);	//å°†å³ä¸‹è§’ä½œä¸ºç‰¹æ®Šæ–¹æ ¼ç»§ç»­å¤„ç†è¯¥è±¡é™
	}
	//è€ƒè™‘å³ä¸Šè§’è±¡é™
	if(dr<tr+s && dc>=tc+s)  
		chessboard(tr,tc+s,dr,dc,s);		//ç‰¹æ®Šæ–¹æ ¼åœ¨æ­¤è±¡é™ä¸­ 
	else {									//æ­¤è±¡é™ä¸­æ— ç‰¹æ®Šæ–¹æ ¼
		board[tr+s-1][tc+s]=t;					//ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å·¦ä¸‹è§’
		chessboard(tr,tc+s,tr+s-1,tc+s,s);  	//å°†å·¦ä¸‹è§’ä½œä¸ºç‰¹æ®Šæ–¹æ ¼ç»§ç»­å¤„ç†è¯¥è±¡é™
	}
	//å¤„ç†å·¦ä¸‹è§’è±¡é™
	if(dr>=tr+s && dc<tc+s)				//ç‰¹æ®Šæ–¹æ ¼åœ¨æ­¤è±¡é™ä¸­
		chessboard(tr+s,tc,dr,dc,s);  
	else { 									//æ­¤è±¡é™ä¸­æ— ç‰¹æ®Šæ–¹æ ¼
		board[tr+s][tc+s-1]=t;  				//ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å³ä¸Šè§’
        chessboard(tr+s,tc,tr+s,tc+s-1,s);	//å°†å³ä¸Šè§’ä½œä¸ºç‰¹æ®Šæ–¹æ ¼ç»§ç»­å¤„ç†è¯¥è±¡é™
   	}
	//å¤„ç†å³ä¸‹è§’è±¡é™
	if(dr>=tr+s && dc>=tc+s)					//ç‰¹æ®Šæ–¹æ ¼åœ¨æ­¤è±¡é™ä¸­
		chessboard(tr+s,tc+s,dr,dc,s); 
	else {									//æ­¤è±¡é™ä¸­æ— ç‰¹æ®Šæ–¹æ ¼
		board[tr+s][tc+s]=t;  					//ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å·¦ä¸Šè§’
		chessboard(tr+s,tc+s,tr+s,tc+s,s);  	//å°†å·¦ä¸Šè§’ä½œä¸ºç‰¹æ®Šæ–¹æ ¼ç»§ç»­å¤„ç†è¯¥è±¡é™
	}
}
int main() {
	k=3;
	x=1; y=2;
	int size=1<<k;
	chessboard(0, 0, x, y, size);
	for(int i=0; i<size; i++) {					//è¾“å‡ºæ–¹æ¡ˆ
		for(int j=0; j<size;j++)
			printf("%4d",board[i][j]);
		printf("\n");
	}
	return 0;
}

```



### å¾ªç¯æ—¥ç¨‹å®‰æ’é—®é¢˜

```c++
#include<iostream>
using namespace std;
#define MAX 101
int a[MAX][MAX];						//å­˜æ”¾æ¯”èµ›æ—¥ç¨‹è¡¨ï¼ˆè¡Œåˆ—ä¸‹æ ‡ä¸º0çš„å…ƒç´ ä¸ç”¨ï¼‰
void plan(int k) {
	int n=2;								//nä»2^1=2å¼€å§‹
	a[1][1]=1; a[1][2]=2;   			//æ±‚è§£2ä¸ªé€‰æ‰‹æ¯”èµ›æ—¥ç¨‹,å¾—åˆ°å·¦ä¸Šè§’å…ƒç´ 
	a[2][1]=2; a[2][2]=1;
	for (int t=1;t<k;t++) {						//è¿­ä»£å¤„ç†,ä¾æ¬¡å¤„ç†2^2(t=1)â€¦,2^k(t=k-1)ä¸ªé€‰æ‰‹
		int tmp=n;								//tmp=2^t
		n=n*2; 								//n=2^(t+1)
		for (int i=tmp+1;i<=n;i++) {			//å¡«å·¦ä¸‹è§’å…ƒç´ 
			for (int j=1; j<=tmp; j++)
				a[i][j]=a[i-tmp][j]+tmp; 	//å·¦ä¸‹è§’å…ƒç´ å’Œå·¦ä¸Šè§’å…ƒç´ çš„å¯¹åº”å…³ç³»
		}
		for (int i=1; i<=tmp;i++) {				//å¡«å³ä¸Šè§’å…ƒç´ 
			for (int j=tmp+1; j<=n; j++)
				a[i][j]=a[i+tmp][(j+tmp)% n];
		}
		for (int i=tmp+1;i<=n;i++) {			//å¡«å³ä¸‹è§’å…ƒç´ 
			for (int j=tmp+1; j<=n; j++)
				a[i][j]=a[i-tmp][j-tmp];
		}
    }
}
int main() {
	int k=3;
	int n=1<<k;							//nç­‰äº2çš„kæ¬¡æ–¹å³n=2^k
	plan(k);							//äº§ç”Ÿnä¸ªé€‰æ‰‹çš„æ¯”èµ›æ—¥ç¨‹è¡¨
	for(int i=1;i<=n;i++) {				//è¾“å‡ºæ¯”èµ›æ—¥ç¨‹è¡¨
		for(int j=1; j<=n; j++)
			printf("%4d",a[i][j]);
		printf("\n");
	}
	return 0;
}

```



### æ—…è¡Œå•†é—®é¢˜

```c++
#include<iostream>
#include<vector>
#include<set>
using namespace std;
const int INF=0x3f3f3f3f;
void dispset(set<int> &V) {
	printf("{");
	for (auto it=V.begin();it!=V.end();it++)
		printf("%d ",*it);
	printf("}");
}
int TSP(vector<vector<int>> &A,int s,set<int> V,int i) {							//æ±‚TSPæ‰€æœ‰è§£çš„è·¯å¾„é•¿åº¦
	int minpathlen=INF;						//æœ€çŸ­è·¯å¾„é•¿åº¦
	if (V.size()==0) {						//å½“Vä¸ºç©ºæ—¶
		printf("è®¡ç®—f({ },%d)\n",i);
		printf("æ±‚å‡ºf({ },%d),é€’å½’å‡ºå£pathlen=%d\n",i,A[s][i]);
		return A[s][i];
	}
	else {									//å½“Vä¸ºä¸ç©ºæ—¶
		printf("è®¡ç®—f("); dispset(V); printf(",%d)\n",i);
		for (auto it=V.begin();it!=V.end();it++) {	//æ‰«æé›†åˆVä¸­çš„é¡¶ç‚¹j
			set<int> tmpV=V;
			int j=*it;
			tmpV.erase(j);					//tmpV=V-{j}
			int pathlen1=TSP(A,s,tmpV,j);
			int pathlen=pathlen1+A[j][i];
			printf("    f("); dispset(tmpV); printf(",%d )",j); printf(",pathlen1=%d\n",pathlen1);
			minpathlen=min(minpathlen,pathlen);
		}
		printf("æ±‚å‡ºf("); dispset(V); printf(",%d),minpathlen=%d\n",i,minpathlen);
		return minpathlen;
	}
}
void solve(vector<vector<int>> &A,int s) {
	int n=A.size();
	set<int> V;
	for (int i=0;i<n;i++) {
		if(i!=s)
			V.insert(i);
	}
	printf("TSPè·¯å¾„é•¿åº¦=%d\n",TSP(A,s,V,s));	//è¾“å‡º23
}

int main() {
	//freopen("abc.out","w",stdout);
	vector<vector<int>> A={{0,8,5,36}, {6,0,8,5}, {8,9,0,5}, {7,7,8,0}};
	int s=2;
	solve(A,s);
	return 0;
}


```



# åŒºé—´é—®é¢˜

|          | åŒºé—´æ±‚å’Œ | åŒºé—´æœ€å¤§å€¼ | åŒºé—´ä¿®æ”¹ | å•ç‚¹ä¿®æ”¹ |
| -------- | -------- | ---------- | -------- | -------- |
| å‰ç¼€å’Œ   | 1        | 0          | 0        | 0        |
| å·®åˆ†     | 0        | 0          | 1        | 0        |
| æ ‘çŠ¶æ•°ç»„ | 1        | 1          | 0        | 1        |
| çº¿æ®µæ ‘   | 1        | 1          | 1        | 1        |

## å‰ç¼€å’Œ

```c++
prefixSum[i]=arr[0]+arr[1]+â‹¯+arr[iâˆ’1]+arr[i]
    
//å…¶ä¸­prefixsum[0]=0;
```



###  **æ±‚ä»»æ„åŒºé—´çš„å’Œ**

```c++
//åŒºé—´[l,r]ç­‰äºprefixsum[r]-prefixsum[l-1];
#include<iostream>
using namespace std;
int arr[1010];
int s[10010];
int main() {
	int n, m;
	scanf("%d ", &n,&m);
	for (int i = 1; i <= n; i++) {//ä¸‹æ ‡ä»ä¸€å¼€å§‹ï¼Œå¦‚æœä¸‹æ ‡ä»é›¶å¼€å§‹è¦é‡æ–°è®¾è®¡
		scanf("%d", &arr[i]);
		s[i] = s[i - 1] + arr[i];
	}
	while (m--) {
		int l, r;
		scanf("%d %d", &l, &r);
		printf("%d", s[r] - s[l - 1]);
	}
	return 0;

}
```



### åŠ›æ‰£3179

### äºŒç»´å‰ç¼€å’Œ

https://www.bilibili.com/video/BV18P411g7cu/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

```c++
//äºŒç»´å‰ç¼€å’Œs[i][j]è¡¨ç¤ºå‰iè¡Œå‰jåˆ—çš„çŸ©é˜µå…ƒç´ ä¹‹å’Œ
//i1è¡Œ,j1åˆ—ä¸i2è¡Œï¼Œj2åˆ—ä¹‹é—´çš„çŸ©é˜µå…ƒç´ ä¹‹å’Œ


#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, m;
    int arr[105][105] = {0}; // åˆå§‹åŒ–äºŒç»´æ•°ç»„ä¸º0ï¼Œé¿å…åƒåœ¾å€¼
    long long s[106][106] = {0}; // å‰ç¼€å’Œæ•°ç»„

    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
        }
    }

    // æ„å»ºå‰ç¼€å’Œæ•°ç»„
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + arr[i][j];
        }
    }

    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        int i1, j1, i2, j2;
        cin >> i1 >> j1 >> i2 >> j2;
        long long result = s[i2][j2] - s[i1-1][j2] - s[i2][j1-1] + s[i1-1][j1-1];
        cout << result << endl; // æ¯ä¸ªæŸ¥è¯¢ç»“æœä¹‹åæ¢è¡Œ
    }

    return 0;
}

```



### ä¸å¤ªç”œçš„ç³–æœ


ç»™å®šä¸€æ’é•¿åº¦ä¸ºnçš„ç³–æœä¸²ï¼Œæ¯ä¸ªç³–æœæœ‰ä¸€ä¸ªç”œåº¦ï¼Œæ±‚å‡ºä¸€ä¸ªæœ€çŸ­çš„ç³–æœä¸²ä½¿å¾—å®ƒçš„ç”œåº¦ä¹‹å’Œå¤§äºç­‰äºmã€‚

è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•°nå’Œmï¼Œç¬¬äºŒè¡Œæœ‰nä¸ªæ•°ã€‚

è¾“å‡ºæ ¼å¼

è¾“å‡ºä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªæ•°ï¼Œå³æœ€çŸ­çš„ç³–æœä¸²çš„é•¿åº¦ã€‚å¦‚æœæ‰¾ä¸åˆ°è¿™æ ·çš„ç³–æœä¸²ï¼Œè¾“å‡º0ï¼›

æ³¨æ„ç³–æœå­ä¸²æ˜¯è¿ç»­çš„

å¯¹äºæœ¬é¢˜ï¼Œæœ‰ä¸¤ç§è§£æ³•ï¼šæ»‘åŠ¨æ•°ç»„å’Œå‰ç¼€å’Œï¼Œæ»‘åŠ¨æ•°ç»„å¯¹äºç‰¹å®šæ•°æ®ä¼šè¶…æ—¶

![image-20240719210428381](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719210428381.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#include <climits> 

using namespace std;

bool check(vector<int>& prefix_sum, int mid, int target) {
    return prefix_sum[mid] < target;
}
int binary_search(vector<int>& prefix_sum, int low,int high,int target) {
    int l = low-1, r = high+1;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check(prefix_sum, mid, target)) l = mid;
        else r = mid;
    }

    if (r!=high+1&&prefix_sum[r]>=target) return r;
    else return -1;

}
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> sweetness(n+1,0);
    int min_Len = INT_MAX;

    for (int i = 1; i <= n; i++) {
        cin >> sweetness[i];
    }

    vector<int>prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + sweetness[i];
    }

    for (int i = 1; i <= n; i++) {
        int target = prefix_sum[i] + m;
        int index = binary_search(prefix_sum, i,n,target);
        if(index!=-1) min_Len = min(min_Len, index - i);
        
    }

    if (min_Len != INT_MAX) cout << min_Len;

    return 0;
}

```



### ACWing1236é€’å¢ä¸‰å…ƒç»„

åˆ·ç¬¬äºŒéï¼Œçœ‹é”™é¢˜ç›®äº†...

```c++
#include<iostream>
using namespace std;
int n;
int a[100010],b[100010],c[100010];
int cnta[100010],cntc[100010];
int sa[100010],sc[100010];
//ç”¨cnta,cntcè¡¨ç¤ºæ•°ç»„a,cå¯¹åº”å…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å› ä¸ºæ•°ç»„æ˜¯é¡ºåºçš„ï¼Œæ‰€ä»¥ç›¸å½“äºæˆ‘ä»¬æ’äº†åº
//æ¯”å¦‚å‡è®¾æ•°ç»„aæ˜¯1ï¼Œ2ï¼Œ3ï¼Œ5ï¼Œ5ï¼Œ6ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰
//é‚£ä¹ˆcntaå¯¹åº”çš„æ˜¯1 1 1 0 2 1
//è¿™ä¸‹æ¸…æ¥šäº†å§ï¼å› ä¸ºæ’äº†åºï¼Œæ‰€ä»¥å¯¹äºç‰¹å®šçš„b[i],åœ¨iå‰é¢çš„å°±æ˜¯å°äºb[i]çš„
int main(){
    cin>>n;
    long long res=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        cnta[++a[i]]++;
    }
    
    sa[0]=cnta[0];//æˆ‘ç»ˆäºçŸ¥é“ä¸ºä»€ä¹ˆäº†ï¼å› ä¸ºs[0]ä¸€èˆ¬é»˜è®¤ä¸ºé›¶ï¼Œå‰0é¡¹çš„å’Œå˜›ï¼Œä½†æ˜¯è¿™ä¸€é¢˜çš„æ•°æ®å¯ä»¥ä¸º0
    //ä¸ºäº†é¿å…å†²çªï¼Œ++a[i]ä¸€å®šå¤§äºé›¶äº†ï¼Œæ‰€ä»¥cnta[0]=0,æ»¡è¶³äº†sa[0]=0;
    for(int i=1;i<100010;i++) sa[i]=sa[i-1]+cnta[i];//æ³¨æ„è¿™é‡Œï¼Œå› ä¸ºnçš„å–å€¼èŒƒå›´æ˜¯100000
    //æ‰€ä»¥cnta[i]çš„å–å€¼èŒƒå›´æ˜¯0-100000ï¼Œä¸‡ä¸€éƒ½æ˜¯ä¸€ä¸ªæ•°å‘¢ï¼Œæ¯”å¦‚11111111
    for(int i = 1; i <= n; ++i){
        scanf("%d", &b[i]);
        b[i]++;
    } 
    for(int i=1;i<=n;i++){
        scanf("%d",&c[i]);
        cntc[++c[i]]++;
    }
    sc[0]=cntc[0];
    for(int i=1;i<100010;i++) sc[i]=sc[i-1]+cntc[i];
    for(int i=1;i<=n;i++){
        res+=(long long)sa[b[i]-1]*(sc[100010-1]-sc[b[i]]);
    }
    cout<<res;
    return 0;
    
}
```

### å¥¶ç‰›å¼¹é’¢ç´

![image-20240720202233987](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240720202233987.png)

![image-20240720202507280](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240720202507280.png)

å‰ç¼€å’Œæ•°ç»„prefix_sum[i]è¡¨ç¤ºå‰iä¸ªéŸ³é˜¶æ•²æ‰“èŠ±è´¹çš„æ—¶é—´ï¼Œæ¯”å¦‚å¯¹äºè¾“å…¥çš„æ•°æ®2 3 5

å‰1ä¸ªéŸ³èŠ‚èŠ±è´¹2

å‰2ä¸ªéŸ³èŠ‚èŠ±è´¹3

å‰3ä¸ªéŸ³èŠ‚èŠ±è´¹6

ç»™ä¸€ä¸ªæŸ¥è¯¢æ—¶é—´Tï¼Œå‡è®¾T=3æ‰¾å‡ºç¬¬ä¸€ä¸ªå‰ç¼€å’Œå¤§äºTçš„ä¸‹æ ‡ï¼Œæœ¬ä¾‹ä¸º3ï¼Œåˆ™è¯´æ˜Tæ—¶é—´çš„æ—¶å€™æˆ‘ä»¬åœ¨æ•²æ‰“ç¬¬ä¸‰ä¸ªéŸ³èŠ‚

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
bool check(vector<int>& prefix_sum,int mid,int target) {
    return prefix_sum[mid] <= target;
}
int binary_search(vector<int>& prefix_sum, int low, int high, int target) {
    int l = low - 1;
    int r = high + 1;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check(prefix_sum,mid,target)) l = mid;
        else r = mid;
    }

    if (r != high + 1 && prefix_sum[r] > target) return r;
    else return -1;

}
int main() {
    int N, Q;
    cin >> N >> Q;
    vector<int>B(N, 0);
    vector<int>prefix_sum(N + 1, 0);
    for (int i = 0; i < N; i++) {
        cin >> B[i];
        prefix_sum[i + 1] = prefix_sum[i] + B[i];
    }

    for (int i = 0; i < Q; i++) {
        int temp;
        cin >> temp;
        cout << binary_search(prefix_sum, 1, N, temp) << endl;
    }
    return 0;
}
```



## ä¸€ç»´å·®åˆ†

å·®åˆ†æ•°ç»„ç”¨äºå¿«é€Ÿæ›´æ–°æ•°ç»„çš„æŸä¸€æ®µåŒºé—´å†…çš„å…ƒç´ å€¼ã€‚å·®åˆ†æ•°ç»„çš„ä¸»è¦æ€æƒ³æ˜¯é€šè¿‡è®°å½•å˜åŒ–é‡æ¥é—´æ¥è¡¨ç¤ºæ•°ç»„çš„æ›´æ–°ã€‚ç›¸è¾ƒäºç›´æ¥æ›´æ–°æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œ**å·®åˆ†æ•°ç»„å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å¯¹æ•°ç»„è¿›è¡ŒåŒºé—´æ›´æ–°ã€‚**

1. å¯¹äºå·®åˆ†æ•°ç»„`0 0 0 0 0`,å¯¹d[1]åŠ ä¸€çš„ç»“æœæ˜¯å¯¹åŸæ•°ç»„åŒºé—´[1,n-1]éƒ½åŠ ä¸Š1
2. ä½¿ç”¨å·®åˆ†æ•°ç»„å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å¯¹åŸæ•°ç»„çš„æŸä¸ªåŒºé—´è¿›è¡Œæ›´æ–°æ“ä½œã€‚
3. å·®åˆ†æ•°ç»„çš„å‰ç¼€å’Œæ˜¯åŸæ•°ç»„
4. å‰ç¼€å’Œæ•°ç»„åšä¸€æ¬¡å·®åˆ†ä¹Ÿä¼šè¿”å›åˆ°åŸæ•°ç»„
5. å·®åˆ†æ•°ç»„é€‚ç”¨äºå¤šæ¬¡æ›´æ–°ï¼Œå•æ¬¡æŸ¥è¯¢çš„åœºæ™¯
6. å¯¹åŒºé—´[l,r]éƒ½åŠ ä¸Švalueï¼Œåªéœ€è¦å°†å·®åˆ†æ•°ç»„ï¼š`d[l]+value,d[r+1]-value`,åœ¨åšå‰ç¼€å’Œå³å¯å¾—åˆ°ç»“æœ



å®šä¹‰å·®åˆ†æ•°ç»„`d[i]=arr[i]-arr[i-1]`

å…¶ä¸­`d[0]=arr[0]`

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> constructDifferenceArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    return diff;
}

void updateDifferenceArray(vector<int>& diff, int l, int r, int x) {
    diff[l] += x;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= x;
    }
}

vector<int> restoreArrayFromDifferenceArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    return arr;
}

int main() {
    vector<int> arr = {2, 4, 6, 8, 10};
    vector<int> diff = constructDifferenceArray(arr);

    // Perform update operation: add 3 to the range [1, 3]
    updateDifferenceArray(diff, 1, 3, 3);

    // Restore the updated array
    vector<int> updatedArr = restoreArrayFromDifferenceArray(diff);

    for (int val : updatedArr) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}

```





## äºŒç»´å·®åˆ†

https://www.bilibili.com/video/BV1pi4y1j7si/?p=4&spm_id_from=pageDriver&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

`b[i][j]=a[i][j]âˆ’a[iâˆ’1][j]âˆ’a[i][jâˆ’1]+a[iâˆ’1][jâˆ’1]`



1. å¯¹äºäºŒç»´å·®åˆ†æ•°ç»„`b[i][j]`,å¦‚æœ`b[i][j]+1`,ä¼šå½±å“åˆ°åç»­çš„ä¸€æ•´å—åŒºåŸŸ



```c++
#include <iostream>
#include <vector>
using namespace std;

// æ„é€ å·®åˆ†æ•°ç»„
void constructDifferenceArray(const vector<vector<int>>& a, vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();

    differenceArray[0][0] = a[0][0];
    for (int i = 1; i < m; i++) differenceArray[i][0] = a[i][0] - a[i - 1][0];
    for (int j = 1; j < n; j++) differenceArray[0][j] = a[0][j] - a[0][j - 1];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            differenceArray[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
        }
    }
}

// æ›´æ–°å·®åˆ†æ•°ç»„
void updateDifferenceArray(vector<vector<int>>& differenceArray, int x1, int y1, int x2, int y2, int value) {
    differenceArray[x1][y1] += value;
    int m = differenceArray.size();
    int n = differenceArray[0].size();

    if (x2 + 1 < m) {
        differenceArray[x2 + 1][y1] -= value;
    }
    if (y2 + 1 < n) {
        differenceArray[x1][y2 + 1] -= value;
    }
    if (x2 + 1 < m && y2 + 1 < n) {
        differenceArray[x2 + 1][y2 + 1] += value;
    }
}

// ä»å·®åˆ†æ•°ç»„æ¢å¤åŸå§‹æ•°ç»„
void restoreArrayFromDifferenceArray(vector<vector<int>>& a, const vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();
    a[0][0] = differenceArray[0][0];

    for (int j = 1; j < n; j++) {
        a[0][j] = a[0][j - 1] + differenceArray[0][j];
    }
    for (int i = 1; i < m; i++) {
        a[i][0] = a[i - 1][0] + differenceArray[i][0];
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + differenceArray[i][j];
        }
    }
}

int main() {
    vector<vector<int>> a = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int m = a.size();
    int n = a[0].size();
    vector<vector<int>> differenceArray(m, vector<int>(n, 0));

    // æ„é€ åˆå§‹å·®åˆ†æ•°ç»„
    constructDifferenceArray(a, differenceArray);

    // æ›´æ–°å·®åˆ†æ•°ç»„
    updateDifferenceArray(differenceArray, 0, 0, 1, 1, 10);

    // æ¢å¤æ›´æ–°åçš„åŸæ•°ç»„
    restoreArrayFromDifferenceArray(a, differenceArray);

    // æ‰“å°æ›´æ–°åçš„åŸæ•°ç»„
    cout << "Updated Original Array:" << endl;
    for (const auto& row : a) {
        for (const auto& elem : row) {
            cout << elem << " ";
        }
        cout << endl;
    }

    return 0;
}

```



## çº¿æ®µæ ‘

**å®šä¹‰**

çº¿æ®µæ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œé€šå¸¸ç”¨æ¥å­˜å‚¨æ•°ç»„åŒºé—´çš„ä¿¡æ¯ã€‚æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªåŒºé—´ï¼ŒèŠ‚ç‚¹çš„å€¼é€šå¸¸è¡¨ç¤ºè¯¥åŒºé—´çš„ä¸€äº›å±æ€§ï¼ˆå¦‚åŒºé—´å’Œã€åŒºé—´æœ€å°å€¼ç­‰ï¼‰ã€‚çº¿æ®µæ ‘çš„æ ¹èŠ‚ç‚¹è¡¨ç¤ºæ•´ä¸ªæ•°ç»„çš„åŒºé—´ï¼Œæ ¹èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹åˆ†åˆ«è¡¨ç¤ºæ•°ç»„çš„å·¦åŠéƒ¨åˆ†å’Œå³åŠéƒ¨åˆ†ï¼Œä¾æ­¤ç±»æ¨ã€‚

çº¿æ®µæ ‘ç®—æ³•ä¸­å¸¸ç”¨åˆ°ï¼š

1. nodeindexï¼šè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ä¸‹æ ‡
2. startè¡¨ç¤ºdataæ•°ç»„åŒºé—´å·¦ç«¯ç‚¹ä¸‹æ ‡
3. endè¡¨ç¤ºdataæ•°ç»„åŒºé—´å³ç«¯ç‚¹ä¸‹æ ‡
4. leftindexè¡¨ç¤ºå½“å‰è®¿é—®ç«¯ç‚¹å·¦å­©å­ä¸‹æ ‡
5. rightindexè¡¨ç¤ºå½“å‰è®¿é—®ç«¯ç‚¹å³å­©å­ä¸‹æ ‡ 



â€‹      

**ç”¨é€”**

1. **åŒºé—´æŸ¥è¯¢**ï¼šä¾‹å¦‚ï¼ŒæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å°å€¼ã€æœ€å¤§å€¼ã€å’Œã€ä¹˜ç§¯ç­‰ã€‚è¯·æ³¨æ„ï¼ŒåŒºé—´æŸ¥è¯¢ä¸‹æ ‡æ˜¯æ•°ç»„ä¸‹æ ‡ï¼ï¼
2. **åŒºé—´æ›´æ–°**ï¼šä¾‹å¦‚ï¼Œå°†æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æ¯ä¸ªå…ƒç´ éƒ½å¢åŠ ä¸€ä¸ªå›ºå®šå€¼ï¼Œæˆ–å°†æŸä¸ªåŒºé—´å†…çš„å€¼å…¨éƒ¨è®¾ä¸ºæŸä¸ªå€¼ã€‚
3. **åŠ¨æ€æ•°æ®å¤„ç†**ï¼šçº¿æ®µæ ‘æ”¯æŒåœ¨æ•°æ®æ›´æ–°çš„åŒæ—¶ï¼Œä¿æŒå¿«é€Ÿçš„æŸ¥è¯¢æ€§èƒ½ï¼Œé€‚åˆåŠ¨æ€æ•°æ®å¤„ç†åœºæ™¯ã€‚

 		

**æ—¶é—´å¤æ‚åº¦**

- çº¿æ®µæ ‘çš„æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(logâ¡ğ‘›)ã€‚
- çº¿æ®µæ ‘çš„æ„å»ºæ—¶é—´å¤æ‚åº¦ä¸º ğ‘‚(ğ‘›)ã€‚





**æ‡’æƒ°æ ‡è®°çº¿æ®µæ ‘**

æ‡’æƒ°æ ‡è®°ï¼ˆLazy Propagationï¼‰æ˜¯ä¸€ç§ä¼˜åŒ–æŠ€æœ¯ï¼Œç”¨äºæé«˜çº¿æ®µæ ‘å¤„ç†åŒºé—´æ›´æ–°æ“ä½œçš„æ•ˆç‡ã€‚å®ƒé€šè¿‡æ¨è¿Ÿæ›´æ–°æ“ä½œç›´åˆ°çœŸæ­£éœ€è¦æ—¶æ‰è¿›è¡Œï¼Œä»è€Œé¿å…åœ¨æ¯æ¬¡æ›´æ–°æ—¶å¯¹æ•´ä¸ªåŒºé—´è¿›è¡Œé‡å¤æ“ä½œã€‚è¿™æ ·å¯ä»¥æ˜¾è‘—å‡å°‘æ›´æ–°æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ã€‚

åœ¨æ ‡å‡†çº¿æ®µæ ‘ä¸­ï¼Œæ¯æ¬¡æ›´æ–°æ“ä½œéƒ½ä¼šå½±å“åˆ°ç›¸å…³åŒºé—´çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¯¼è‡´æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ã€‚æ‡’æƒ°æ ‡è®°é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¼˜åŒ–ï¼š

1. **å»¶è¿Ÿæ›´æ–°**ï¼šå°†æ›´æ–°æ“ä½œè®°å½•åœ¨æ‡’æƒ°æ ‡è®°æ•°ç»„ä¸­ï¼Œè€Œä¸ç«‹å³æ›´æ–°æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹ã€‚
2. **ä¼ æ’­æ›´æ–°**ï¼šåœ¨æŸ¥è¯¢æˆ–è¿›ä¸€æ­¥æ›´æ–°æ“ä½œæ—¶ï¼Œå†å°†ä¹‹å‰è®°å½•çš„æ›´æ–°æ“ä½œåº”ç”¨åˆ°ç›¸å…³èŠ‚ç‚¹ä¸Šã€‚



**æ‡’æƒ°æ ‡è®°æœºåˆ¶çš„å®ç°ä¸­ï¼Œåœ¨è¿›è¡Œçº¿æ®µæ ‘çš„æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œä¹‹å‰ï¼Œé€šå¸¸ä¼šå…ˆæ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦æœ‰æ‡’æƒ°æ ‡è®°ã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿åœ¨éœ€è¦è¿›è¡ŒæŸ¥è¯¢æˆ–æ›´æ–°æ“ä½œæ—¶ï¼Œé¦–å…ˆå°†å»¶è¿Ÿæ›´æ–°åº”ç”¨åˆ°å½“å‰èŠ‚ç‚¹ä¸Šï¼Œç„¶åå†è¿›è¡Œç›¸åº”çš„æ“ä½œï¼Œä»è€Œä¿è¯æ•°æ®çš„å‡†ç¡®æ€§å’Œä¸€è‡´æ€§ã€‚**



### æ±‚å’Œçº¿æ®µæ ‘

```c++
#include<iostream>
#include<vector>
#include<numeric>
using namespace std;
#include <vector>
using namespace std;

#include <vector>
#include <iostream>
using namespace std;

class SegmentTree {
private:
    vector<int> Tree;
    vector<int> Lazy;
    vector<int> data;
    int n;

    void BuildTree(int node, int start, int end) {
        if (start == end) {
            Tree[node] = data[start];
        }
        else {
            int mid = (start + end) / 2;
            int leftindex = 2 * node;
            int rightindex = 2 * node + 1;
            BuildTree(leftindex, start, mid);
            BuildTree(rightindex, mid + 1, end);
            Tree[node] = Tree[leftindex] + Tree[rightindex];
        }
    }

    void propagate(int node, int start, int end) {

        if (Lazy[node] != 0) {
            
            Tree[node] += (end - start + 1) * Lazy[node];
            if (start != end) {
                Lazy[node * 2] += Lazy[node];
                Lazy[node * 2 + 1] += Lazy[node];
            }
            Lazy[node] = 0;
        }
    }

    void updateRange(int node, int start, int end, int L, int R, int val) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return;
        }

        if (L <= start && end <= R) {
            //å¦‚æœå½“å‰åŒºé—´è¢«åŒ…å«åœ¨æŸ¥è¯¢åŒºé—´ä¸­ï¼Œé‚£ä¹ˆå°±ä¸ç»§ç»­å‘ä¸‹æ›´æ–°ï¼Œè€Œæ˜¯é€‰æ‹©åŸè·¯è¿”å›ï¼Œç”¨æ‡’æƒ°æ ‡è®°æ ‡è®°è¯¥èŠ‚ç‚¹
            //å¹¶ä¸”ç»™å·¦å­©å­å’Œå³å­©å­è®°è´¦ï¼Œç­‰è®¿é—®å·¦å­©å­å³å­©å­çš„æ—¶å€™ï¼Œä¼šå…ˆæŸ¥ä¸€ä¸‹è¯¥èŠ‚ç‚¹æœ‰æ²¡æœ‰çˆ¶èŠ‚ç‚¹ç•™ä¸‹çš„å¸
            //å¦‚æœæœ‰ï¼Œå°±è¦å…ˆæ›´æ–°ï¼Œä¹Ÿå°±æ˜¯æœ¬å‡½æ•°å¼€å¤´çš„propagateå‡½æ•°
            Tree[node] += (end - start + 1) * val;
            if (start != end) {
                Lazy[node * 2] += val;
                Lazy[node * 2 + 1] += val;
            }
            return;
        }

        int mid = (start + end) / 2;
        updateRange(node * 2, start, mid, L, R, val);
        updateRange(node * 2 + 1, mid + 1, end, L, R, val);
        Tree[node] = Tree[node * 2] + Tree[node * 2 + 1];
    }

    int queryRange(int node, int start, int end, int L, int R) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return 0;
        }

        if (L <= start && end <= R) {
            return Tree[node];
        }

        int mid = (start + end) / 2;
        int leftSum = queryRange(node * 2, start, mid, L, R);
        int rightSum = queryRange(node * 2 + 1, mid + 1, end, L, R);
        return leftSum + rightSum;
    }

    


    //å…ˆæ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹ï¼Œæ›´æ–°ï¼ŒååŸè·¯æ›´æ–°è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼
    void updateTree(int node, int start, int end, int idx, int val) {
        if (start == end) {
            data[idx] = val;
            Tree[node] = val;
        }
        else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            if (start <= idx && idx <= mid) {
                updateTree(leftChild, start, mid, idx, val);
            }
            else {
                updateTree(rightChild, mid + 1, end, idx, val);
            }
            Tree[node] = Tree[leftChild] + Tree[rightChild];
        }
    }

public:
    SegmentTree(const vector<int>& data) {
        this->data = data;
        this->n = data.size();
        Tree.resize(4 * n);
        Lazy.resize(4 * n, 0);
        BuildTree(1, 0, n - 1);
    }

    void update(int idx, int val) {
        updateTree(0, 0, n - 1, idx, val);
    }

    void updateRange(int L, int R, int val) {
        updateRange(1, 0, n - 1, L, R, val);
    }

  

    int queryRange(int L, int R) {
        return queryRange(1, 0, n - 1, L, R);
    }
};


int main() {
    std::vector<int> data(100);
    iota(data.begin(), data.end(), 1);
    
    SegmentTree segTree(data);
  
    
    return 0;

}
```



### ä¹˜æ³•(æ ¹å·)çº¿æ®µæ ‘

å½“æˆ‘ä»¬å¯¹åŒºé—´è¿›è¡ŒåŒæ—¶åŠ å’Œä¹˜çš„æ—¶å€™ï¼Œåº”è¯¥æœ‰ä¸¤ä¸ªæ‡’æƒ°æ ‡è®°

ä¹˜æ³•æ ‡è®°ï¼šåˆå§‹å€¼ä¸º1

åŠ æ³•æ ‡è®°ï¼šåˆå§‹å€¼ä¸º0

åœ¨pushdownå‡½æ•°ä¸­ï¼Œé¦–å…ˆè·å¾—è¯¥èŠ‚ç‚¹çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°å’ŒåŠ æ³•æ‡’æƒ°æ ‡è®°

ç„¶åæ›´æ–°å·¦å³å­©å­èŠ‚ç‚¹çš„æ‡’æƒ°æ ‡è®°

å·¦å­©å­çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°ç­‰äºå·¦å­©å­ä¹˜æ³•æ‡’æƒ°æ ‡è®°ä¹˜å½“å‰èŠ‚ç‚¹çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°

å·¦å­©å­çš„åŠ æ³•æ‡’æƒ°æ ‡è®°ç­‰äºå·¦å­©å­åŠ æ³•æ‡’æƒ°æ ‡è®°ä¹˜å½“å‰èŠ‚ç‚¹çš„ä¹˜æ³•æ‡’æƒ°æ ‡è®°å€¼åŠ ä¸Šå½“å‰èŠ‚ç‚¹çš„åŠ æ³•æ‡’æƒ°æ ‡è®°

```c++
#include <vector>
#include <iostream>

using namespace std;

const long long p = 1e9 + 7;

struct SegmentTreeNode {
    long long sum = 0;
    long long mlz = 1; // Multiplicative lazy tag, initially 1
    long long plz = 0; // Additive lazy tag, initially 0
    int l = 0, r = 0;
};

vector<SegmentTreeNode> tree;

// Initialize the segment tree with a given array size
void init(int n) {
    tree.resize(4 * n); // Allocate sufficient space for segment tree
}

// Build the segment tree
void build(vector<int>& arr, int i, int l, int r) {
    tree[i].l = l;
    tree[i].r = r;
    if (l == r) {
        tree[i].sum = arr[l];
        return;
    }
    int mid = (l + r) / 2;
    build(arr, 2 * i, l, mid);
    build(arr, 2 * i + 1, mid + 1, r);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Pushdown function to propagate lazy updates
void pushdown(int i) {
    long long k1 = tree[i].mlz, k2 = tree[i].plz;
    if (tree[i].l != tree[i].r) { // Not a leaf node
        // Update left child
        tree[2 * i].sum = (tree[2 * i].sum * k1 + k2 * (tree[2 * i].r - tree[2 * i].l + 1)) % p;
        tree[2 * i].mlz = (tree[2 * i].mlz * k1) % p;
        tree[2 * i].plz = (tree[2 * i].plz * k1 + k2) % p;

        // Update right child
        tree[2 * i + 1].sum = (tree[2 * i + 1].sum * k1 + k2 * (tree[2 * i + 1].r - tree[2 * i + 1].l + 1)) % p;
        tree[2 * i + 1].mlz = (tree[2 * i + 1].mlz * k1) % p;
        tree[2 * i + 1].plz = (tree[2 * i + 1].plz * k1 + k2) % p;
    }
    tree[i].mlz = 1;
    tree[i].plz = 0;
}

// Update function for range updates (multiplicative and additive)
void update(int i, int l, int r, long long k1, long long k2) {
    if (l <= tree[i].l && tree[i].r <= r) {
        tree[i].sum = (tree[i].sum * k1 + k2 * (tree[i].r - tree[i].l + 1)) % p;
        tree[i].mlz = (tree[i].mlz * k1) % p;
        tree[i].plz = (tree[i].plz * k1 + k2) % p;
        return;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    if (l <= mid) update(2 * i, l, r, k1, k2);
    if (r > mid) update(2 * i + 1, l, r, k1, k2);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Query function to get the sum of a range
long long query(int i, int l, int r) {
    if (l <= tree[i].l && tree[i].r <= r) {
        return tree[i].sum;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    long long res = 0;
    if (l <= mid) res = (res + query(2 * i, l, r)) % p;
    if (r > mid) res = (res + query(2 * i + 1, l, r)) % p;
    return res;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    init(n);
    build(arr, 1, 0, n - 1);

    // Example usage: updating range [1, 3] with k1 = 2 (multiplicative) and k2 = 3 (additive)
    update(1, 1, 3, 2, 3);
    cout << query(1, 1, 3) << endl; // Query the sum of range [1, 3]

    return 0;
}

```



### çº¿æ®µæ ‘çš„åº”ç”¨

1. åŒºé—´æœ€å€¼æŸ¥è¯¢å’Œæ›´æ–°
   åº”ç”¨ï¼šåœ¨ç»™å®šæ•°ç»„ä¸­ï¼ŒæŸ¥è¯¢æŸä¸ªåŒºé—´å†…çš„æœ€å°å€¼æˆ–æœ€å¤§å€¼ï¼Œä»¥åŠåœ¨æ•°ç»„çš„æŸä¸ªä½ç½®æ›´æ–°ä¸€ä¸ªå€¼ã€‚
   ç¤ºä¾‹ï¼šåœ¨ç”µå•†å¹³å°ä¸­ï¼ŒæŸ¥è¯¢æŸä¸€æ—¶é—´æ®µå†…å•†å“çš„æœ€ä½ä»·æ ¼ã€‚
2. åŒºé—´å’ŒæŸ¥è¯¢å’Œæ›´æ–°
   åº”ç”¨ï¼šæ±‚æ•°ç»„æŸä¸ªåŒºé—´å†…çš„å…ƒç´ å’Œï¼Œä»¥åŠåœ¨æŸä¸ªä½ç½®æˆ–åŒºé—´å†…è¿›è¡Œæ›´æ–°æ“ä½œã€‚
   ç¤ºä¾‹ï¼šç»Ÿè®¡æŸæ®µæ—¶é—´å†…ç½‘ç«™çš„æ€»è®¿é—®é‡ï¼Œå¹¶èƒ½å¿«é€Ÿæ›´æ–°æŸå¤©çš„è®¿é—®é‡ã€‚
3. åŒºé—´ä¹˜ç§¯æŸ¥è¯¢å’Œæ›´æ–°
   åº”ç”¨ï¼šæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…å…ƒç´ çš„ä¹˜ç§¯ï¼Œå¹¶æ”¯æŒå•ç‚¹æ›´æ–°ã€‚
   ç¤ºä¾‹ï¼šåœ¨é‡‘èç³»ç»Ÿä¸­ï¼Œè®¡ç®—æŸæ®µæ—¶é—´å†…çš„æŠ•èµ„æ”¶ç›Šï¼Œå¹¶èƒ½å¿«é€Ÿæ›´æ–°æŸå¤©çš„æ”¶ç›Šã€‚
4. åŒºé—´æœ€å¤§å…¬çº¦æ•° (GCD) æŸ¥è¯¢
   åº”ç”¨ï¼šæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å¤§å…¬çº¦æ•°ã€‚
   ç¤ºä¾‹ï¼šåœ¨æ•°å­¦åˆ†æä¸­ï¼Œæ‰¾åˆ°æŸä¸ªåŒºé—´å†…æ‰€æœ‰æ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚
5. åŒºé—´æœ€å°å…¬å€æ•° (LCM) æŸ¥è¯¢
   åº”ç”¨ï¼šæŸ¥è¯¢æ•°ç»„æŸä¸ªåŒºé—´å†…çš„æœ€å°å…¬å€æ•°ã€‚
   ç¤ºä¾‹ï¼šåœ¨æ’ç­ç³»ç»Ÿä¸­ï¼Œæ‰¾åˆ°æŸæ®µæ—¶é—´å†…å¤šä¸ªå‘¨æœŸä»»åŠ¡çš„å…±åŒå‘¨æœŸã€‚
6. åŒºé—´ä¼—æ•°æŸ¥è¯¢
   åº”ç”¨ï¼šåœ¨æ•°ç»„çš„æŸä¸ªåŒºé—´å†…ï¼ŒæŸ¥æ‰¾å‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ ã€‚
   ç¤ºä¾‹ï¼šç»Ÿè®¡æŸæ®µæ—¶é—´å†…æœ€çƒ­é—¨çš„å•†å“ã€‚
7. åŒºé—´é€†åºå¯¹æŸ¥è¯¢
   åº”ç”¨ï¼šè®¡ç®—æ•°ç»„æŸä¸ªåŒºé—´å†…çš„é€†åºå¯¹æ•°é‡ã€‚
   ç¤ºä¾‹ï¼šåœ¨æ’åºç®—æ³•çš„ä¼˜åŒ–ä¸­ï¼Œç»Ÿè®¡é€†åºå¯¹çš„æ•°é‡ä»¥å†³å®šæ˜¯å¦ä½¿ç”¨å½’å¹¶æ’åºã€‚
8. åŒºé—´æœ€å°å€¼å·®æŸ¥è¯¢
   åº”ç”¨ï¼šæŸ¥è¯¢æŸä¸ªåŒºé—´å†…æœ€å°å€¼å’Œæ¬¡å°å€¼ä¹‹é—´çš„å·®å€¼ã€‚
   ç¤ºä¾‹ï¼šåœ¨æ¯”èµ›æˆç»©åˆ†æä¸­ï¼Œæ‰¾åˆ°æŸæ®µæ—¶é—´å†…æˆç»©æœ€æ¥è¿‘çš„ä¸¤åé€‰æ‰‹ã€‚
9. åŠ¨æ€æ±‚è§£ç›´æ–¹å›¾ä¸­çš„æœ€å¤§çŸ©å½¢é¢ç§¯
   åº”ç”¨ï¼šæ±‚è§£åŠ¨æ€å˜åŒ–çš„ç›´æ–¹å›¾ä¸­çš„æœ€å¤§çŸ©å½¢é¢ç§¯é—®é¢˜ã€‚
   ç¤ºä¾‹ï¼šåœ¨å›¾åƒå¤„ç†å’Œåˆ†æä¸­ï¼Œæ‰¾å‡ºå›¾åƒä¸­æœ€å¤§è¿é€šå—çš„é¢ç§¯ã€‚
10. å­—ç¬¦ä¸²é—®é¢˜
    åº”ç”¨ï¼šå¤„ç†å­—ç¬¦ä¸²çš„ä¸€äº›æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œï¼Œå¦‚åŒºé—´å­—ç¬¦ç»Ÿè®¡ã€åŒºé—´å›æ–‡åˆ¤æ–­ç­‰ã€‚
    ç¤ºä¾‹ï¼šåœ¨æ–‡æœ¬ç¼–è¾‘å™¨ä¸­ï¼Œç»Ÿè®¡æŸæ®µæ–‡å­—ä¸­çš„ç‰¹å®šå­—ç¬¦å‡ºç°æ¬¡æ•°ã€‚
11. åŒºé—´è¦†ç›–é—®é¢˜
    åº”ç”¨ï¼šè§£å†³åŒºé—´è¦†ç›–é—®é¢˜ï¼Œå¦‚åŒºé—´æ¶‚è‰²ã€åŒºé—´è¦†ç›–ç­‰ã€‚
    ç¤ºä¾‹ï¼šåœ¨åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ä¸­ï¼ŒæŸ¥è¯¢æŸå—åŒºåŸŸå†…çš„è¦†ç›–æƒ…å†µã€‚
12. æ•°æ®å‹ç¼©
    åº”ç”¨ï¼šåˆ©ç”¨çº¿æ®µæ ‘è¿›è¡Œæ•°æ®å‹ç¼©å’Œç¨€ç–çŸ©é˜µçš„å­˜å‚¨ã€‚
    ç¤ºä¾‹ï¼šåœ¨æ•°æ®å‹ç¼©ç®—æ³•ä¸­ï¼Œç”¨çº¿æ®µæ ‘è®°å½•ç¨€ç–çŸ©é˜µçš„éé›¶å…ƒç´ ã€‚
13. åŠ¨æ€æ’åˆ—ç»Ÿè®¡
    åº”ç”¨ï¼šç»Ÿè®¡åŠ¨æ€æ’åˆ—ä¸­çš„é€†åºå¯¹ã€æ’åˆ—çš„é¡ºåºç»Ÿè®¡ç­‰ã€‚
    ç¤ºä¾‹ï¼šåœ¨å®æ—¶æ’åºç³»ç»Ÿä¸­ï¼Œç»Ÿè®¡åŠ¨æ€æ’åºç»“æœçš„é€†åºå¯¹æ•°é‡ã€‚
14. å¤šç»´çº¿æ®µæ ‘
    åº”ç”¨ï¼šè§£å†³å¤šç»´æ•°æ®çš„åŒºé—´æŸ¥è¯¢å’Œæ›´æ–°é—®é¢˜ï¼Œå¦‚äºŒç»´çº¿æ®µæ ‘ã€‚
    ç¤ºä¾‹ï¼šåœ¨å›¾åƒå¤„ç†å’Œåˆ†æä¸­ï¼Œè¿›è¡ŒäºŒç»´åŒºåŸŸçš„å¿«é€Ÿç»Ÿè®¡å’Œæ›´æ–°ã€‚

# è´ªå¿ƒ

### [ä»é›¶å¼€å§‹å­¦è´ªå¿ƒç®—æ³•-CSDNåšå®¢](https://blog.csdn.net/qq_32400847/article/details/51336300?ops_request_misc=%7B%22request%5Fid%22%3A%22170970936516800226558001%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170970936516800226558001&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51336300-null-null.142^v99^pc_search_result_base1&utm_term=è´ªå¿ƒç®—æ³•&spm=1018.2226.3001.4187)



è´ªå¿ƒç®—æ³•æ˜¯ç‰¹æ®Šçš„åŠ¨æ€è§„åˆ’ï¼Ÿï¼Ÿï¼Ÿ

è´ªå¿ƒç®—æ³•æ±‚ç¡¬å¸ï¼Œåªè¦ç¡¬å¸ä¹‹é—´æ˜¯æ•´é™¤å…³ç³»

### æœ€å¤§å…¼å®¹åŒºé—´ä¸ªæ•°

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
class Action {
public:
	int start;
	int end;
	Action(int s, int e) :start(s), end(e) {}
	bool operator<(const Action& o) const {
		return end <= o.end;
	}
};

void greedy(vector<Action>&Arr) {
	int n = Arr.size();
	vector<bool>flag(n, false);
	sort(Arr.begin(), Arr.end());
	int preend = Arr[0].end;
	flag[0] = true;
	int ans = 1;
	for (int i = 1; i < n; i++) {
		if (Arr[i].start >= preend) {
			flag[i] = true;
			ans++;
			preend = Arr[i].end;
		}
	}

	cout << "æ±‚è§£ç»“æœ: " << endl;
	cout << "é€‰å–çš„æ´»åŠ¨: ";
	for (int i = 0; i < n; i++) {
		if (flag[i] == true) {
			cout << "æ´»åŠ¨" << i << " å¼€å§‹æ—¶é—´:" << Arr[i].start << " ç»“æŸæ—¶é—´:" << Arr[i].end << endl;
		}
	}

	cout << "å…±" << ans << "ä¸ªæ´»åŠ¨";
}
int main() {

}
```



### ç»™å®šæ­£æ•´æ•°Nï¼Œæ±‚Nä¸ªNç›¸ä¹˜çš„ä¸ªä½æ•°

```c++
#include<iostream>
#include<vector>
using namespace std;

int func(int x) {
   vector<int> a(10);
   a[0] = 0;
   a[1] = 1;
   a[2] = 4;
   a[3] = 7;
   a[4] = 6;
   a[5] = 5;
   a[6] = 6;
   a[7] = 3;
   a[8] = 6;
   a[9] = 9;
   return a[x];
}

int main() {
    // å–è¾“å…¥çš„æ•°
    int n;
    cin >> n;
    
    // è®¡ç®—ä¸ªä½æ•°
    int ge = n % 10;
    
    // è°ƒç”¨å‡½æ•°å¹¶è¾“å‡ºç»“æœ
    cout << func(ge); 
    
    return 0;
}

```

### ç‰¹æ®Šçš„æ–æ³¢é‚£å¥‘

**æœ‰ä¸€ç§fibonacciæ•°åˆ—ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š**

**f(0)=7,f(1)=11,f(n)=f(n-1)+f(n-2),ç»™å®šä¸€ä¸ªn(n<1000000),è¯·åˆ¤æ–­f(n)èƒ½å¦è¢«3æ•´é™¤**

(a+b)%3=(a%3+b%3)%3

f(0) = 7 % 3 = 1 

f(1) = 11 % 3 = 2 

f(2) = f(1) + f(0) = 2 + 1 = 3 % 3 = 0

f(3) = f(2) + f(1) = 0 + 2 = 2 

f(4) = f(3) + f(2) = 2 + 0 = 2 

f(5) = f(4) + f(3) = 2 + 2 = 4 % 3 = 1 

f(6) = f(5) + f(4) = 1 + 2 = 3 % 3 = 0 

f(7) = f(6) + f(5) = 0 + 1 = 1

å‘¨æœŸä¸º8.

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
using namespace std;
bool func(int m) {
    if (m == 2 || m == 6) {
        return true;
   }
    return false;
    
}

int main() {
    //æ€è·¯ï¼šä¸ªä½æ•°åªå’Œä¸ªä½æ•°ç›¸å…³
    int n;
    cin >> n;
    int m = n % 8;
   
    cout << func(m); 
    return 0;
}

```



### æ±‚A^Bçš„æœ€åä¸‰ä½è¡¨ç¤ºçš„æ•´æ•°

```c++
#include <iostream>
using namespace std;

long long fastPowerIterative(long long base, long long exponent) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1)
            result *= base;
        base *= base;
        exponent /= 2;
    }
    return result;
}

int main() {
    long long base, exponent;
    cout << "è¯·è¾“å…¥åº•æ•°å’ŒæŒ‡æ•°: ";
    cin >> base >> exponent;
    long long res = fastPowerIterative(base, exponent);
    cout << res % 1000;
    return 0;
}

```

### åŠ›æ‰£1217ç©ç­¹ç 

æœäº†ç‹—å±é¢˜ç›®è¿™ä¹ˆç®€å•æˆ‘ä¸ä¼š

### åŠ›æ‰£402ç§»æ‰kä½æ•°å­—

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240306184035499.png" alt="image-20240306184035499" style="zoom: 67%;" />



è€ƒè™‘ä»å·¦å¾€å³å¢é‡çš„æ„é€ æœ€åçš„ç­”æ¡ˆã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ ˆç»´æŠ¤å½“å‰çš„ç­”æ¡ˆåºåˆ—ï¼Œæ ˆä¸­çš„å…ƒç´ ä»£è¡¨æˆªæ­¢åˆ°å½“å‰ä½ç½®ï¼Œåˆ é™¤ä¸è¶…è¿‡ k æ¬¡ä¸ªæ•°å­—åï¼Œæ‰€èƒ½å¾—åˆ°çš„æœ€å°æ•´æ•°ã€‚æ ¹æ®ä¹‹å‰çš„è®¨è®ºï¼šåœ¨ä½¿ç”¨ kä¸ªåˆ é™¤æ¬¡æ•°ä¹‹å‰ï¼Œæ ˆä¸­çš„åºåˆ—ä»æ ˆåº•åˆ°æ ˆé¡¶å•è°ƒä¸é™ã€‚

å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªæ•°å­—ï¼Œå¦‚æœè¯¥æ•°å­—å°äºæ ˆé¡¶å…ƒç´ ï¼Œæˆ‘ä»¬å°±ä¸æ–­åœ°å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œç›´åˆ°

1. æ ˆä¸ºç©º

2. æˆ–è€…æ–°çš„æ ˆé¡¶å…ƒç´ ä¸å¤§äºå½“å‰æ•°å­—
3. æˆ–è€…æˆ‘ä»¬å·²ç»åˆ é™¤äº† kkk ä½æ•°å­—

ä¸Šè¿°æ­¥éª¤ç»“æŸåæˆ‘ä»¬è¿˜éœ€è¦é’ˆå¯¹ä¸€äº›æƒ…å†µåšé¢å¤–çš„å¤„ç†ï¼š

å¦‚æœæˆ‘ä»¬åˆ é™¤äº† m ä¸ªæ•°å­—ä¸” m<km<km<kï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦ä»åºåˆ—å°¾éƒ¨åˆ é™¤é¢å¤–çš„ kâˆ’mk-mkâˆ’m ä¸ªæ•°å­—ã€‚

1. å¦‚æœæœ€ç»ˆçš„æ•°å­—åºåˆ—å­˜åœ¨å‰å¯¼é›¶ï¼Œæˆ‘ä»¬è¦åˆ å»å‰å¯¼é›¶ã€‚
2. å¦‚æœæœ€ç»ˆæ•°å­—åºåˆ—ä¸ºç©ºï¼Œæˆ‘ä»¬åº”è¯¥è¿”å› 0ã€‚
3. æœ€ç»ˆï¼Œä»æ ˆåº•åˆ°æ ˆé¡¶çš„ç­”æ¡ˆåºåˆ—å³ä¸ºæœ€å°æ•°ã€‚

è€ƒè™‘åˆ°æ ˆçš„ç‰¹ç‚¹æ˜¯åè¿›å…ˆå‡ºï¼Œå¦‚æœé€šè¿‡æ ˆå®ç°ï¼Œåˆ™éœ€è¦å°†æ ˆå†…å…ƒç´ ä¾æ¬¡å¼¹å‡ºç„¶åè¿›è¡Œç¿»è½¬æ‰èƒ½å¾—åˆ°æœ€å°æ•°ã€‚ä¸ºäº†é¿å…ç¿»è½¬æ“ä½œï¼Œå¯ä»¥ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ä»£æ›¿æ ˆçš„å®ç°ã€‚

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<char> stk;
        for (auto& digit: num) {
            while (stk.size() > 0 && stk.back() > digit && k) {
                stk.pop_back();
                k -= 1;
            }
            stk.push_back(digit);
        }

        for (; k > 0; --k) {
            stk.pop_back();
        }

        string ans = "";
        bool isLeadingZero = true;
        for (auto& digit: stk) {
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};


```

### åŠ›æ‰£605ç§èŠ±é—®é¢˜

1.å¯¹äºä¸¤æœµå·²ç»ç§èŠ±ä¸”ä¸­é—´æ²¡æœ‰ç§èŠ±çš„åˆ‡ç‰‡:å®ƒä»¬ä¹‹é—´å¯ä»¥ç§èŠ±çš„èŒƒå›´æ˜¯[i+2,j-2],æ­¤æ—¶å¯ä»¥ç§èŠ±çš„æ ¼å­æ•°æ˜¯j-i-3ã€‚å‡è®¾æœ‰kä¸ªç©ºæ ¼ç§èŠ±ï¼Œå¯ä»¥ç§èŠ±çš„ä¸ªæ•°æ˜¯ï¼ˆk+1ï¼‰/2,æ‰€ä»¥åœ¨i,jä¹‹é—´å¯ä»¥ç§çš„èŠ±æ˜¯ï¼ˆj-i-2ï¼‰/2ã€‚

2.åœ¨ç¬¬ä¸€ä¸ªç§èŠ±ä¹‹å‰çš„åˆ‡ç‰‡ï¼šç¬¬ä¸€æœµä¸‹æ ‡i,åˆ™å¯ä»¥ç§i/2æœµèŠ±

3.åœ¨æœ€åä¸€æœµèŠ±åˆ°æœ«å°¾ï¼ŒåŒä¸Šï¼Œä»¤æœ€åä¸€æœµèŠ±çš„ä½ç½®æ˜¯r,èŠ±å›æ€»é•¿m,åˆ™å¯ä»¥ç§ï¼ˆm-r-1ï¼‰/2æœµèŠ±

åŸºäºä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥éå†èŠ±å›æ•°ç»„ï¼Œå¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œæˆ‘ä»¬è®¾ç½®å¼€å¤´æ˜¯-1

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count=0;//è®¡æ•°
        int prev=-1;//è¡¨ç¤ºå¼€å¤´
        int m=flowerbed.size();
        for(int i=0;i<m;i++){
            if(flowerbed[i]==1){
                if(prev<0){
                    count+=i/2;     
                }
                else{
                    count+=(i-prev-2)/2;
                }
                prev=i;
            }
        }
        if(prev<0){
            //ä¸€æœµèŠ±ä¹Ÿæ²¡ç§
            count+=(m+1)/2;
        }
        else{
            count+=(m-prev-1)/2;
        }

        return count>=n;
    }
       

};


```

### åŠ›æ‰£608éªŒè¯å›æ–‡ä¸²

æˆ‘ä»¬å‘ç°ï¼šæœ€å¤–å±‚çš„ä¸¤ä¸ªå­—æ¯å¦‚æœä¸åŒï¼Œä¸€å®šä¸æ˜¯å›æ–‡ä¸²ï¼ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å¯ä»¥ç»§ç»­éå†å†…å±‚çš„å­—ä¸²ï¼Œè¿™å°±æ˜¯è´ªå¿ƒçš„æ€æƒ³ã€‚

å½“æˆ‘ä»¬å‘ç°æœ‰ä¸¤ä¸ªå­—æ¯ä¸åŒçš„æ—¶å€™ï¼Œ**å¿…é¡»åˆ é™¤ä¸€ä¸ªå­—æ¯**ï¼Œåˆ é™¤ä¹‹åï¼Œå…¶ä»–åºåˆ—æ˜¯å›æ–‡ä¸²ï¼Œå› ä¸ºæœ€å¤–å±‚å·²ç»æ˜¯å›æ–‡ä¸ç”¨è€ƒè™‘ï¼Œæ‰€ä»¥åªè¦åˆ¤æ–­å³è¾¹å’Œå·¦è¾¹æ˜¯å¦æœ‰ä¸€ä¸ªæ˜¯å›æ–‡ä¸²å°±å¥½ã€‚

```
class Solution {
public:
    bool ishuiwen(const string&s,int low,int high){
        for(int i=low,j=high;i<j;++i,--j){
            if(s[i]!=s[j]){
                return false;
            }
        }
        return true;
    }
    bool validPalindrome(string s) {
        //å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯éƒ½æ˜¯å›æ–‡ä¸²ï¼Œå¯ä»¥å…ˆåˆ¤æ–­ä¸¤ç«¯æ˜¯å¦æ˜¯å­—ç¬¦ä¸²ï¼Œå¦‚æœæœ€å¤–éƒ¨éƒ½ä¸æ˜¯ï¼Œåˆ™ä¸€å®šä¸æ˜¯
        int low=0,high=s.size()-1;
        while(low<high){
            char c1=s[low],c2=s[high];
            if(c1==c2){
                low++;
                high--;
            }
            else{
                return ishuiwen(s,low+1,high)||ishuiwen(s,low,high-1);
            }
        }      
        return true;
    }
};
```

### æ±‚æ€»å’Œ

é¢˜ç›®é“¾æ¥ï¼šhttps://atcoder.jp/contests/abc362/tasks/abc362_c

æ±‚æ•°å¯¹çš„æœ€å°å’Œmin_account     æœ€å¤§å’Œmax_account

åˆ¤æ–­æ˜¯å¦æˆç«‹çš„æ¡ä»¶æ˜¯ï¼šå¦‚æœæœ€å°å’Œå¤§äºé›¶ï¼Œé‚£ä¹ˆæ€ä¹ˆæ·»åŠ éƒ½ä¸ä¼šç­‰äºé›¶ï¼Œå¦‚æœæœ€å¤§å’Œå°äºé›¶ï¼Œé‚£ä¹ˆæ€ä¹ˆå‡å°‘éƒ½ä¸ä¼šç­‰äºé›¶



åˆå§‹åŒ–ç»“æœåºåˆ—ï¼šå‡è®¾æ¯ä¸ªæ•°å¯¹çš„æœ€å°å€¼å°±æ˜¯è¦æ±‚çš„å€¼ï¼Œç°åœ¨æˆ‘çš„ç»“æœåºåˆ—æ˜¯æ¯ä¸ªæ•°å¯¹çš„æœ€å°å€¼



æˆ‘ä»¬éœ€è¦åœ¨åŸå…ˆæ•°å¯¹çš„åŸºç¡€ä¸ŠæŠŠå€¼å¢åŠ ,æˆ‘ä»¬éœ€è¦å¢åŠ çš„æœ€å¤§å€¼å½“ç„¶æ˜¯min_accontçš„ç›¸åæ•°ï¼Œä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶é™åˆ¶ï¼Œæ¯æ¬¡å¢åŠ çš„å€¼ä¸èƒ½è¶…è¿‡Ri-Li,è¿™æ˜¯é¢˜ç›®é™åˆ¶çš„ï¼Œå¦‚æœåœ¨éå†è¿‡ç¨‹ä¸­éœ€è¦å¢åŠ çš„å€¼å˜æˆ0äº†ï¼Œç›´æ¥è¾“å‡ºå³å¯

```c++
#include<iostream>
#include<vector>
using namespace std;
//è´ªå¿ƒæ˜¯ä»€ä¹ˆä¸œè¥¿
int main() {
	int n;
	cin >> n;
	int min_account=0, max_account=0;
	vector<vector<int>>arr(n,vector<int>(2,0));
	vector<int>result(n, 0);
	for (int i = 0; i < n; i++) {
		cin >> arr[i][0] >> arr[i][1];
		min_account += arr[i][0];
		max_account += arr[i][1];
		result[i] = arr[i][0];
	}

	if (max_account < 0 || min_account>0) cout << "No";
	else {
		cout << "Yes"<<endl;
		int current_account = 0 - min_account;
		for (int i = 0; i < n; i++) {
			if (current_account == 0) break;//å°å°å‰ªæ
			int temp = min(current_account, arr[i][1] - arr[i][0]);
			result[i] += temp;
			current_account -= temp;
		}

		for (int i = 0; i < n; i++) {
			cout << result[i] << ' ';
		}

	}
}
```

### åŠ›æ‰£100361åˆ‡è›‹ç³•çš„æœ€å°å¼€é”€

é‡‡ç”¨è´ªå¿ƒçš„æ€æƒ³ï¼Œå› ä¸ºåé¢æˆ‘ä»¬éœ€è¦è¿›è¡Œçš„åˆ‡å‰²åŠ¨ä½œè¶Šæ¥è¶Šå¤šï¼Œæ‰€ä»¥åé¢åˆ‡å‰²çš„æƒå€¼è¦å°½å¯èƒ½å°ï¼Œæˆ‘ä»¬æ¯æ¬¡é€‰å–æƒå€¼æœ€å¤§çš„åˆ†å‰²çº¿ã€‚

å¦‚ä½•ç”¨ä»£ç è¡¨ç¤ºåˆ‡è›‹ç³•è¿™ä¸ªåŠ¨ä½œæ˜¯æœ¬é¢˜çš„éš¾ç‚¹ï¼Œç”»å›¾å¯çŸ¥ï¼Œæˆ‘ä»¬æ°´å¹³åˆ‡ä¸€åˆ€ï¼Œåˆ™å‚ç›´æ–¹å‘ä¸Šå°±è¦å¤šåˆ‡ä¸€ä¸‹ï¼Œè¿™ä¸ªæ˜¯å®è·µå¾—æ¥çš„

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minCostToCutCake(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
    vector<pair<int, bool>>cost;
    for (int i = 0; i < m-1; i++) {
        cost.push_back({ horizontalCut[i],true });
    }

    for (int i = 0; i < n-1; i++) {
        cost.push_back({ verticalCut[i],false });
    }

    sort(cost.rbegin(), cost.rend());

    int hor = 1, ver = 1;
    int min_cost = 0;

    for (auto i : cost) {
        int temp = i.first;
        if (i.second) {
            min_cost += temp * ver;
            hor++;
        }

        else {
            min_cost += temp * hor;
            ver++;
        }
    }

    return min_cost;
    
    
}

int main() {
    int m = 6, n = 3;
    vector<int> horizontalCut = { 2,3,2,3,1 };
    vector<int> verticalCut = { 1,2 };

    int result = minCostToCutCake(m, n, horizontalCut, verticalCut);
    cout << "æœ€å°æ€»å¼€é”€æ˜¯: " << result << endl;

    return 0;
}

```

### åŠ›æ‰£54èºæ—‹çŸ©é˜µ

æˆ‘æœ€è®¨åŒçš„é¢˜ç›®ï¼šæ¨¡æ‹Ÿé¢˜å•Šå•Šå•Šå•Š

å…·ä½“è¯·çœ‹é¢˜è§£ç¬¬ä¸€ä¸ªï¼Œè®¾ç½®å·¦ä¸Šå³ä¸‹å››ä¸ªè¾¹è·ï¼Œæ¯æ¬¡éå†ç»“æŸä¹‹åå°±åˆ é™¤è¾¹è·å³å¯

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int up = 0;
        int down = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        vector<int>res;
        while (up <= down && left <= right) {

            for (int i = left; i <= right; i++) res.push_back(matrix[up][i]);
            up++;
            if (up > down || left > right) break;
            for (int i = up; i <= down; i++) res.push_back(matrix[i][right]);
            right--;
            if (up > down || left > right) break;
            for (int i = right; i >= left; i--) res.push_back(matrix[down][i]);
            down--;
            if (up > down || left > right) break;
            for (int i = down; i >= up; i--) res.push_back(matrix[i][left]);
            left++;
            if (up > down || left > right) break;
        }

        return res;
    }
};
```



# å›æº¯ç®—æ³•

### æ±‚å¹‚é›†

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> x;							//è§£å‘é‡ 
void disp(vector<int> &a) {	//è¾“å‡ºä¸€ä¸ªè§£
	printf("  {");
	for (int i=0;i<x.size();i++)
		if (x[i]==1)
			printf("%d ",a[i]);
	printf("}");
}
void dfs(vector<int> &a,int i) {	//å›æº¯ç®—æ³•
	if (i>=a.size())
		disp(a);
	else {
		x[i]=1;
		dfs(a,i+1);				//é€‰æ‹©a[i]
		x[i]=0;
		dfs(a,i+1);				//ä¸é€‰æ‹©a[i]
	}
}
void pset1(vector<int> &a) {		//æ±‚å¹‚é›†ç®—æ³•1
	int n=a.size();
	x=vector<int>(n);
	dfs(a,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("æ±‚è§£ç»“æœ\n");
	pset1(a);
	return 0;
}


```



è‹¥è¦æ±‚è¾“å‡ºæœ‰åºçš„è§£ï¼Œåº”è¯¥ç”¨è¯¥æ–¹æ³•

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> x;												//è§£å‘é‡
void disp(vector<int> &x) {						//è¾“å‡ºä¸€ä¸ªè§£ï¼ˆå­é›†ï¼‰
	printf("  {");
	for (int k=0;k<x.size();k++)
		printf("%d ",x[k]);
	printf("}");
}
void dfs(vector<int> &a,int j) {					//å›æº¯ç®—æ³•
	disp(x);													//è¾“å‡ºå¯¹åº”çš„è§£
	for(int j1=j;j1<a.size();j1++) {					//j1â‰¥i
		x.push_back(a[j1]);
		dfs(a,j1+1);
		x.pop_back();
	}
}
void pset2(vector<int> &a) {					//æ±‚å¹‚é›†ç®—æ³•2
	dfs(a,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("æ±‚è§£ç»“æœ\n");
	pset2(a);
	return 0;
	return 0;
}


```

### å›¾çš„è·¯å¾„æœç´¢

```c++
#include<iostream>
#include<vector>
using namespace std;
const int INF=0x3f3f3f3f; 
int n=5;
vector<vector<int>> A={{0,5,INF,1,INF},{5,0,INF,INF,INF},{INF,INF,0,2,3},{1,INF,2,0,8},{INF,INF,3,8,0}};
vector<vector<int>> ans;			//å­˜æ”¾ç­”æ¡ˆ
vector<int> x;						//è§£å‘é‡
vector<int> visited;
void dfs(int i,int curlen,int t) {
	if (i==t) {
		ans.push_back(x);
		ans.back().push_back(curlen);
    }
	else {
    	for (int j=0;j<n;j++) {
            if(i==j || A[i][j]==INF) continue;
            if (visited[j]) continue;
            visited[j]=1;
            x.push_back(j);
            curlen+=A[i][j];
            dfs(j,curlen,t);
            curlen-=A[i][j];
            x.pop_back();
            visited[j]=0;
        }
    }
};
void allpath(int s,int t) {
    x.push_back(s);
    visited=vector<int>(n,0);
	visited[s]=1;
    dfs(s,0,t);
    printf("ä»%dåˆ°%dçš„æ‰€æœ‰è·¯å¾„:\n"); 
    for(int i=0;i<ans.size();i++) {
    	printf("  è·¯å¾„%d: é•¿åº¦=%d, è·¯å¾„:",i+1,ans[i].back());
		for(int j=0;j<ans[i].size()-1;j++)
			printf(" %d",ans[i][j]);
		printf("\n");
	}
}
int main() {
	//freopen("abc.out","w",stdout);
	int s=0,t=4;
	allpath(s,t);	
	return 0;
}
```

### æ„é€ è¡¨è¾¾å¼

```c++
#include<iostream>
#include<vector> 
using namespace std;
#define N 9
int a[N];
vector<string> ans;					//å­˜æ”¾ç­”æ¡ˆ 
char x[N];							//è§£å‘é‡
void dfs(int sum,int prev,int i)
{
	if (i==N) {						//åˆ°è¾¾ä¸€ä¸ªå¶å­ç»“ç‚¹
		if (sum==100) {				//æ‰¾åˆ°ä¸€ä¸ªè§£
			string s=to_string(a[0]);
			for (int j=1;j<N;j++) {
				if (x[j]!=' ') s+=x[j];
				s+=to_string(a[j]);
			}
			s+="=100";
			ans.push_back(s);
		}
	}
	else {
		x[i]='+';						//ä½ç½®iæ’å…¥'+'
		sum+=a[i];						//è®¡ç®—ç»“æœ
		dfs(sum,a[i],i+1);
		sum-=a[i];						//å›æº¯

		x[i]='-';						//ä½ç½®iæ’å…¥'-'
		sum-=a[i];						//è®¡ç®—ç»“æœ
		dfs(sum,-a[i],i+1);
		sum+=a[i];						//å›æº¯

		x[i]=' ';						//ä½ç½®iæ’å…¥' '
		sum-=prev;					//å…ˆå‡å»å‰é¢çš„å…ƒç´ å€¼
		int tmp;						//è®¡ç®—æ–°åˆå¹¶å€¼
		if (prev>0)
			tmp=prev*10+a[i];		//å¦‚prev=2,a[i]=3,ç»“æœä¸º23
		else
			tmp=prev*10-a[i];		//å¦‚prev=-2,a[i]=3,ç»“æœä¸º-23
		sum+=tmp;						//è®¡ç®—åˆå¹¶ç»“æœ
		dfs(sum,tmp,i+1);
		sum-=tmp;						//å›æº¯sum
		sum+=prev;
	}
}
void express() {
	for (int i=0;i<N;i++)				//ä¸ºaèµ‹å€¼ä¸º1,2ï¼Œ...,9
		a[i]=i+1;
	dfs(a[0],a[0],1);					//æ’å…¥ä½ç½®iä»1å¼€å§‹
	printf("æ±‚è§£ç»“æœ\n");
	for(int i=0;i<ans.size();i++)
		cout << "  (" << i+1 << ") " << ans[i] << endl;	
}
int main() {
	freopen("abc.out","w",stdout);
	express();
	return 0;
}

```

### å›¾çš„mç€è‰²é—®é¢˜

æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒå¤§ï¼ŒåŸç†ç®€å•

```c++
#include<iostream>
#include<cstring>
#define MAXN 20				//å›¾æœ€å¤šçš„é¡¶ç‚¹ä¸ªæ•°
int n=4;
int A[MAXN][MAXN]={{0,1,1,1},{1,0,0,0},{1,0,0,1},{1,0,1,0}};
int ans=0;						//å…¨å±€å˜é‡ï¼Œç´¯è®¡è§£ä¸ªæ•°
int x[MAXN];					//å…¨å±€å˜é‡ï¼Œx[i]è¡¨ç¤ºé¡¶ç‚¹içš„ç€è‰²
bool judge(int i,int j) {				//åˆ¤æ–­é¡¶ç‚¹iæ˜¯å¦å¯ä»¥ç€è‰²j
	for(int k=0;k<n;k++) {
 		if(A[i][k]==1 && x[k]==j)	//å­˜åœ¨ç›¸åŒé¢œè‰²çš„é¡¶ç‚¹
     	return false;
 	}
 	return true;
}

void dfs(int m,int i) {				//å›æº¯ç®—æ³•
	if (i>=n)					//è¾¾åˆ°å¶å­ç»“ç‚¹
		ans++;				//ç€è‰²æ–¹æ¡ˆæ•°å¢1
	else {
		for (int j=0;j<m;j++) {	//è¯•æ¢æ¯ä¸€ç§ç€è‰²
			x[i]=j;
			if (judge(i,j))		//å¯ä»¥ç€è‰²jï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªé¡¶ç‚¹ç€è‰²
				dfs(m,i+1);
			x[i]=-1;				//å›æº¯
		}
	}
}
void color(int m) {
	memset(x,0xff,sizeof(x));		//xåˆå§‹åŒ–
	dfs(m,0);
	printf("ç€è‰²æ–¹æ¡ˆæ•°:%d\n",ans); 
}
int main() {
	int m=3;
	color(m);
	return 0;
}



```

### å­é›†å’Œé—®é¢˜

æ— å‰ªæçš„ç®—æ³•ï¼š

```c++
#include<iostream>
#include<vector>
using namespace std;
int n,t;
vector<int> a;						//å­˜æ”¾æ‰€æœ‰æ•´æ•°
int cnt=0;							//ç´¯è®¡è§£ä¸ªæ•°
int tot=0;                         	//ç´¯è®¡æœç´¢çš„ç»“ç‚¹ä¸ªæ•°
vector<int> x;						//è§£å‘é‡ 
void disp() {				//è¾“å‡ºä¸€ä¸ªè§£
	printf("  ç¬¬%dä¸ªè§£,",++cnt);
  	printf("é€‰å–çš„æ•°ä¸º: ");
  	for (int i=0;i<x.size();i++) {
  		if (x[i]==1)
     	printf("%d ",a[i]);
 	}
  	printf("\n");
}
void dfs(int cs,int i) { 			//å›æº¯ç®—æ³•
	tot++;
  	if (i>=n) {									//åˆ°è¾¾ä¸€ä¸ªå¶å­ç»“ç‚¹
  		if (cs==t) disp();							//æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„è§£,è¾“å‡º
 	}
  	else {													//æ²¡æœ‰åˆ°è¾¾å¶å­ç»“ç‚¹
  		x[i]=1;											//é€‰å–æ•´æ•°a[i]
   		dfs(cs+a[i],i+1);
    	x[i]=0;											//ä¸é€‰å–æ•´æ•°a[i]
    	dfs(cs,i+1);
	}
}
void subs1(vector<int>&A,int T) {				//æ±‚è§£å­é›†å’Œé—®é¢˜
	n=A.size();
	a=A;
	t=T;
	x=vector<int>(n);
  	printf("æ±‚è§£ç»“æœ\n");
  	dfs(0,0);											//iä»0å¼€å§‹
  	printf("tot=%d\n",tot);
}

int main() {
	int t=8;
	vector<int> a={3,1,5,2};					//å­˜æ”¾æ‰€æœ‰æ•´æ•°
	//int t=3;
	//vector<int> a={1,3,2};					//å­˜æ”¾æ‰€æœ‰æ•´æ•°
	subs1(a,t);
	return 0;
}

```

å·¦å‰ªæï¼š

```c++
#include<iostream>
#include<vector>
using namespace std;
int n,t;
vector<int> a;						//å­˜æ”¾æ‰€æœ‰æ•´æ•°
int cnt=0;							//ç´¯è®¡è§£ä¸ªæ•°
int tot=0;                         	//ç´¯è®¡æœç´¢çš„ç»“ç‚¹ä¸ªæ•°
vector<int> x;						//è§£å‘é‡ 
void disp() {				//è¾“å‡ºä¸€ä¸ªè§£
	printf("  ç¬¬%dä¸ªè§£,",++cnt);
  	printf("é€‰å–çš„æ•°ä¸º: ");
  	for (int i=0;i<x.size();i++) {
  		if (x[i]==1)
     	printf("%d ",a[i]);
 	}
  	printf("\n");
}
void dfs(int cs,int i) { 			//å›æº¯ç®—æ³•
	tot++;
  	if (i>=n) {									//åˆ°è¾¾ä¸€ä¸ªå¶å­ç»“ç‚¹
  		if (cs==t) disp();							//æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„è§£,è¾“å‡º
 	}
  	else {													//æ²¡æœ‰åˆ°è¾¾å¶å­ç»“ç‚¹
		if (cs+a[i]<=t) {								//å·¦å­©å­ç»“ç‚¹å‰ªæ”¯
     		x[i]=1;										//é€‰å–æ•´æ•°a[i]
     		dfs(cs+a[i],i+1);
		}
    	x[i]=0;											//ä¸é€‰å–æ•´æ•°a[i]
    	dfs(cs,i+1);
	}
}
void subs2(vector<int>&A,int T) {				//æ±‚è§£å­é›†å’Œé—®é¢˜
	n=A.size();
	a=A;
	t=T;
	x=vector<int>(n);
  	printf("æ±‚è§£ç»“æœ\n");
  	dfs(0,0);											//iä»0å¼€å§‹
  	printf("tot=%d\n",tot);
}

int main() {
	int t=8;
	vector<int> a={3,1,5,2};					//å­˜æ”¾æ‰€æœ‰æ•´æ•°
	//int t=3;
	//vector<int> a={1,3,2};					//å­˜æ”¾æ‰€æœ‰æ•´æ•°
	subs2(a,t);
	return 0;
}

```

å³å‰ªæï¼š

```c++
#include<iostream>
#include<vector>
using namespace std;
int n,t;
vector<int> a;						//å­˜æ”¾æ‰€æœ‰æ•´æ•°
int cnt=0;							//ç´¯è®¡è§£ä¸ªæ•°
int tot=0;                         	//ç´¯è®¡æœç´¢çš„ç»“ç‚¹ä¸ªæ•°
vector<int> x;						//è§£å‘é‡ 
void disp() {				//è¾“å‡ºä¸€ä¸ªè§£
	printf("  ç¬¬%dä¸ªè§£,",++cnt);
  	printf("é€‰å–çš„æ•°ä¸º: ");
  	for (int i=0;i<x.size();i++) {
  		if (x[i]==1)
     	printf("%d ",a[i]);
 	}
  	printf("\n");
}
void dfs(int cs,int rs,int i) { 			//å›æº¯ç®—æ³•
	tot++;
  	if (i>=n) {									//åˆ°è¾¾ä¸€ä¸ªå¶å­ç»“ç‚¹
  		if (cs==t) disp();							//æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„è§£,è¾“å‡º
 	}
  	else {													//æ²¡æœ‰åˆ°è¾¾å¶å­ç»“ç‚¹
	  	rs-=a[i];											//æ±‚å‰©ä½™çš„æ•´æ•°å’Œ
	  	string str="dfs("+to_string(cs+a[i])+","+to_string(rs)+","+to_string(i+1)+")";
		cout << str << endl;  	
		if (cs+a[i]<=t) {								//å·¦å­©å­ç»“ç‚¹å‰ªæ”¯
     		x[i]=1;										//é€‰å–æ•´æ•°a[i]
     		dfs(cs+a[i],rs,i+1);
			cout << str << "è¿”å›" << endl;
		}
		else
			cout << str << "->cut" << endl;
 
	  	str="dfs("+to_string(cs)+","+to_string(rs)+","+to_string(i+1)+")";
		cout << str << endl;  	
    	if (cs+rs>=t) {									//å³å­©å­ç»“ç‚¹å‰ªæ”¯
     		x[i]=0;										//ä¸é€‰å–æ•´æ•°a[i]
      		dfs(cs,rs,i+1);
			cout << str << "è¿”å›" << endl;
		}
		else
			cout << str << "->cut" << endl;
	   	rs+=a[i];										//æ¢å¤å‰©ä½™æ•´æ•°å’Œ(å›æº¯)
	}
}
void subs3(vector<int>&A,int T) {				//æ±‚è§£å­é›†å’Œé—®é¢˜
	n=A.size();
	a=A;
	t=T;
	x=vector<int>(n);
	int rs=0;												//è¡¨ç¤ºæ‰€æœ‰æ•´æ•°å’Œ
  	for (int j=0;j<n;j++)					//æ±‚rs
  		rs+=a[j];
  	printf("æ±‚è§£ç»“æœ\n");
  	printf("dfs(0,%d,0)\n",rs);
  	dfs(0,rs,0);											//iä»0å¼€å§‹
  	printf("tot=%d\n",tot);
}

int main() {
	//int t=8;
	//vector<int> a={3,1,5,2};					//å­˜æ”¾æ‰€æœ‰æ•´æ•°
	int t=3;
	vector<int> a={1,3,2};					//å­˜æ”¾æ‰€æœ‰æ•´æ•°
	subs3(a,t);
	return 0;
}

```

### ç®€å•è£…è½½é—®é¢˜

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> w;
int t;
int n;
vector<int> x;									    //è§£å‘é‡
vector<int> bestx;									//å­˜æ”¾æœ€ä¼˜è§£å‘é‡
int bestw=0;										//å­˜æ”¾æœ€ä¼˜è§£çš„æ€»é‡é‡ï¼Œåˆå§‹åŒ–ä¸º0
int tot=0;                         	 	//ç´¯è®¡æœç´¢çš„ç»“ç‚¹ä¸ªæ•°
void dfs(int cw,int rw,int i) { 	//å›æº¯ç®—æ³•
	tot++;
  	if (i>=n) {									//è¾¾åˆ°ä¸€ä¸ªå¶å­ç»“ç‚¹
  		if (cw>bestw) {				          	//æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„æ›´ä¼˜è§£
     	bestw=cw;					            //ä¿å­˜æ›´ä¼˜è§£
      	bestx=x;
    	}
 	}
  	else {														//å°šæœªæ‰¾å®Œæ‰€æœ‰é›†è£…ç®±
  		rw-=w[i];											//æ±‚å‰©ä½™é›†è£…ç®±çš„é‡é‡å’Œ
   		if (cw+w[i]<=t) {								//å·¦å­©å­ç»“ç‚¹å‰ªæ”¯ï¼šé€‰æ‹©æ»¡è¶³æ¡ä»¶çš„é›†è£…ç®±
     	x[i]=1;											//é€‰å–é›†è£…ç®±i 
      	cw+=w[i];										//ç´¯è®¡å½“å‰æ‰€é€‰é›†è£…ç®±çš„é‡é‡å’Œ
      	dfs(cw,rw,i+1);
      	cw-=w[i];										//æ¢å¤å½“å‰æ‰€é€‰é›†è£…ç®±çš„é‡é‡å’Œ(å›æº¯)
    	}
    	if (cw+rw>bestw) {								//å³å­©å­ç»“ç‚¹å‰ªæ”¯
     	x[i]=0;											//ä¸é€‰æ‹©é›†è£…ç®±i
      	dfs(cw,rw,i+1);
    	}
    	rw+=w[i];											//æ¢å¤å‰©ä½™é›†è£…ç®±çš„é‡é‡å’Œ(å›æº¯)
  	}
}
void loading(vector<int>&W,int T) {							//æ±‚è§£ç®€å•è£…è½½é—®é¢˜
	w=W;
	t=T;
	n=w.size();
  	int rw=0;
  	for (int i=0;i<n;i++)						//ç´¯è®¡å…¨éƒ¨é›†è£…ç®±çš„é‡é‡å’Œrw
  		rw+=w[i];
	x=vector<int>(n);
	dfs(0,rw,0);										//iä»0å¼€å§‹
  	printf("æ±‚è§£ç»“æœ\n");
  	for (int i=0;i<n;i++) {      			//è¾“å‡ºæœ€ä¼˜è§£
  		if (bestx[i]==1)
     		printf("  é€‰å–ç¬¬%dä¸ªé›†è£…ç®±\n",i);
 	}
  	printf("  æ€»é‡é‡=%d\n",bestw);
  	printf("tot=%d\n",tot);
}
int main() {
	vector<int> w={5,2,6,4,3};
	int	t=10;
	loading(w,t);
	return 0;
}

```



### 0/1èƒŒåŒ…é—®é¢˜

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct Goods {
	int no;  //ç‰©å“ç¼–å·
	int w;  //ç‰©å“é‡é‡
	int v;  //ç‰©å“ä»·å€¼
	Goods(int no, int w, int v) {
		this->no = no;
		this->w = w;
		this->v = v;
	}

	bool operator<(const Goods& s) const {
		return (double)v / w > (double)v / w;
	}
};

vector<Goods>g = { Goods(0,5,4),Goods(1,3,4),Goods(2,2,3),Goods(3,1,1) };
int W=6;  //æœ€å¤§é‡é‡
int n=4;
vector<int>x; //è§£å‘é‡
vector<int>bestx;  //å­˜æ”¾æœ€ä¼˜è§£å‘é‡
int bestv = 0;  //å­˜æ”¾æœ€å¤§ä»·å€¼
int bestw = 0;
int tot = 0; //ç´¯è®¡æœç´¢çš„èŠ‚ç‚¹ä¸ªæ•°
int cw = 0;  //å½“å‰èƒŒåŒ…æ€»é‡
int cv = 0;  //å½“å‰èƒŒåŒ…ä»·å€¼

double bound(int i) {
	int rw = W - cw;
	double b = cv;
	int j = i;
	while (j < n && g[j].w < rw) {
		rw -= g[j].w;
		b += g[j].v;
		j++;
	}

	if (j < n) {
		b += (double)g[j].v / g[j].w*rw;
	}

	return b;
}

void dfs(int i) {
	tot++;
	if (i >= n) {
		if (cw <= W && cv > bestv) {
			bestv = cv;
			bestw = cw;
			bestx = x;
		}
	}

	else {
		if (cw + g[i].w <= W) {
			x[i] = 1;
			cw += g[i].w;
			cv += g[i].v;
			dfs(i + 1);
			cw -= g[i].w;
			cv -= g[i].v;

		}

		double b = bound(i + 1);  //ä¸é€‰å½“å‰èŠ‚ç‚¹çš„ä¸Šé™å‡½æ•°
		if (b > bestv) {
			x[i] = 0;
			dfs(i + 1);
		}
	}
}

void knap() {

	sort(g.begin(), g.end());
	x = vector<int>(n, 0);
	dfs(0);
	cout << "æœ€ä½³è£…å¡«æ–¹æ¡ˆï¼š" << endl;
	for (int i = 0; i < n; i++) {
		if (bestx[i] == 1) {
			cout << "é€‰å–ç¬¬" << g[i].no << "ä¸ªç‰©å“" << endl;
		}
	}

	cout << "æ€»é‡é‡=" << bestw << "æ€»ä»·å€¼=" << bestv;


}

int main() {
	knap();


}
```

### å®Œå…¨èƒŒåŒ…é—®é¢˜

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n=2; 
int w[]={1,2};
int v[]={2,5};
int W=2;
int bestv=0;      						//å­˜æ”¾æœ€å¤§ä»·å€¼,åˆå§‹ä¸º0
void dfs(int cw,int cv,int i) {    		//å›æº¯ç®—æ³•
	if(i>=n) {
		printf("å¶å­:cw=%d,cv=%d,i=%d  ",cw,cv,i); 
  		if(cw<=W && cv>bestv) {      	//æ‰¾åˆ°ä¸€ä¸ªæ›´ä¼˜è§£
     		bestv=cv;
     		printf(" => bestcv=%d",bestv);
     	}
     	printf("\n");     	
	}
  	else {
  		string str="dfs1("+to_string(cw)+","+to_string(cv)+","+to_string(i+1)+")";
  		cout << str << endl;
  		dfs(cw,cv,i+1);             	//ä¸é€‰æ‹©ç‰©å“i
  		cout << str<< "è¿”å›" << endl;
		printf("i=%d, cw+w[i]=%d,W=%d\n",i,cw+w[i],W); 
   		if(cw+w[i]<=W) {						//å‰ªæ”¯
  			str="dfs2("+to_string(cw+w[i])+","+to_string(cv+v[i])+","+to_string(i)+")";
  			cout << str << endl;
     		dfs(cw+w[i],cv+v[i],i);     	//é€‰æ‹©ç‰©å“iï¼Œç„¶åç»§ç»­é€‰æ‹©ç‰©å“i
  			cout << str<< "è¿”å›" << endl;
     	}
		printf("i=%d, cw+w[i]=%d,W=%d\n",i,cw+w[i],W);     	
  	  	if(cw+w[i]<=W) {					//å‰ªæ”¯
  			str="dfs3("+to_string(cw+w[i])+","+to_string(cv+v[i])+","+to_string(i+1)+")";
  			cout << str << endl;
	     	dfs(cw+w[i],cv+v[i],i+1);   	//é€‰æ‹©ç‰©å“i,ç„¶åé€‰ä¸‹ä¸€ä»¶
  			cout << str<< "è¿”å›" << endl;
	    }
  	}
}
void completeknap1() {					//æ±‚å®Œå…¨èƒŒåŒ…é—®é¢˜
	printf("dfs(0,0,0)\n");
	dfs(0,0,0);
    printf("æœ€å¤§ä»·å€¼=%d\n",bestv);
}
int main() {
	completeknap1();
	return 0;
}

```





```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n=2; 
int w[]={1,2};
int v[]={2,5};
int W=2;
int bestv=0;      						//å­˜æ”¾æœ€å¤§ä»·å€¼,åˆå§‹ä¸º0
void dfs(int cw,int cv,int j) {    		//å›æº¯ç®—æ³•
	printf("è°ƒç”¨dfs(%d,%d,%d)\n",cw,cv,j); 
	if(cw<=W && cv>bestv) {      		//æ‰¾åˆ°ä¸€ä¸ªæ›´ä¼˜è§£
    	bestv=cv;
		printf("å¶å­: cv=%d,bestv=%d\n",cv,bestv);
    }
    for (int j1=j;j1<n;j1++) {
     		printf("j1=%d, cw+w[j1]=%d,W=%d\n",j1,cw+w[j1],W); 
   			if(cw+w[j1]<=W) {					//å‰ªæ”¯
   				string str="j="+to_string(j)+",é€‰æ‹©j1="+to_string(j1)+" dfs("+ to_string(cw+w[j1])+","+to_string(cv+v[j1])+","+to_string(j1)+")";
   				cout << str << endl;
     			dfs(cw+w[j1],cv+v[j1],j1);     	//é€‰æ‹©ç‰©å“iï¼Œç„¶åç»§ç»­é€‰æ‹©ç‰©å“i
     			cout << str << "è¿”å›" << endl; 
     		}
     		else printf("è¶…é‡\n"); 
  		}
}
void completeknap2() {					//æ±‚å®Œå…¨èƒŒåŒ…é—®é¢˜
	dfs(0,0,0);
    printf("æœ€å¤§ä»·å€¼=%d\n",bestv);
}
int main() {
	completeknap2();
	return 0;
}

```



### åŸºäºæ’åˆ—é—®é¢˜çš„å›æº¯ç®—æ³•æ¡†æ¶

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> x;							//è§£å‘é‡
vector<int> used;						//used[i]è¡¨ç¤ºa[i]æ˜¯å¦ä½¿ç”¨è¿‡ 
int cnt=0;								//ç´¯è®¡æ’åˆ—ä¸ªæ•° 
void disp() {							//è¾“å‡ºä¸€ä¸ªè§£
	printf("  %2d {",++cnt);
	for (int i=0;i<x.size()-1;i++)
		printf("%d,",x[i]);
	printf("%d}\n",x.back());
}
void dfs(vector<int> &a,int i) {	//å›æº¯ç®—æ³•
	int n=a.size();
	if (i>=n)
		disp();
	else {
		for(int j=0;j<n;j++) {
			if(used[j]) continue;
			x[i]=a[j];
			used[j]=1;
			dfs(a,i+1);				//é€‰æ‹©a[j]
			used[j]=0;
			x[i]=0;
		}
	}
}
void perm1(vector<int> &a) {		//æ±‚å…¨æ’åˆ—ç®—æ³•1
	int n=a.size();
	x=vector<int>(n);
	used=vector<int>(n,0);
	dfs(a,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("æ±‚è§£ç»“æœ\n");
	perm1(a);
	return 0;
}


```



äº¤æ¢æ³•

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
vector<int> x;						//è§£å‘é‡
int cnt=0;							//ç´¯è®¡æ’åˆ—ä¸ªæ•°
void disp() {						//è¾“å‡ºä¸€ä¸ªè§£
	printf("  %2d {",++cnt);
	for (int i=0;i<x.size()-1;i++)
		printf("%d,",x[i]);
	printf("%d}\n",x.back());
}
void dfs(int i) {	//å›æº¯ç®—æ³•
	int n=x.size();
	if (i>=n)
		disp();
	else {
		for(int j=i;j<n;j++) {
			swap(x[i],x[j]);		//äº¤æ¢a[i]ä¸a[j]
			dfs(i+1);
			swap(x[i],x[j]);		//äº¤æ¢a[i]ä¸a[j]ï¼šæ¢å¤
		}
	}
}
void perm2(vector<int> &a) {		//æ±‚å…¨æ’åˆ—ç®—æ³•2
	int n=a.size();
	x=vector<int>(n);
	for(int i=0;i<n;i++)			//ç½®x=a 
		x[i]=a[i]; 
	dfs(0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("æ±‚è§£ç»“æœ\n");
	perm2(a);
	return 0;
}


```



### nçš‡åé—®é¢˜

éœ€è¦æ³¨æ„çš„æ˜¯å¦‚ä½•åˆ¤æ–­å¯¹è§’çº¿

```c++
#include<iostream>
#include<vector>
using namespace std;
#define MAXN 20					//æœ€å¤šçš‡åä¸ªæ•°
int q[MAXN];					//å­˜æ”¾nçš‡åé—®é¢˜çš„è§£(è§£å‘é‡)
int cnt=0;						//ç´¯è®¡è§£ä¸ªæ•°
void disp(int n) {  			//è¾“å‡ºä¸€ä¸ªè§£
	printf("  ç¬¬%dä¸ªè§£:",++cnt);
	for (int i=0;i<n;i++)
		printf("(%d,%d) ",i,q[i]);
	printf("\n");
}
bool valid(int i,int j) {                   	//æµ‹è¯•(i,j)ä½ç½®èƒ½å¦æ”¾ç½®çš‡å
	if (i==0) return true;                      //ç¬¬ä¸€ä¸ªçš‡åæ€»æ˜¯å¯ä»¥æ”¾ç½®
    int k=0;
    while (k<i) {                               //k=1ï½i-1æ˜¯å·²æ”¾ç½®äº†çš‡åçš„è¡Œ
       	if ((q[k]==j) || (abs(q[k]-j)==abs(i-k)))
           	return false;
       	k++;
    }
    return true;
}
void dfs(int n,int i) {						  //å›æº¯ç®—æ³•
	if (i>=n)
  		disp(n);								//æ‰€æœ‰çš‡åæ”¾ç½®ç»“æŸ
  	else {
  		for (int j=i;j<n;j++) {				//åœ¨ç¬¬iè¡Œä¸Šè¯•æ¢æ¯ä¸€ä¸ªåˆ—j
     		swap(q[i],q[j]);					//ç¬¬iä¸ªçš‡åæ”¾ç½®åœ¨q[j]åˆ—
      		if(valid(i,q[i]))					//å‰ªæ”¯
       			dfs(n,i+1);
      		swap(q[i],q[j]);					//å›æº¯
    	}
 	}
}
void queen(int n) {							//æ±‚è§£nçš‡åé—®é¢˜
  	for(int i=0;i<n;i++)           		//åˆå§‹åŒ–qä¸º0-n-1
  		q[i]=i;
	dfs(n,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	int n=6;								//nå­˜æ”¾å®é™…çš‡åä¸ªæ•°
	printf("%dçš‡åé—®é¢˜æ±‚è§£å¦‚ä¸‹:\n",n);
	queen(n);
	return 0;
}

```



### ä»»åŠ¡åˆ†é…é—®é¢˜

æ³¨æ„ä¸‹é™å‡½æ•°ï¼Œè¿™ç§å‰ªæçš„æ€æƒ³åœ¨å›æº¯ç®—æ³•ä¸­å¾ˆå¸¸è§

```c++
#include<iostream>
#include<vector>
using namespace std;
const int INF=0x3f3f3f3f;
int n;
vector<vector<int>> c;
vector<int> x;						//è§£å‘é‡
vector<int> bestx;					//æœ€ä¼˜è§£å‘é‡
int bestc;							//æœ€å°æˆæœ¬ 
vector<bool> used; 
int bound(int cost,int i) {								//æ±‚ä¸‹ç•Œç®—æ³•
	int minsum=0;
  	for (int i1=i;i1<n;i1++) {								//æ±‚c[i..n-1]è¡Œä¸­æœ€å°å…ƒç´ å’Œ
  		int minc=INF;
   		for (int j1=0;j1<n;j1++) {
     		if (used[x[j1]]==false && c[i1][x[j1]]<minc)
       		minc=c[i1][x[j1]];
		}
    	minsum+=minc;
  	}
  	return cost+minsum;
}
void dfs(int cost,int i) {							//å›æº¯ç®—æ³•
  	if (i>=n) {				            			//åˆ°è¾¾ä¸€ä¸ªå¶å­ç»“ç‚¹  		
  		if (cost<bestc) {		        			//æ¯”è¾ƒæ±‚æœ€ä¼˜è§£
     		bestc=cost;
      		bestx=x;
    	}
  	}
 	else {
  		for (int j=i;j<n;j++) {						//ä¸ºäººå‘˜iè¯•æ¢ä»»åŠ¡x[j]
     		swap(x[i],x[j]);						//ä¸ºäººå‘˜iåˆ†é…ä»»åŠ¡x[j]
      		used[x[i]]=true;
      		cost+=c[i][x[i]];
      		if(bound(cost,i+1)<bestc)				//å‰ªæ”¯
     			dfs(cost,i+1);						//ç»§ç»­ä¸ºäººå‘˜i+1åˆ†é…ä»»åŠ¡
     		cost-=c[i][x[i]];						//costå›æº¯
      		used[x[i]]=false;						//usedå›æº¯
     		swap(x[i],x[j]);
    	}
	}
}
void allocate(vector<vector<int>> &C) {     		//æ±‚è§£ä»»åŠ¡åˆ†é…é—®é¢˜
	c=C;
	n=c.size();
  	x=vector<int>(n);
  	for(int i=0;i<n;i++)							//å°†x[0..n-1]åˆ†åˆ«è®¾ç½®ä¸º0åˆ°n-1å€¼
  		x[i]=i;
  	used=vector<bool>(n,false);
  	bestc=INF;
  	dfs(0,0);										//ä»äººå‘˜0å¼€å§‹
  	printf("æœ€ä¼˜åˆ†é…æ–¹æ¡ˆ\n");
  	for (int k=0;k<n;k++)
  		printf("   äººå‘˜%dåˆ†é…ä»»åŠ¡%d\n",k,bestx[k]);
 	printf("   æ€»æˆæœ¬=%d\n",bestc);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<vector<int>> C={{9,2,7,8},{6,4,3,7},{5,8,1,8},{7,6,9,4}};
	allocate(C);	
	return 0;
}


```



### æ—…è¡Œå•†é—®é¢˜

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20241030092947443.png" alt="image-20241030092947443" style="zoom:50%;" />

```c++
#include<iostream>
#include<vector>
#include <limits>
using namespace std;
const int INF = std::numeric_limits<int>::max();
vector<int>x;  //è§£å‘é‡
vector<int>bestx;  //æœ€ä¼˜è§£å‘é‡
int d;  //è·¯å¾„é•¿åº¦
int bestd = INF;
void dfs(vector<vector<int>>& A, int s, int i,int n) {
	if (i >= n) {
		if (d +A[x[n-1]][s]< bestd) {
			bestd = d + A[x[n - 1]][s];
			bestx = x;
			bestx.push_back(s);
		}
	}
	else {
		for (int j = i; j < n; j++) {
			if (A[x[i - 1]][x[j]] != 0 && A[x[i - 1]][x[j]] != INF) {
				if (d + A[x[i - 1]][x[j]] < bestd) {
					swap(x[i], x[j]);
					d += A[x[i - 1]][x[i]];
					dfs(A, s, i + 1, n);
					d -= A[x[i - 1]][x[i]];
					swap(x[i], x[j]);
				}
			}
		}
	}
}

void TSP(vector<vector<int>>& A, int s) {
	int n = A.size();
	x.push_back(s);
	for (int i = 0; i < n; i++) {
		if (i != s) x.push_back(i);
	}
	d = 0;
	dfs(A, s, 1,n);
	cout << "æœ€çŸ­è·¯å¾„:";
	for (int i = 0; i < bestx.size(); i++) {
		if (i == 0) cout << bestx[i];
		else cout << "->" << bestx[i];
	}
	cout << endl << "è·¯å¾„é•¿åº¦ï¼š" << bestd;
}
int main() {
	vector<vector<int>> A = { {0,8,5,36},{6,0,8,5},{8,9,0,5},{7,7,8,0} };
	int s = 0; 									//æŒ‡å®šèµ·ç‚¹
	printf("æ±‚è§£ç»“æœ:\n");
	TSP(A, s);

}
```



### åŠ›æ‰£114äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        // ç®—æ³•ä¹‹ç¥ä¿ä½‘ï¼
        // å·¦å­æ ‘ä¸ºç©ºï¼Œç›´æ¥è€ƒè™‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        while (root != nullptr) {
            if (root->left == nullptr) {
                root = root->right;
            } else {
                TreeNode* pre = root->left;
                while (pre->right != nullptr) {
                    pre = pre->right;
                }
                pre->right = root->right;
                root->right = root->left;
                root->left = nullptr;
                root = root->right;
            }
        }
    }
};
```

### ACWingé€’å½’å®ç°ç»„åˆå‹æšä¸¾

åˆ†æä»£ç ï¼Œè§‰å¾—éš¾ç‚¹åœ¨äºæ€æ ·è¡¨ç¤ºæ¯æ¬¡æšä¸¾çš„æ•°éƒ½æ¯”å½“å‰å€¼è¦å¤§

æ¯”å¦‚ç¬¬ä¸€ä¸ªæ•°æ˜¯3ï¼Œé‚£ä¹ˆæˆ‘çš„ä¸‹ä¸€ä¸ªæ•°å¿…é¡»åœ¨4ï¼Œ5ä¸­é€‰

ä»£ç ä¸­å®šä¹‰äº†forå¾ªç¯ï¼Œå®šä¹‰äº†å˜é‡start,è§£å†³äº†è¯¥é—®é¢˜

```c++
#include<iostream>
using namespace std;
int n,r;
const int N=21;
int arr[N];
void dfs(int x,int start){
    if(x>r){
        for(int i=1;i<=r;i++){
            cout<<arr[i]<<' ';
        }
        cout<<endl;
        return;
    }
    
    for(int i=start;i<=n;i++){
        arr[x]=i;
        dfs(x+1,i+1);//æ¯æ¬¡é€’å½’ä¸€å®šæ˜¯ä¸‹ä¸€ä½ï¼Œä¿è¯æ•°æ®ä¸é‡å¤
        arr[x]=0;
    }
}
int main(){
    cin>>n>>r;
    dfs(1,1);
    return 0;
    
}
```



### ACWingé€’å½’å®ç°æ’åˆ—å‹æšä¸¾

é€’å½’æ ‘ä¾æ®ï¼šä¸€æ¬¡æšä¸¾æ¯ä¸ªä½ç½®åº”è¯¥æ”¾å“ªä¸ªæ•°

å…¨æ’åˆ—è¦æ±‚æ•°å­—ä¸å…è®¸é‡å¤ï¼Œä½†æ˜¯æœ‰äº›é¢˜ç›®ï¼š

æ¯”å¦‚æœ‰æ˜¯ä¸ªä½ç½®ï¼Œè¦æ±‚æˆ‘ä»¬åªå¡«3ä¸ªæ•°çš„è¯ï¼Œé‚£å°±å¯ä»¥æœ‰é‡å¤æ•°å­—  

```c++
#include<iostream>
using namespace std;
const int N=20;
int n;
int st[N];
int arr[N];
void dfs(int x){
    if(x>n){
        for(int i=1;i<=n;i++){
            cout<<arr[i]<<" ";
        }
        cout<<endl;
    }
    for(int i=1;i<=n;i++){
        if(!st[i]){//å¦‚æœè¿™ä¸ªæ•°è¿˜æ²¡æœ‰è¢«é€‰è¿‡
            st[i]=1;
            arr[x]=i;
            dfs(x+1);
            st[i]=0;
            arr[x]=0;
        }
    }
}
int main(){
    cin>>n;
    dfs(1);
    return 0;
}
```



### ACWingé€’å½’å®ç°æŒ‡æ•°å‹æšä¸¾

æœ¬é¢˜è®¾ç½®äº†ä¸‰ç§çŠ¶æ€ï¼Œåˆ†åˆ«æ˜¯1é€‰å–ï¼Œ2ä¸é€‰ï¼Œ0å¾…å®šï¼Œåˆ†æé—®é¢˜æ—¶å¯çŸ¥æ¯ä¸ªæ•°å­—åªæœ‰è¿™ä¸‰ç§æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹æ¯ä¸ªæ•°å­—æšä¸¾è¿™ä¸‰ä¸ªå€¼ï¼Œä½†æ˜¯æšä¸¾ä¸‹ä¸€ä¸ªå€¼ä¹‹å‰éœ€è¦æ¢å¤ç°åœº

```c++
#include<iostream>
using namespace std;
int n;
const int N = 20;
int arr[N];

void dfs(int x) {
    if (x > n) {
        for (int i = 1; i <= n; i++) {
            if (arr[i] == 1) {
                cout << i << ' ';
            }
        }
        cout << endl;
        return;
    }
    
    //è®°å¾—å›æº¯
    arr[x] = 1;
    dfs(x + 1);
    arr[x] = 0;
    /*
åœ¨è¿™ä¸ªç‰¹å®šçš„ä»£ç ä¸­ï¼Œarr[x] = 0; è¿™ä¸€è¡Œå¯ä»¥çœç•¥ã€‚å› ä¸ºåœ¨æ¯æ¬¡è°ƒç”¨ dfs å‡½æ•°æ—¶ï¼Œarr æ•°ç»„éƒ½ä¼šè¢«é‡ç½®ä¸ºå…¨é›¶ï¼Œæ‰€ä»¥åœ¨é€’å½’å›æº¯çš„è¿‡ç¨‹ä¸­ï¼Œarr[x] çš„å€¼ä¸ä¼šä¿ç•™åˆ°ä¸‹ä¸€æ¬¡è°ƒç”¨ dfs å‡½æ•°ã€‚ä½†æ˜¯åœ¨æ›´å¤æ‚çš„æƒ…å†µä¸‹ï¼Œå¦‚æœåœ¨é€’å½’å›æº¯çš„è¿‡ç¨‹ä¸­éœ€è¦ä¿æŒ arr æ•°ç»„çš„æŸäº›ç‰¹å®šçŠ¶æ€ï¼Œé‚£ä¹ˆè¿™ä¸€è¡Œä¸èƒ½çœç•¥ã€‚*/

    arr[x] = 2;
    dfs(x + 1);
    arr[x] = 0;

}
int main() {
    cin >> n;
    dfs(1);
    return 0;

}
```

### åŠ›æ‰£ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

æ³¨æ„å›æº¯

```c++
class Solution {
public:
    const vector<string> phoneMap = {"",    "",    "abc",  "def", "ghi",
                                     "jkl", "mno", "pqrs", "tuv", "wxyz"};

    void func(string& digits,int index,string &current,vector<string>&res){
        if(index==digits.size()){
            res.push_back(current);
            return;
        }

        int digit=digits[index]-'0';
        const string& letters = phoneMap[digit];
        for(auto le:letters){
            current.push_back(le);
            func(digits,index+1,current,res);
            current.pop_back();
        }

    }
    vector<string> letterCombinations(string digits) {
         vector<string>res;
        if(digits=="") return res;
        string current;
       
        int n=digits.size();
        func(digits,0,current,res);
        return res;

       
    }
};
```

### åŠ›æ‰£22æ‹¬å·ç”Ÿæˆ

**æœ‰æ•ˆæ‹¬å·çš„åˆ¤å®šæ¡ä»¶æ˜¯ï¼š**

ä»»ä½•æœ‰æ•ˆæ‹¬å·å­—ç¬¦ä¸²çš„å‰ç¼€ï¼Œå·¦æ‹¬å·çš„æ•°é‡ä¸å°‘äºå³æ‹¬å·çš„æ•°é‡

æœ€ç»ˆçš„å·¦å³æ‹¬å·æ•°é‡ç›¸ç­‰

æˆ‘ä»¬æ¥é‡ç°é€’å½’è¿‡ç¨‹ï¼š

**ç¬¬ä¸€æ­¥**ï¼š

- `current = ""`, `left = 0`, `right = 0`
- å¯ä»¥æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("(", 1, 0, 3, result)`

**ç¬¬äºŒæ­¥**ï¼š

- `current = "(", left = 1, right = 0`
- å¯ä»¥ç»§ç»­æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("((", 2, 0, 3, result)`
- ä¹Ÿå¯ä»¥æ·»åŠ å³æ‹¬å·ï¼Œä½† `left` æ•°é‡æœªè¾¾åˆ° `n`ï¼Œä¼˜å…ˆæ·»åŠ å·¦æ‹¬å·

**ç¬¬ä¸‰æ­¥**ï¼š

- `current = "((", left = 2, right = 0`
- å¯ä»¥ç»§ç»­æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("(((", 3, 0, 3, result)`

**ç¬¬å››æ­¥**ï¼š

- `current = "(((", left = 3, right = 0`
- å·²ç»è¾¾åˆ°æœ€å¤§å·¦æ‹¬å·æ•°ï¼Œåªèƒ½æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("((()", 3, 1, 3, result)`

**ç¬¬äº”æ­¥**ï¼š

- `current = "((()", left = 3, right = 1`
- ç»§ç»­æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("((())", 3, 2, 3, result)`

**ç¬¬å…­æ­¥**ï¼š

- `current = "((())", left = 3, right = 2`
- ç»§ç»­æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("((()))", 3, 3, 3, result)`

**ç¬¬ä¸ƒæ­¥**ï¼ˆç»ˆæ­¢æ¡ä»¶ï¼‰ï¼š

- `current = "((()))", left = 3, right = 3`
- `current.length() == 2 * n`ï¼Œå°† `"((()))"` æ·»åŠ åˆ°ç»“æœåˆ—è¡¨ `result`

**å›æº¯**ï¼ˆå›åˆ°ç¬¬ä¸‰æ­¥ï¼‰ï¼š

- `current = "((", left = 2, right = 0`
- å°è¯•æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("(()", 2, 1, 3, result)`

**ç¬¬å…«æ­¥**ï¼š

- `current = "(()", left = 2, right = 1`
- å¯ä»¥ç»§ç»­æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("(()(", 3, 1, 3, result)`

**ç¬¬ä¹æ­¥**ï¼š

- `current = "(()(", left = 3, right = 1`
- å·²ç»è¾¾åˆ°æœ€å¤§å·¦æ‹¬å·æ•°ï¼Œåªèƒ½æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("(()()", 3, 2, 3, result)`

**ç¬¬åæ­¥**ï¼š

- `current = "(()()", left = 3, right = 2`
- ç»§ç»­æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("(()())", 3, 3, 3, result)`

**ç¬¬åä¸€æ­¥**ï¼ˆç»ˆæ­¢æ¡ä»¶ï¼‰ï¼š

- `current = "(()())", left = 3, right = 3`
- `current.length() == 2 * n`ï¼Œå°† `"(()())"` æ·»åŠ åˆ°ç»“æœåˆ—è¡¨ `result`

**å›æº¯**ï¼ˆå›åˆ°ç¬¬äºŒæ­¥ï¼‰ï¼š

- `current = "(", left = 1, right = 0`
- å°è¯•æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()", 1, 1, 3, result)`

**ç¬¬åäºŒæ­¥**ï¼š

- `current = "()", left = 1, right = 1`
- å¯ä»¥ç»§ç»­æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()(", 2, 1, 3, result)`

**ç¬¬åä¸‰æ­¥**ï¼š

- `current = "()(, left = 2, right = 1`
- å¯ä»¥ç»§ç»­æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()((", 3, 1, 3, result)`

**ç¬¬åå››æ­¥**ï¼š

- `current = "()((", left = 3, right = 1`
- å·²ç»è¾¾åˆ°æœ€å¤§å·¦æ‹¬å·æ•°ï¼Œåªèƒ½æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()(()", 3, 2, 3, result)`

**ç¬¬åäº”æ­¥**ï¼š

- `current = "()((), left = 3, right = 2`
- ç»§ç»­æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()(())", 3, 3, 3, result)`

**ç¬¬åå…­æ­¥**ï¼ˆç»ˆæ­¢æ¡ä»¶ï¼‰ï¼š

- `current = "()(())", left = 3, right = 3`
- `current.length() == 2 * n`ï¼Œå°† `"()(())"` æ·»åŠ åˆ°ç»“æœåˆ—è¡¨ `result`

**å›æº¯**ï¼ˆå›åˆ°ç¬¬åäºŒæ­¥ï¼‰ï¼š

- `current = "()", left = 1, right = 1`
- å°è¯•æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()()", 2, 2, 3, result)`

**ç¬¬åä¸ƒæ­¥**ï¼š

- `current = "()()", left = 2, right = 2`
- å¯ä»¥ç»§ç»­æ·»åŠ å·¦æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()()(", 3, 2, 3, result)`

**ç¬¬åå…«æ­¥**ï¼š

- `current = "()()(", left = 3, right = 2`
- å·²ç»è¾¾åˆ°æœ€å¤§å·¦æ‹¬å·æ•°ï¼Œåªèƒ½æ·»åŠ å³æ‹¬å·ï¼Œè°ƒç”¨ `backtrack("()()()", 3, 3, 3, result)`

**ç¬¬åä¹æ­¥**ï¼ˆç»ˆæ­¢æ¡ä»¶ï¼‰ï¼š

- `current = "()()()", left = 3, right = 3`
- `current.length() == 2 * n`ï¼Œå°† `"()()()"` æ·»åŠ åˆ°ç»“æœåˆ—è¡¨ `result`

```c++
class Solution {
public:
    void ba(string s, int n, int left, int right, vector<string>& res) {
        int len = s.size();
        if (len == 2 * n) {
            res.push_back(s);
            return;
        }
        if (left < n) {
            ba(s + '(', n, left + 1, right, res);
        }

        if (right < left) {
            ba(s + ')', n, left, right + 1, res);
        }
    }
    vector<string> generateParenthesis(int n) {
        // ç»å…¸å›æº¯é—®é¢˜
        vector<string> res;
        ba("", n, 0, 0, res);
        return res;
       
    }
};
```

### åŠ›æ‰£40ç»„åˆæ€»å’ŒII

æ«è€å¸ˆä¹Ÿæ˜¯å¥½èµ·æ¥äº†ï¼Œéƒ½ä¼šè‡ªå·±å†™å›æº¯äº†

å»é‡é€»è¾‘

https://www.bilibili.com/video/BV12V4y1V73A/?spm_id_from=333.788&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

![image-20240718223851548](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718223851548.png)

```c++
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
class Solution {
public:
    void dfs(int sum, vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& res, int n) {
        if (sum > target || index >n) return;
        if (sum == target) {
            res.push_back(current);
            return;
        }

        for (int i = index; i < n; i++) {
            if (i>index && candidates[i] == candidates[i - 1]) continue;
            sum += candidates[i];
            current.push_back(candidates[i]);
            dfs(sum, candidates, target, i+1, current, res, n);
            sum -= candidates[i];
            current.pop_back();

        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>>res;
        int n = candidates.size();
        sort(candidates.begin(), candidates.end());
        vector<int>current;
        int sum = 0;
        int index = 0;
        dfs(sum, candidates, target, index, current, res, n);
        return res;


    
    }
};


int main() {
    vector<int>a = {2,2,6 };
    int target = 8;
    Solution b;
    vector<vector<int>>res;
   
    res=b.combinationSum2(a, target);
    for (auto i : res) {
        for (auto j : i) {
            cout << j << ' ';
        }
        cout << endl;
    }
   
    return 0;
}


```

### åŠ›æ‰£46å…¨æ’åˆ—

<img src="D:\WeChat Files\wxid_aaaljrtur35n22\FileStorage\Temp\31c3c6b720969af1aad9b3d26477fa1.jpg" alt="31c3c6b720969af1aad9b3d26477fa1" style="zoom: 50%;" />

```c++
class Solution {
public:
    void dfs(vector<int>& nums, int n, vector<vector<int>>& res, vector<int>& current, vector<int>& used) {
        if (current.size() == n) {
            res.push_back(current);
            return;
        }

        for (int i = 0; i < n; i++) {
            if (used[i]) continue;
            used[i] = 1;
            current.push_back(nums[i]);
            dfs(nums, n, res, current, used);
            current.pop_back();
            used[i] = 0;
        }

    }
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<int>used(n, 0);
        vector<vector<int>>res;
        vector<int>current;
        dfs(nums, n, res, current,used);
        return res;
    }
};
```

### åŠ›æ‰£47å…¨æ’åˆ—II

å»é‡é€»è¾‘ï¼š

![image-20240718225248217](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718225248217.png)

```c++
class Solution {
public:
    void dfs(vector<int>& nums, int n, vector<vector<int>>& res,
        vector<int>& current, vector<int>& used) {
        if (current.size() == n) res.push_back(current);
           
        

        for (int i = 0; i < n; i++) {
           
            if (i > 0 && nums[i] == nums[i - 1]&&used[i-1]==0) continue;
            if (used[i]) continue;
            used[i] = 1;
            current.push_back(nums[i]);
            dfs(nums, n, res, current, used);
            current.pop_back();
            used[i] = 0;
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        int n = nums.size();
        vector<int> used(n, 0);
        vector<vector<int>> res;
        vector<int> current;
        sort(nums.begin(), nums.end());
        dfs(nums, n, res, current, used);
        return res;
    }
};
```

### æ±‰è¯ºå¡”é—®é¢˜

æ±‰è¯ºå¡”é—®é¢˜çš„ä¸»è¦æ€æƒ³æ˜¯ï¼š

1. å°† `n-1` ä¸ªç›˜å­ä»æºæŸ±å­ï¼ˆAï¼‰ç§»åŠ¨åˆ°è¾…åŠ©æŸ±å­ï¼ˆBï¼‰ã€‚
2. å°†ç¬¬ `n` ä¸ªç›˜å­ä»æºæŸ±å­ï¼ˆAï¼‰ç§»åŠ¨åˆ°ç›®æ ‡æŸ±å­ï¼ˆCï¼‰ã€‚
3. å°† `n-1` ä¸ªç›˜å­ä»è¾…åŠ©æŸ±å­ï¼ˆBï¼‰ç§»åŠ¨åˆ°ç›®æ ‡æŸ±å­ï¼ˆCï¼‰ã€‚

```
void hanoi(int n, char source, char auxiliary, char destination) {
    if (n == 1) {
        cout << source <<" " << "To"<<" " << destination << endl;
        return;
    }

    else {
        hanoi(n - 1, source, destination, auxiliary);


        cout << source <<" " << "To"<<" " << destination << endl;
        hanoi(n - 1, auxiliary, source, destination);

       
    }

 
}
```

### è°·ä»“çš„å®‰ä¿

Farmer Johnç»™è°·ä»“å®‰è£…äº†ä¸€ä¸ªæ–°çš„å®‰å…¨ç³»ç»Ÿï¼Œå¹¶ä¸”è¦ç»™ç‰›ç¾¤ä¸­çš„æ¯ä¸€ä¸ªå¥¶ç‰›å®‰æ’ä¸€ä¸ªæœ‰æ•ˆçš„å¯†ç ã€‚ä¸€ä¸ªæœ‰æ•ˆçš„å¯†ç ç”±L(3 <= L <= 15)ä¸ªå°å†™å­—æ¯(æ¥è‡ªä¼ ç»Ÿçš„æ‹‰ä¸å­—æ¯é›†'a'...'z')ç»„æˆï¼Œè‡³å°‘æœ‰ä¸€ä¸ªå…ƒéŸ³('a', 'e', 'i', 'o', æˆ–è€… 'u')ï¼Œè‡³å°‘ä¸¤ä¸ªè¾…éŸ³(é™¤å»å…ƒéŸ³ä»¥å¤–çš„éŸ³èŠ‚)ï¼Œå¹¶ä¸”æœ‰æŒ‰å­—æ¯è¡¨é¡ºåºå‡ºç°çš„å­—æ¯(ä¾‹å¦‚ï¼Œ'abc'æ˜¯æœ‰æ•ˆçš„ï¼Œè€Œ'bac'ä¸æ˜¯) ã€‚
ç»™å®šä¸€ä¸ªæœŸæœ›é•¿åº¦Lå’ŒCä¸ªå°å†™å­—æ¯ï¼Œå†™ä¸€ä¸ªç¨‹åºï¼Œæ‰“å°å‡ºæ‰€æœ‰çš„é•¿åº¦ä¸ºLã€èƒ½ç”±è¿™äº›å­—æ¯ç»„æˆçš„æœ‰æ•ˆå¯†ç ã€‚å¯†ç å¿…é¡»æŒ‰å­—æ¯è¡¨é¡ºåºæ‰“å°å‡ºæ¥ï¼Œä¸€è¡Œä¸€ä¸ªã€‚



ç¬¬ä¸€è¡Œ: ä¸¤ä¸ªç”±ç©ºæ ¼åˆ†å¼€çš„æ•´æ•°ï¼ŒLå’ŒCã€‚
ç¬¬äºŒè¡Œ: Cä¸ªç©ºæ ¼åˆ†å¼€çš„å°å†™å­—æ¯ï¼Œå¯†ç æ˜¯ç”±è¿™ä¸ªå­—æ¯é›†ä¸­çš„å­—æ¯æ¥æ„å»ºçš„ã€‚



è¾“å‡ºè‹¥å¹²è¡Œï¼Œæ¯ä¸€ä¸ªè¾“å‡ºè¡ŒåŒ…æ‹¬ä¸€ä¸ªé•¿åº¦ä¸ºLä¸ªå­—ç¬¦çš„å¯†ç (æ²¡æœ‰ç©ºæ ¼)ã€‚è¾“å‡ºè¡Œå¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºæ’åˆ—ã€‚
å¦‚æœè®¡ç®—å‡ºè¶…è¿‡25000ä¸ªæœ‰æ•ˆå¯†ç ï¼Œä½ çš„ç¨‹åºåªéœ€è¾“å‡ºå‰25000ä¸ªæœ‰æ•ˆå¯†ç ï¼Œå³ä½¿åé¢è¿˜å­˜åœ¨æœ‰æ•ˆå¯†ç ã€‚



```c++
//æ ·ä¾‹è¾“å…¥
4 6
a t c i s w
    
//æ ·ä¾‹è¾“å‡º
acis
acit
aciw
acst
acsw
actw
aist
aisw
aitw
astw
cist
cisw
citw
istw
```





```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int L, C;
vector<char> arr(20);
vector<char> current(30);
vector<bool>st(30);
int cnt = 0;


void dfs(int start, int len) {
    if (cnt >= 25000) exit(0);

    if (len == L) {
        int cnt1 = 0, cnt2 = 0;
        for (auto i : current) {
            if (i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u') cnt1++;
            else cnt2++;
        }

        if (cnt1 >= 1 && cnt2 >= 2) {
            for (char c : current) {
                cout << c;
            }
            cout << endl;
            cnt++;
            if (cnt >= 25000) exit(0);
        }
        return;
    }

    for (int i = start; i < C; i++) {
        if (cnt >= 25000) exit(0);
        if (!st[i]) {
            current[len] = arr[i];
            st[i] = 1;
            dfs(i + 1, len + 1);
            st[i] = 0;

        }
    }
}

int main() {
  
    cin >> L >> C;

    for (int i = 0; i < C; i++) cin >> arr[i];

    sort(arr.begin(), arr.begin() + C);
    dfs(0, 0);

    return 0;
}
```

### å…«çš‡åé—®é¢˜

æœ¬é¢˜æ˜¯ç»å…¸å›æº¯æ¨¡æ¿é¢˜ï¼Œå…¶å®å’Œå†™å…«ä¸ªforå¾ªç¯æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡å›æº¯å†™èµ·æ¥æ–¹ä¾¿ä¸€äº›

ä¸»è¦é€»è¾‘å°±æ˜¯éå†æ¯è¡Œï¼Œå†éå†è¯¥è¡Œçš„æ¯ä¸€åˆ—ï¼Œå¦‚æœè¯¥è¡Œã€è¯¥åˆ—ã€å¯¹è§’çº¿ä¸Šéƒ½æ²¡æœ‰çš‡åï¼Œå°±åŠ ä¸€ä¸ªçš‡åï¼Œå†éå†ä¸‹ä¸€è¡Œ

æ‰€ä»¥åœ¨åˆ¤æ–­map[i] [j]æ˜¯å¦å¯ä»¥å­˜æ”¾èŠ‚ç‚¹çš„æ—¶å€™ï¼Œæœ¬è¡Œçš„ä¸‹ä¸€è¡Œä¸€å®šæ²¡æœ‰çš‡åï¼Œä¸ç”¨åˆ¤æ–­ä¸‹é¢è¡Œï¼Œå› ä¸ºä¸‹é¢è¡Œè¿˜æ²¡æœ‰éå†åˆ°ï¼Œæœ¬è¡Œä¸‹é¢çš„ä¸¤æ¡å¯¹è§’çº¿ä¹Ÿæ²¡æœ‰çš‡åï¼Œæ‰€ä»¥åªåˆ¤æ–­è¯¥åˆ—ä¸Šå’Œå·¦ä¸Šã€å³ä¸Šå¯¹è§’çº¿ä¸Šæ˜¯å¦æœ‰çš‡åå³å¯





```c++
#include<iostream>
using namespace std;

const int N = 10;
int map[N][N] = { 0 };
int cnt = 0;

bool isvalid(int row, int column) {
    for (int i = 1; i < row; i++) {
        if (map[i][column]) return false;
        if (column-(row-i) >= 1 && map[i][column - (row-i)]) return false;
        if (column + (row-i)<= 8 && map[i][column + (row-i)]) return false;
    }
    return true;
}

void dfs(int row) {
    if (row == 9) {
        cnt++;
        cout << "No." <<" "<<cnt << endl;
        for (int i = 1; i <= 8; i++) {
            for (int j = 1; j <= 8; j++) {
                cout << map[i][j] << " ";
            }
            cout << endl;
        }
        return;
    }

    for (int i = 1; i <= 8; i++) {
        if (isvalid(row, i)) {
            map[row][i] = 1;
            dfs(row + 1);
            map[row][i] = 0;
        }
    }
}

int main() {
    dfs(1);
    return 0;
}

```

### æ•°è¿·

ç»™å‡ºå«æœ‰NÃ—Nä¸ªæ ¼å­çš„æ­£æ–¹å½¢è¡¨æ ¼ï¼Œè¦æ±‚æ¯ä¸ªæ ¼å­éƒ½å¡«ä¸Šä¸€ä¸ª**ä¸ªä½æ•°**ï¼ˆèŒƒå›´1ï½Nï¼‰ï¼Œä½¿å¾—æ¯è¡Œã€æ¯åˆ—ä»¥åŠåŒä¸€æ–œçº¿ä¸Šçš„æ•°å­—éƒ½ä¸åŒã€‚éƒ¨åˆ†æ ¼å­å·²ç»å¡«å¥½æ•°å­—ã€‚æ±‚æ»¡è¶³é¢˜æ„çš„æ–¹æ¡ˆæ•°ã€‚

ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°N (1<=N<=9)ã€‚

ä¸‹æ¥ç»™å‡ºä¸€ä¸ªéƒ¨åˆ†å·²ç»å¡«å¥½æ•°å­—çš„æ­£æ–¹å½¢ã€‚æ€»å…±Nè¡Œï¼Œæ¯è¡ŒNä¸ªå­—ç¬¦ï¼Œâ€˜*â€™è¡¨ç¤ºç©ºç™½æ ¼å­ï¼Œè¿˜æ²¡æœ‰å¡«æ•°å­—ã€‚

```c++
//è¾“å…¥
5
54*21
3*154
*54*2
4*215
*1***
    
//è¾“å‡º1
```



ç¬¬ä¸€ç§æ–¹æ³•æ˜¯éå†æ¯ä¸€å±‚ï¼Œæ£€æŸ¥è¿™ä¸€å±‚çš„æ¯ä¸€åˆ—ï¼Œå¦‚æœéœ€è¦å¡«æ•°å­—çš„è¯ï¼Œéå†æ‰€æœ‰èƒ½éå†çš„æ•°æ®çš„å¯èƒ½ï¼Œå†é€’å½’è°ƒç”¨æœ¬å±‚ï¼Œå¦‚æœè¿˜æœ‰éœ€è¦å¡«æ•°çš„æ ¼å­ï¼Œç»§ç»­å¡«æ•°å­—ï¼ŒçŸ¥é“æœ¬å±‚å¡«æ»¡æ•°å­—



```c++
#include <iostream>
#include <vector>
using namespace std;

const int N = 10;
vector<string> map(N);
int n;
int cnt = 0;


bool isvalid(int row, int column, char num) {
  
    for (int i = 0; i < n; i++) {
        if (i != column && map[row][i] == num) return false;
        if (i != row && map[i][column] == num) return false;
    }

    for (int i = 1; i < n; i++) {
        if (row + i < n && column + i < n && map[row + i][column + i] == num) return false;
        if (row + i < n && column - i >= 0 && map[row + i][column - i] == num) return false;
        if (row - i >= 0 && column + i < n && map[row - i][column + i] == num) return false;
        if (row - i >= 0 && column - i >= 0 && map[row - i][column - i] == num) return false;
    }

    return true;
}


void dfs(int row) {
    if (row == n) {
        for (int i = 0; i < n; i++) cout << map[i] << endl;
        cnt++;
       
        return;
    }

  
    for (int i = 0; i < n; i++) {
        if (map[row][i] == '*') {
            for (int j = 1; j <= n; j++) {
                char num = j + '0';
                if (isvalid(row, i, num)) {
                    map[row][i] = num;
                    dfs(row); 
                    map[row][i] = '*';  
                }
            }
            return; 
        }
    }

   
    dfs(row + 1);  
    
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> map[i];
    }
    dfs(0);
    cout << cnt;
    return 0;
}

```





ç¬¬äºŒç§æ–¹æ³•æ˜¯éå†æ¯ä¸€ä¸ªè¦å¡«å……çš„æ•°å­—ï¼Œå†éå†å¡«æ•°ï¼Œå¦‚æœå½“å‰å¯ä»¥å¡«æ•°å­—ï¼Œåˆ™ç»§ç»­éå†ä¸‹ä¸€ä¸ªç©ºæ ¼

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

const int N = 10;
int n;
int res = 0;
int num_cnt = 0;
vector<string> map(N);
vector<pair<int, int>> record;

bool isvalid(char num, int x, int y) {
    for (int i = 0; i < n; i++) {
        if (map[x][i] == num || map[i][y] == num) return false; // åŒè¡Œæˆ–åŒåˆ—
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if ((i + j == x + y || i - j == x - y) && map[i][j] == num) return false; // å¯¹è§’çº¿
        }
    }
    return true;
}

void dfs(int num) {
    if (num == num_cnt) {
        res++;
        return;
    }

    int x = record[num].first;
    int y = record[num].second;

    for (int i = 1; i <= n; i++) {
        if (isvalid(i + '0', x, y)) {
            map[x][y] = i + '0';
            dfs(num + 1);
            map[x][y] = '*';
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> map[i];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (map[i][j] == '*') {
                record.push_back({i, j});
                num_cnt++;
            }
        }
    }

    dfs(0);
    cout << res;
    return 0;
}

```



# æ·±åº¦ä¼˜å…ˆ

### [äº‘å‰ªè´´æ¿ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com)](https://www.luogu.com/paste/vjf2z3hi)

### é€’å½’æ ‘

#### é€’å½’æ ‘çš„æ·±åº¦

é€’å½’æ ‘çš„æ·±åº¦æŒ‡çš„æ˜¯ä»æ ¹èŠ‚ç‚¹ï¼ˆåˆå§‹å‡½æ•°è°ƒç”¨ï¼‰åˆ°æœ€æ·±çš„å¶å­èŠ‚ç‚¹ï¼ˆæœ€åä¸€æ¬¡é€’å½’è°ƒç”¨ï¼‰æ‰€ç»è¿‡çš„èŠ‚ç‚¹æ•°æˆ–è°ƒç”¨æ¬¡æ•°ã€‚å®ƒåæ˜ äº†é€’å½’è°ƒç”¨çš„æœ€å¤§åµŒå¥—å±‚æ¬¡ã€‚

### åŠ›æ‰£ä¸åŒè·¯å¾„

é—®é¢˜è½¬åŒ–ä¸ºæ±‚äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
using namespace std;

int func(int x,int y,int endx,int endy) {
    if (x > endx || y > endy) return 0;
    if (x == endx && y == endy) return 1;
    return func(x + 1, y,endx,endy) + func(x, y + 1,endx,endy);



}
int main() {
    cout << func(0,0, 2,2);
}
```

$$
å¯¹äºè¯¥é€’å½’æ ‘ï¼Œä»–çš„æ·±åº¦ä¸º(endx-x+endy-y),æ—¶é—´å¤æ‚åº¦ä¸º2^{endx-x+endy-y}
$$



### 15å±Šè“æ¡¥æ¯æ•°å­—æ¥é¾™

```c++
#include <iostream>
#include <string>
using namespace std;
const int N = 20;
int map[N][N];//åœ°å›¾
bool vis[N][N];//çŠ¶æ€æ•°ç»„
string res;//å­˜æ”¾ç­”æ¡ˆ,è¾“å‡ºç¬¬ä¸€æ¬¡æœç´¢åˆ°çš„å­—ç¬¦ä¸²
//æœç´¢ä¸åˆ°ï¼Œè¾“å‡º-1ä¹Ÿæœ‰åˆ†
int dx[8] = {-1,-1,0,1,1,1,0,-1};//æ–¹å‘æ•°ç»„,ä¸‹æ ‡å’Œç»™å®šæ–¹å‘ä¸€è‡´
int dy[8] = {0,1,1,1,0,-1,-1,-1};

int n, k;
void dfs(int x, int y, int pre, string s, int dep) {
    if (x == n && y == n && dep == n * n) {
        //å¦‚æœæœç´¢åˆ°ç»ˆç‚¹å¹¶ä¸”æœç´¢æ·±åº¦ç­‰äºn*nï¼Œè¯´æ˜å·²ç»æœç´¢åˆ°ç»“å°¾ï¼Œæœç´¢ç»“æŸ
        if (res.empty()) res = s;//æ­¤æ—¶ä¸ºç©ºè¯´æ˜ä¸€å®šæ˜¯å­—å…¸åºæœ€å°çš„ï¼Œè¿”å›
        return;
    }

    for (int i = 0; i < 8; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a<1 || b<1 || a>n || b>n) continue;
        if (vis[a][b]) continue;

        //é˜²æ­¢äº¤å‰æœç´¢
        //æ€æƒ³æ˜¯ä¼šå‡ºç°äº¤å‰æœç´¢çš„æ˜¯1ã€3ã€5ã€7è¿™å››æ¡
        //å¦‚æœç›¸é‚»ç‚¹è¢«æ ‡è®°è¿‡ï¼Œè¯´æ˜è¢«äº¤å‰æœç´¢äº†
        if (i == 1 && vis[x - 1][y] && vis[x][y + 1]) continue;
        else if (i == 3 && vis[x + 1][y] && vis[x][y+1]) continue;
        else if (i == 5 && vis[x+1][y] && vis[x][y-1]) continue;
        else if (i == 7 && vis[x-1][y] && vis[x][y - 1]) continue;

        //ä¿è¯æœç´¢æ–¹å‘æ˜¯0ï¼Œ1ï¼Œ2ï¼Œk-1...
        if ((map[a][b] < k && map[a][b] == pre + 1) || (pre+1==k &&map[a][b]==0)) {
            //å¼€å§‹æœç´¢
            vis[a][b] = true;
            dfs(a, b, map[a][b], s + to_string(i), dep + 1);

            //æœ€ä¼˜æ€§å‰ªæ
            if (!res.empty()) return;//å¦‚æœç»“æœå­—ç¬¦ä¸²éç©ºï¼Œé€å±‚è¿”å›
            
            vis[a][b] = false;//æœ¬é¢˜å¿…é¡»å¼•å…¥å›æº¯

        }
    }
}

int main() {
    //é¦–å…ˆä½ è¦æŠŠé¢˜ç›®éƒ½æ¸…æ¥š
    //é¢˜ç›®éƒ½ä¸æ¸…æ¥šæ€ä¹ˆæ¨¡æ‹Ÿå‘¢ï¼Ÿ
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> map[i][j];
        }
    }

    string emp;
    vis[1][1] = 1;
    
    //å‚æ•°åˆ†åˆ«æ˜¯ä¸‹æ ‡x,y,æœç´¢åºåˆ—ï¼Œæ‹¼æ¥å­—ç¬¦ä¸²å’Œæœç´¢æ·±åº¦
    dfs(1, 1, 0, emp, 1);
    if (res.empty()) cout << -1 << endl;
    else cout << res << endl;

    
    return 0;
}

```



### åŠ›æ‰£99æ¢å¤äºŒå‰æœç´¢æ ‘

ç©ºé—´å¤æ‚åº¦ä¸º0nçš„åšæ³•

```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& nums) {
        if (root == nullptr) {
            return;
        }
        inorder(root->left, nums);
        nums.push_back(root->val);
        inorder(root->right, nums);
    }

    pair<int,int> findTwoSwapped(vector<int>& nums) {
        int n = nums.size();
        int index1 = -1, index2 = -1;
        for (int i = 0; i < n - 1; ++i) {
            if (nums[i + 1] < nums[i]) {
                index2 = i + 1;
                if (index1 == -1) {
                    index1 = i;
                } else {
                    break;
                }
            }
        }
        int x = nums[index1], y = nums[index2];
        return {x, y};
    }
    
    void recover(TreeNode* r, int count, int x, int y) {
        if (r != nullptr) {
            if (r->val == x || r->val == y) {
                r->val = r->val == x ? y : x;
                if (--count == 0) {
                    return;
                }
            }
            recover(r->left, count, x, y);
            recover(r->right, count, x, y);
        }
    }

    void recoverTree(TreeNode* root) {
        vector<int> nums;
        inorder(root, nums);
        pair<int,int> swapped= findTwoSwapped(nums);
        recover(root, 2, swapped.first, swapped.second);
    }
};


```

### åŠ›æ‰£110åˆ¤æ–­å¹³è¡¡äºŒå‰æ ‘

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return depth(root)!=-1;
    }
    int depth(TreeNode*root){
        if(root==nullptr) return 0;
        int left =depth(root->left);
        if(left==-1) return -1;
        int right=depth(root->right);
        if(right==-1) return -1;
        return abs(left-right)<2?max(left,right)+1:-1;    
    }
};
```



### åŠ›æ‰£113è·¯å¾„æ€»å’Œ

```c++
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();//å›æº¯
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};


```





### æ´›è°·p1036é€‰æ•°

```c++
#include<iostream>
using namespace std;
const int N=30;
int n,k;
int arr[N];
int choose[N];
int res=0;

bool is_prime(int sum){
    for(int i=2;i<sum/i;i++){
        if(sum%i==0) return false;
    }
    return true;
}
void dfs(int x,int start){
    
    if(x>k){
        int sum=0;
        for(int i=1;i<=k;i++){
            sum+=choose[i];
        }
        if(is_prime(sum)) res++;
        return;
        
    }
    for(int i=start;i<=n;i++){//ç”¨ä¸‹æ ‡è¡¨ç¤ºstartï¼Œä½†æ˜¯å®é™…ä¸Šæ˜¯arr[i]
        choose[x]=arr[i];//ç»„åˆå‹æšä¸¾çš„ç®€å•åº”ç”¨è¾£å•¦
        dfs(x+1,i+1);
        choose[x]=0;
    }
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
    }
    //ç»„åˆæ•°
    dfs(1,1);
    cout<<res;
    return 0;
    
}
```



### æ´›è°·p1088ç«æ˜Ÿäºº

//å…¨æ’åˆ—æ¨¡æ¿

//è®¾ç½®çŠ¶æ€æ•°ç»„å’Œç­”æ¡ˆæ•°ç»„

//åŒæ—¶æ³¨æ„åˆ°ï¼Œå› ä¸ºåˆšå¼€å§‹éå†çš„æ—¶å€™ä¸ä¸€å®šæ˜¯ä»æœ€å°å¼€å§‹ï¼Œè¾“å…¥äº†marsæ•°ç»„ï¼Œæˆ‘ä»¬è®©iä»mars[x]å¼€å§‹éå†

//æ‰¾åˆ°ä¹‹åå¯ä»¥åœæ­¢ç¨‹åº

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
int N, M;
int mars[10010];
int st[10010];
int arr[10010];
int res = 0;
int return0 = 0;
void dfs(int x) {
    if (return0 == 1) {
        return;
    }
    if (x > N) {
        res++;
        if (res == M + 1) {
            return0 = 1;
            for (int i = 1; i <= N; i++) {
                printf("%d ", arr[i]);
            }
        }
    }
    for (int i = 1; i <= N; i++) {
        if (res == 0) {
            i = mars[x];
        }
            if (!st[i]) {
                st[i] = 1;
                arr[x] = i;
                dfs(x + 1);
                st[i] = 0;
                arr[x] = 0;
            }
        }
    }

int main() {
    cin >> N;
    cin >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d",&mars[i]);
    }
    dfs(1);
}
```





è™½ç„¶ä½†æ˜¯ï¼ŒSTLä½ æ˜¯æˆ‘çš„ç¥ï¼Œæ¯”èµ›å°±ç”¨ä½ ï¼ï¼ï¼

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int N,M;
	string s="";
	cin>>N;
	cin>>M;
	char ch;
	for(int i=0;i<N;i++){
		cin>>ch;
		s+=ch;
	}
	while(M--){
		next_permutation(s.begin(),s.end());
	}
	cout<<s;
    return 0;
}

```



### æ´›è°·p2089çƒ¤é¸¡

æˆ‘ä»¬å‘ç°æ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªæ•°åªæœ‰ä¸‰ç§çŠ¶æ€ï¼Œå’ŒæŒ‡æ•°å‹æšä¸¾ç±»ä¼¼

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 11;
int n;
vector<int>choose(11);
int res = 0;
int sum = 0;
vector<vector<int>>ans;


void dfs(int x)
{
    if (x > 10) {
        if (sum == n) {
            ans.push_back(choose);
            res += 1;
        }              
        return;
    }
    for (int i = 1; i <= 3; i++) {
        choose[x] = i;
        sum += i;
        if (sum <= n) {
            dfs(x + 1);
        }
        sum -= i;
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << res << endl;
    for (auto p : ans) {
        for (int i = 1; i <= 10; i++) {
            cout << p[i] << " ";
        }
        cout << endl;
    }
    
    return 0;
}

```



### p1149ç«æŸ´æ£’ç­‰å¼

æˆ‘çœŸç¬‘äº†ï¼Œè‡ªè®¤ä¸ºå¼€1000æ•°æ®å¤ªå¤§äº†ï¼Œç„¶åæ”¹å°äº†ï¼Œç­”æ¡ˆå°±ä¸å¯¹ï¼Œä¸è¦å¤ªé«˜å‚²äº†å•Šå•Šå•Šå•Šå•Š

```c++
#include<iostream>
using namespace std;
int n;

int ans;
int match[1000] = { 6,2,5,5,4,5,6,3,7,6 };
int arr[4];
void dfs(int x,int sum) {
	if (sum > n) return;//å‰ªæ 
	if (x > 3) {
		if (sum == n && arr[1] + arr[2] == arr[3])  ans++;
		return;
		
	}

	for (int i = 0; i < 1000; i++) {
		arr[x] = i;	
		dfs(x + 1,sum+match[i]);
	}


}
int main() {
	cin >> n;
	n -= 4;
	for (int i = 10; i <1000; i++) {
		match[i] = match[i % 10] + match[i / 10];
	}
	dfs(1,0);
	cout << ans;

	return 0;

}
```



### æ´›è°·p2036

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int n;
bool tl = false;
int difference = INT32_MAX;

int arr[11];
int brr[11];
int choosea[11];
int chooseb[11];

void dfs(int x) {
    if (x > n) {
        int sour = 1, ku = 0;
        for (int i = 1; i <= n; i++) {       
            if (choosea[i] == 1 && chooseb[i] == 1) {
                tl = true;
                sour *= arr[i];
                ku += brr[i];
            }
        }
        if (tl==true) {
            int d = abs(sour - ku);
            difference = min(d, difference);
            tl = false;
        }

        return;

    }

    choosea[x] = 1;
    chooseb[x] = 1;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

    choosea[x] = 2;
    chooseb[x] = 2;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

}


int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &arr[i], &brr[i]);
    }
    dfs(1);
    cout << difference;
    return 0;
}
```



### æ´›è°·p1135

dfsè¶…æ—¶ï¼Œæˆ‘è¯·é—®å‘¢ï¼Œéè¦å¡ä¸€ä¸ªæ•°æ®å‘œå‘œå‘œ

```c++
#include<iostream>
using namespace std;
int N,A,B;
int arr[210];
int res=1e9;
bool st[210];//è®¾ç½®çŠ¶æ€
//å‰ªæï¼Œå½“æ¯å±‚æ¥¼åªå»è¿‡ä¸€æ¬¡ï¼Œæ˜¯æœ€å¥½çš„çŠ¶æ€
//xä»£è¡¨å½“å‰å±‚æ•°ï¼Œcntè¡¨ç¤ºæŒ‰æŒ‰é’®çš„æ¬¡æ•°
void dfs(int x,int cnt){
    if(cnt>=res){
        //å‰ªæ
        return ;
    }
    
    if(x<0||x>N) return ;
    if(x==B){
        res=min(res,cnt);
        return;
    }
    
    //bfsçš„ç²¾é«“å°±æ˜¯æš´åŠ›æœç´¢
    //æ‰€ä»¥å½“x+arr[x]<nçš„æ—¶å€™éƒ½å¯ä»¥è¿›è¡Œæœç´¢ä½ 
    if(arr[x]+x<=N&&!st[x+arr[x]]){
        st[x+arr[x]]=true;
        dfs(x+arr[x],cnt+1);
        st[x+arr[x]]=false;
    }
    
    if(x-arr[x]>0){
         st[x-arr[x]]=true;
        dfs(x-arr[x],cnt+1);
        st[x-arr[x]]=false;
    }
    
}
int main(){
    cin>>N>>A>>B;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
    }
    
    dfs(A,0);
    if(res==1e9) 
    {cout<<"-1";
    return 0;
    }
    cout<<res;

    return 0;
}

```



### åŠ›æ‰£257äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

```c++
//ä½¿ç”¨äº†æ·±åº¦ä¼˜å…ˆæœç´¢
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string>paths;
        func(root,"",paths);
        return paths;
    }
    void func(TreeNode*root,string path,vector<string>&paths){//è¿™é‡Œrootæ²¡æœ‰ç”¨å¼•ç”¨æ˜¯å› ä¸ºrootä¸éœ€è¦ä¿®æ”¹
        if(root!=nullptr){
            path+=to_string(root->val);
            if(root->left==nullptr&&root->right==nullptr){
                paths.push_back(path);
            }
            else{
                path+="->";
                func(root->left,path,paths);//è¿™é‡Œpathæ²¡æœ‰ç”¨å¼•ç”¨æ˜¯å› ä¸ºpathæ¯æ¬¡éƒ½æ˜¯+=ï¼Œæ„é€ äº†ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²æ’å…¥åˆ°pathsä¸­
                func(root->right,path,paths);
            }
        }
    }
};
```



### p1135å¥‡æ€ªçš„ç”µæ¢¯

æ·±åº¦ä¼˜å…ˆæœç´¢çš„æŒ‡æ•°å‹æšä¸¾æ¨¡å‹ï¼Œåªæœ‰ä¸Šä¸‹å’Œæœªç¡®å®šä¸‰ç§çŠ¶æ€

åˆ«äººå†™çš„dfs

```c++
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k[201],dis[201];
void dfs(int node,int step){
	dis[node]=step;//ä¸€å®šå¯ä»¥æ›´æ–°
	int v=node-k[node];
	if(1<=v&&step+1<dis[v]/*å¯ä»¥æ›´æ–°åœ¨æœç´¢*/)//ä¸‹
		dfs(v,step+1);
	v=node+k[node];
	if(v<=n&&step+1<dis[v])//ä¸Š
		dfs(v,step+1);
	return;
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
		cin>>k[i];
	dfs(a,0);
	cout<<(dis[b]==0x3f3f3f3f?-1:dis[b]);
	return 0;
}==
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 210;
int a[N];    //æ¯å±‚æ¥¼è‡³å¤šèµ°ä¸€æ¬¡ä¸ºæ¬¡æ•°æœ€å°‘
int start, end1, n;
bool find1 = false;
int st[N];
int res=1e9;
void dfs(int i, int sum)
{
    if (sum < 1 ||sum > n||i>=res) return;
    else if (sum == end1)
    {
        find1 = true;
        res=min(res,i);
        return;
    }
    else{ 
        if(st[sum]>i||st[sum]==0) 
        {
            st[sum]=i;
            dfs(i + 1, sum + a[sum]);   //ç”µæ¢¯ä¸Šè¡Œ 
            dfs(i + 1, sum - a[sum]);//ç”µæ¢¯ä¸‹è¡Œ
        }
        else return;
    }
}
int main()
{
    scanf("%d %d %d", &n, &start, &end1);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    dfs(0, start);
    if (!find1) printf("-1");
    else printf("%d",res);
    return 0;
}
```



### åŠ›æ‰£980ä¸åŒè·¯å¾„III

dfsè§£é¢˜å…³é”®ï¼šå›æº¯

# è¿·å®«æ¨¡å‹

1. **çŠ¶æ€è¡¨ç¤º**ï¼šé¦–å…ˆéœ€è¦å®šä¹‰è¿·å®«çš„çŠ¶æ€è¡¨ç¤ºã€‚å¸¸è§çš„æ–¹æ³•æ˜¯ä½¿ç”¨äºŒç»´æ•°ç»„ï¼Œå…¶ä¸­0è¡¨ç¤ºå¯é€šè¡Œçš„è·¯å¾„ï¼Œ1è¡¨ç¤ºå¢™å£æˆ–ä¸å¯é€šè¡Œçš„åŒºåŸŸã€‚åŒæ—¶éœ€è¦ä¸€ä¸ªèµ·ç‚¹å’Œç»ˆç‚¹è¡¨ç¤ºå…¥å£å’Œå‡ºå£çš„ä½ç½®ã€‚
2. **é€’å½’æœç´¢**ï¼šä»èµ·ç‚¹å¼€å§‹ï¼ŒæŒ‰ç…§ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘è¿›è¡Œé€’å½’æœç´¢ã€‚æ¯æ¬¡ç§»åŠ¨åˆ°ä¸€ä¸ªæ–°ä½ç½®æ—¶ï¼Œéƒ½ä¼šæ£€æŸ¥æ˜¯å¦åˆ°è¾¾äº†ç»ˆç‚¹ã€‚å¦‚æœæ²¡æœ‰åˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ™ç»§ç»­ä»å½“å‰ä½ç½®è¿›è¡Œæœç´¢ã€‚
3. **å›æº¯æ¡ä»¶**ï¼šåœ¨æœç´¢è¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°æ­»è·¯æˆ–è€…å·²ç»è®¿é—®è¿‡çš„ä½ç½®ï¼Œå°±éœ€è¦è¿›è¡Œå›æº¯ã€‚è¿™æ—¶ä¼šè¿”å›åˆ°å‰ä¸€ä¸ªä½ç½®ï¼Œå°è¯•å…¶ä»–æ–¹å‘çš„è·¯å¾„ã€‚
4. **è®°å½•è·¯å¾„**ï¼šä¸ºäº†é¿å…é‡å¤èµ°åŒä¸€æ¡è·¯å¾„ï¼Œéœ€è¦è®°å½•å·²ç»è®¿é—®è¿‡çš„ä½ç½®ã€‚ä¸€ç§å¸¸è§çš„åšæ³•æ˜¯ç”¨2æ¥æ ‡è®°å·²ç»èµ°è¿‡çš„å¯é€šè¡Œè·¯å¾„ã€‚
5. **æ±‚è§£æ–¹æ³•**ï¼šé™¤äº†å›æº¯æ³•ï¼Œè¿˜å¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰æˆ–å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ç­‰å…¶ä»–å›¾æœç´¢ç®—æ³•æ¥è§£å†³è¿·å®«é—®é¢˜ã€‚æ¯ç§æ–¹æ³•éƒ½æœ‰å…¶ä¼˜ç¼ºç‚¹ï¼Œä¾‹å¦‚DFSåŠ å›æº¯å¯èƒ½ä¸ä¼šç›´æ¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œè€ŒBFSå¯ä»¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œä½†éœ€è¦è®°å½•æ›´å¤šçš„èŠ‚ç‚¹ä¿¡æ¯ã€‚

### dfsæ±‚è§£è¿·å®«æœ€çŸ­è·¯å¾„é—®é¢˜

```c++
#include<iostream>
#include<queue>
#include<vector>
using namespace std;


const int N = 110;
int map[N][N];
bool st[N][N];
int row, colum, endx, endy;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,-1,0,1 };
int res = INT_MAX;
void dfs(int x, int y,int step) {
    //x yä»£è¡¨å½“å‰åæ ‡
    if (x == endx && y == endy) {
        res = min(res, step);
        return;
    }

    for (int i = 0; i < 4; i++) {
        int la = x + dx[i];
        int lb = y + dy[i];
        if (st[la][lb] == 1) continue;
        if (la<1 || lb<1 || la>row || lb>colum) continue;
        if (map[la][lb] == 1) continue;
        st[la][lb] = 1;
        dfs(la, lb, step + 1);
        st[la][lb] = 0;
    }
}
int main() {
  
    cin >> row >> colum;
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            cin >> map[i][j];
        }
    }

    endx = row;
    endy = colum;
    st[1][1] = 1;
    dfs(1, 1,0);
    cout << res;
    return 0;
}

```

### dfsåŠ è®°å¿†åŒ–é€’å½’è¿·å®«é—®é¢˜

```c++

```



### bfsæ±‚è§£è¿·å®«æœ€çŸ­è·¯å¾„

1. **å®šä¹‰è¿·å®«çš„å¤§å°å’ŒçŠ¶æ€ï¼š** å®šä¹‰è¿·å®«çš„å¤§å°å¹¶ç¡®å®šè¿·å®«ä¸­æ¯ä¸ªä½ç½®çš„çŠ¶æ€ï¼Œå¦‚å¢™å£ã€å¯é€šè¡Œè·¯å¾„ç­‰ã€‚
2. **å®šä¹‰åæ ‡ç»“æ„ä½“å’Œæ–¹å‘æ•°ç»„ï¼š** å®šä¹‰ä¸€ä¸ªç»“æ„ä½“æ¥è¡¨ç¤ºè¿·å®«ä¸­æ¯ä¸ªä½ç½®çš„åæ ‡ï¼ŒåŒæ—¶å®šä¹‰ä¸€ä¸ªæ–¹å‘æ•°ç»„ï¼Œç”¨æ¥æŒ‡ç¤ºæ¯ä¸ªä½ç½®å¯ä»¥ç§»åŠ¨çš„æ–¹å‘ï¼Œå¦‚ä¸Šã€å³ã€ä¸‹ã€å·¦ã€‚
3. **ç¼–å†™åˆæ³•æ€§æ£€æŸ¥å‡½æ•°ï¼š** ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€æŸ¥ç»™å®šçš„åæ ‡æ˜¯å¦åˆæ³•ï¼Œå³æ˜¯å¦åœ¨è¿·å®«çš„èŒƒå›´å†…ä¸”å¯¹åº”çš„çŠ¶æ€ä¸ºå¯é€šè¡Œè·¯å¾„ã€‚å…¶ä¸­æœ‰ï¼šè¶Šç•Œæ£€æŸ¥ï¼Œåœ°å›¾æ£€æŸ¥æ˜¯å¦å·²ç»è®¿é—®è¿‡ï¼Œåœ°å›¾æ£€æŸ¥æ˜¯å¦æ˜¯éšœç¢ç‰©ï¼Œæ˜¯å¦æ˜¯ç»ˆç‚¹æ£€æŸ¥ï¼Œå¦‚æœæ˜¯ç»ˆç‚¹å°±è¦è¿”å›ã€‚

4. **ä½¿ç”¨é˜Ÿåˆ—è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼š**
   - åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨äºä¿å­˜å¾…æ¢ç´¢çš„ä½ç½®ã€‚
   - å°†è¿·å®«çš„èµ·å§‹ä½ç½®åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚
   - è¿›å…¥å¾ªç¯ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºæˆ–è€…æ‰¾åˆ°äº†ç»ˆç‚¹ã€‚
   - åœ¨æ¯æ¬¡å¾ªç¯ä¸­æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
     - ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªä½ç½®ï¼Œå³é˜Ÿå¤´çš„å…ƒç´ ï¼Œä½œä¸ºå½“å‰æ¢ç´¢çš„ä½ç½®ã€‚
     - åˆ¤æ–­å½“å‰ä½ç½®æ˜¯å¦ä¸ºç»ˆç‚¹ä½ç½®ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æœç´¢ç»“æŸï¼Œç®—æ³•æˆåŠŸæ‰¾åˆ°äº†é€šå‘ç»ˆç‚¹çš„è·¯å¾„ï¼Œç»“æŸå¾ªç¯ã€‚
     - å°†å½“å‰ä½ç½®æ ‡è®°ä¸ºå·²è®¿é—®è¿‡çš„çŠ¶æ€ï¼Œä»¥é¿å…é‡å¤è®¿é—®ã€‚
     - æ¢ç´¢å½“å‰ä½ç½®å‘¨å›´çš„æ‰€æœ‰ç›¸é‚»ä½ç½®ï¼Œå¹¶å°†æœªè®¿é—®è¿‡çš„ç›¸é‚»ä½ç½®åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚
   - é‡å¤æ‰§è¡Œä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºï¼ˆè¡¨ç¤ºæ²¡æœ‰é€šå‘ç»ˆç‚¹çš„è·¯å¾„ï¼‰æˆ–è€…æ‰¾åˆ°äº†ç»ˆç‚¹ã€‚
5. **è®°å½•è·¯å¾„ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰ï¼š** å¦‚æœéœ€è¦è®°å½•è·¯å¾„ä¿¡æ¯ï¼Œå¯ä»¥åœ¨æ‰¾åˆ°ç»ˆç‚¹åè¿›è¡Œå›æº¯ï¼Œä»ç»ˆç‚¹å¼€å§‹ï¼Œæ ¹æ®å·²ç»è®°å½•çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯é€†å‘å›æº¯åˆ°èµ·ç‚¹ï¼Œå³å¯å¾—åˆ°å…·ä½“çš„è·¯å¾„ä¿¡æ¯ã€‚
6. **è¿”å›æœç´¢ç»“æœï¼š** å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™è¯´æ˜æ²¡æœ‰æ‰¾åˆ°é€šå‘ç»ˆç‚¹çš„è·¯å¾„ï¼Œæœç´¢å¤±è´¥ï¼›å¦‚æœæ‰¾åˆ°äº†ç»ˆç‚¹ï¼Œåˆ™æœç´¢æˆåŠŸï¼Œç®—æ³•ç»“æŸã€‚

```c++

#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
typedef pair<int, int> PII;

const int N = 110;
char map[N][N];
bool st[N][N];
PII parent[N][N]; // è®°å½•æ¯ä¸ªç‚¹çš„çˆ¶èŠ‚ç‚¹åæ ‡
int row, colum, endx, endy;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,-1,0,1 };

void bfs(int x, int y) {
    queue<PII> q;
    q.push({ x,y });
    st[x][y] = true;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == endx && t.second == endy) return; // æ‰¾åˆ°ç»ˆç‚¹ç›´æ¥è¿”å›
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a < 1 || a > row || b < 1 || b > colum) continue;
            if (st[a][b] || map[a][b] == '1') continue;
            st[a][b] = true;
            parent[a][b] = t;//è¯¥æ‹“å±•ç‚¹çš„çˆ¶èŠ‚ç‚¹æ˜¯t
            q.push({ a,b });
        }
    }
}

int main() {
    cout << "è¯·è¾“å…¥è¿·å®«çš„è¡Œå’Œåˆ—" << endl;
    cin >> row >> colum;
    cout << "è¯·è¾“å…¥è¿·å®«çš„ç»ˆç‚¹åæ ‡" << endl;
    cin >> endx >> endy;
    cout << "è¯·è¾“å…¥è¿·å®«ï¼Œå…¶ä¸­1è¡¨ç¤ºéšœç¢ç‰©ï¼Œ0è¡¨ç¤ºå¯è¡Œ" << endl;
    for (int i = 1; i <= row; i++) {
        scanf("%s", map[i] + 1);
    }
    bfs(1, 1);

    if (!st[endx][endy]) {//æ²¡æœ‰è§£çš„è¯ï¼Œå°±æ²¡æœ‰èµ°è¿‡ç»ˆç‚¹ï¼Œåˆ™ç»ˆç‚¹çŠ¶æ€ä¸ºfalse
        cout << "æ²¡æœ‰è§£ï¼" << endl;
        return 0;
    }

    vector<PII> path;
    PII cur = { endx, endy };
    while (cur.first != 0 && cur.second != 0) { // ä»ç»ˆç‚¹å›æº¯åˆ°èµ·ç‚¹
        path.push_back(cur);
        cur = parent[cur.first][cur.second];
    }
    reverse(path.begin(), path.end()); // åè½¬è·¯å¾„ï¼Œå¾—åˆ°ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„

    cout << "æœ€çŸ­è·¯å¾„ä¸ºï¼š" << endl;
    for (auto p : path) {
        cout << '(' << p.first << ',' << p.second << ')' << "->";
    }
    cout << '(' << endx << ',' << endy << ')' << endl; // æ‰“å°ç»ˆç‚¹

    return 0;
}

```



### æ´›è°·p1683è¿·å®«æ¨¡å‹



```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
const int N = 30;
int W, H;
char map[N][N];
int st[N][N];//è®°å½•çŠ¶æ€
int res;
int mx[4] = { -1,0,1,0 };
int my[4] = { 0,1,0,-1 };
void dfs(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx > H || ly < 0 || ly >=W) continue;
        if (st[lx][ly]) continue;
        if (map[lx][ly] != '.')continue;
        st[lx][ly] = 1;
        res++;
        dfs(lx,ly);        
    }
}

int main() {
    int x, y;
    scanf("%d %d", &W, &H);
    for (int i = 0; i < H; i++) {
        scanf("%s", map[i]);
    }
    for (int i = 0; i < H; i++) {
        for (int j = 0; j < W; j++) {
            if (map[i][j] == '@') {
               
                st[i][j] = 1;
                dfs(i, j);
                break;
            }
        }
    }

    printf("%d", ++res);
    return 0;
}
```

### æ´›è°·p1596æ´ªæ°´å¡«å……æ¨¡å‹

å…«è¿é€šæŒ‡çš„æ˜¯å¯ä»¥èµ°æ–œçº¿ï¼Œå¥½æš´åŠ›çš„åšæ³•...æ‰€ä»¥dfsåªèƒ½ç”¨äºä¸€äº›æ•°æ®è¾ƒå°‘çš„åœ°æ–¹å§

```c++
#include<iostream>
#include<string>
using namespace std;
const int n = 100;
int N, M;
int mx[] = { 1,1,1,0,0,-1,-1,-1 };
int my[] = { -1,0,1,1,-1,1,0,-1 };
bool st[n][n];
string s[n];
int res;
void dfs(int x, int y) {

    for (int i = 0; i < 8; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx >= N || ly < 0 || ly >= M) continue;
        if (s[lx][ly] != 'W') continue;
        if (st[lx][ly]) continue;
        st[lx][ly] = true;
        dfs(lx, ly);//ä¸éœ€è¦å›æº¯ï¼Œæ´ªæ°´æ¨¡å‹ï¼Œè¦†æ°´éš¾æ”¶
    }

}
int main() {
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> s[i];
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (s[i][j] == 'W' && !st[i][j]) {
                //æ‰¾åˆ°äº†ç¬¬ä¸€ä¸ªw
                s[i][j]=true;
                dfs(i, j);
                res++;
            }
        }
    }
    cout << res;
    return 0;
}

```



### ACW1114æ£‹ç›˜é—®é¢˜

å¯¹äºæœ¬é¢˜ï¼Œæˆ‘ä»¬è‡ªç„¶æƒ³åˆ°çš„æ˜¯é‡åˆ°ä¸€ä¸ªå¯ä»¥æ”¾æ£‹å­çš„ä½ç½®ï¼Œæ”¾æ£‹å­ï¼Œç„¶ååˆ°å…¶ä»–è¡Œå¹¶ä¸”å…¶ä»–åˆ—çš„åœ°æ–¹å»æ‰¾ç¬¬äºŒä¸ªå¯ä»¥æ”¾æ£‹å­çš„ä½ç½®ã€‚



```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 10;
int n,k,cnt;
bool st[N];
int res;
string arr[N];//è®°å½•ç­”æ¡ˆçš„æ•°ç»„
void dfs(int x,int cnt) {
    if(cnt==k){
        res++;
        return;
    }
    
    if(x>n) return;
    for (int i = 0; i <n; i++) {
        if(!st[i]&&arr[x][i]=='#'){//è¿™é‡Œçš„iè¡¨ç¤ºåˆ—ï¼ï¼
            st[i]=true;
            dfs(x+1,cnt+1);
            st[i]=false;
        }
    }
    
    dfs(x+1,cnt);
}
int main() {
    while( cin >> n>>k,n>0&&k>0){
        for(int i=1;i<=n;i++){
            cin>>arr[i];
        }
        res=0;//æ³¨æ„è¿™é‡Œï¼Œå› ä¸ºæ˜¯å¤šç»„æ ·ä¾‹è¾“å‡ºï¼Œæ‰€ä»¥resè¦æ›´æ–°
        dfs(1,0);
        cout<<res<<endl;
    }

    return 0;
}

```



### æ´›è°·p1019

1. è®¾ç½®ä¸€ä¸ªè®°å½•å•è¯ä½¿ç”¨æ¬¡æ•°çš„æ•°ç»„ï¼Œä»¥ä¾¿åˆ¤æ–­å•è¯çš„ä½¿ç”¨æ¬¡æ•°æ˜¯å¦å¤§äº2
2. è®¾ç½®ä¸€ä¸ªæ•°ç»„æ¥è®°å½•å•è¯ä¹‹é—´çš„å¯æ‹¼æ¥çš„æœ€çŸ­é•¿åº¦ï¼Œå½“æ—¶æ˜¯æœ€çŸ­æ‹¼æ¥é•¿åº¦ï¼Œæ¯æ¬¡å–é‡åˆæœ€çŸ­çš„ï¼Œå¯ä»¥ä½¿å•è¯æœ€é•¿
3. å½“å¼€å§‹æ‰¾åˆ°é¾™çš„æ—¶å€™ï¼Œå¼€å§‹æš´åŠ›æœç´¢

```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 20;
int n;
string arr[N];
int used[N];//æ¯ä¸ªæ•°ç»„ä½¿ç”¨çš„æ¬¡æ•°
int cnt[N][N];//å•è¯iä¸å•è¯jçš„å¯æ‹¼æ¥çš„é•¿åº¦
int ans;
void dfs(string s, int x) {
    ans = max(int(s.size()), ans);
    used[x]++;//å½“å‰å•è¯ä½¿ç”¨æ¬¡æ•°åŠ ä¸€
    for (int i = 0; i < n; i++) {
        if (cnt[x][i] && used[i] < 2) {//åˆ¤æ–­æ¡ä»¶ï¼Œå¦‚æœä¸¤ä¸ªå•è¯ä¹‹é—´å¯ä»¥æ‹¼æ¥å¹¶ä¸”è¿™ä¸ªå•è¯æ²¡æœ‰ä½¿ç”¨ä¸¤æ¬¡ä»¥ä¸Š
            dfs(s + arr[i].substr(cnt[x][i]), i);
        }
    }

    used[x]--;//å›æº¯ï¼Œå› ä¸ºè¦æ‰¾å‡ºæœ€é•¿è·ç¦»
}
int main() {
    char start;

    cin >> n;
    string dargon;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    cin >> start;//é¾™å¤´

    //é¢„å¤„ç†
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            string a = arr[i], b = arr[j];
            for (int k = 1; k < min(a.size(), b.size()); k++) {//æ³¨æ„è¿™é‡Œï¼Œkå¿…é¡»ä»1å¼€å§‹å–
                //æ‰¾åˆ°ä¸€ä¸ªå•è¯çš„åç¼€å’Œå¦ä¸€ä¸ªå•è¯çš„å‰ç¼€ç›¸åŒ
                if (a.substr(a.size() - k, k) == b.substr(0, k)) {
                    //ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ä¸€å®šæ˜¯æœ€çŸ­çš„ï¼Œå› ä¸ºé»˜è®¤æœ€çŸ­é•¿åº¦æ˜¯1å¹¶ä¸”é€’å¢
                    cnt[i][j] = k;
                    break;
                }
            }

        }
    }

    for (int i = 0; i < n; i++) {
        if (arr[i][0] == start) {
            dfs(arr[i], i);//åˆ†åˆ«æ˜¯é¾™å’Œå½“å‰è®¿é—®åˆ°äº†å“ªä¸ªå•è¯
        }
    }
    cout << ans;
    return 0;
}
```



### æ´›è°·p1025

```c++
#include<iostream>
#include<string>
using namespace std;
int n, k;
int res;
int numsum;
int arr[210];
//ç»„åˆå‹ï¼Œä½†æ˜¯ä¸‹ä¸€æ¬¡å¼€å§‹æšä¸¾å¯ä»¥æ˜¯1
void dfs(int x, int start, int numsum) {
    if (x > k) {
        if (numsum == n) {
            res++;     
        }
          return;
    }


    for (int i = start;numsum+i*(k-x+1)<=n; i++) {//å› ä¸ºä¹‹ååˆ’åˆ†çš„ä¸€å®šå¤§äºç­‰äºiï¼Œå¦‚æœå‰©ä¸‹çš„ä½æ•°
        //å…¨æ˜¯içš„è¯è¿˜å¤§äºnï¼Œä¸€å®šä¸ç¬¦åˆæƒ…å†µ
        //æšä¸¾kä¸ªæ•°å­—
        arr[x] = i;
        dfs(x + 1, i, numsum+i);
        arr[x] = 0;
    }
}
int main() {
    cin >> n >> k;
    dfs(1, 1, 0);//ä»1,1å¼€å§‹æšä¸¾
    cout << res;
    return 0;
}

```

### æ´›è°·P1162

æ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆç»“åˆå“¦

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<string>
using namespace std;
typedef  pair<int, int> PII;
queue<PII> q;
const int n = 35;
int N;
int mx[] = { 0,1,0,-1 };
int my[] = { 1,0,-1,0 };
bool st[n][n];//çŠ¶æ€æ•°ç»„
int map[n][n];//åœ°å›¾
bool bfs(int x, int y) {
    q.push({ x,y });
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == 1 || t.second == 1 || t.first == N || t.second == N) {
            //åˆ°è¾¾è¾¹ç•Œ
            return true;//å¯è¾¾
        }
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b] == 1) continue;
            if (st[a][b]) continue;
            //ä¸å­˜åœ¨è¶Šç•Œé—®é¢˜
            st[a][b] = true;
            q.push({ a,b });
        }
    }
    return false;
}

void dfs(int x, int y) {
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b]==2||map[a][b]==1) continue;
            if (a < 2 || b < 2 || a >= N || b >= N) continue;
            //if (st[a][b]) continue;
            //ä¸å­˜åœ¨è¶Šç•Œé—®é¢˜
            //st[a][b] = true;
            map[a][b] = 2;
            dfs(a, b);
        }
}
int main() {
    cin >> N;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            scanf("%d", &map[i][j]);
        }
        
    }

    bool flag = false;
    for (int i = 1; i <= N; i++) {
        if (flag == true) break;
        for (int j = 1; j <= N; j++) {
            if (map[i][j] == 0 && i != 1 && i != N && j != 1 && j != N) {
                bool res=bfs(i, j);
               
                if (!res)
                {
                    map[i][j] = 2;
                    dfs(i, j);
                    flag = true;
                    break;
                }
                
            }
        }
    }

    cout << endl;
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            cout << map[i][j] << ' ';
        }
        cout << endl;
         
    }
    return 0;
}



```





# å¹¿åº¦ä¼˜å…ˆ

### [äº‘å‰ªè´´æ¿ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/paste/sa0zary9)



### æ´›è°·p2658æ±½è½¦æ‹‰åŠ›èµ›

äºŒåˆ†æŸ¥æ‰¾+bfs

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
int high[510][510];
int flag[510][510];
bool st[510][510];
typedef pair<int, int>PII;
int x, y;
int row, colum;
int flag_cnt = 0;
PII q[510 * 510];//bfsçš„é˜Ÿåˆ—
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
bool check(int mid) {
    q[0] = { x,y };//å…¥é˜Ÿ
    int cnt = 1;
    int hh = 0, tt = 0;
    st[x][y]=true;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a<1 || a>row || b<1 || b>colum) continue;
            if (st[a][b]) continue;
            if (abs(high[a][b] - high[t.first][t.second]) > mid) continue;
            st[a][b] = true;
            q[++tt] = { a,b };
            if (flag[a][b] == 1) {
                cnt++;
                  if (cnt == flag_cnt) return true;   
            }         
        }
    }
    return false;
}

int main() {
    cin >> row >> colum;
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &high[i][j]);
        }
    }

    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &flag[i][j]);
            
            if (flag[i][j] == 1) {
                flag_cnt++;
                x = i, y = j;
            }
        }
    }

    int l = -1, r = 10000000010;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        memset(q, 0, sizeof q);
        memset(st, false, sizeof st);
        if (check(mid)) r = mid;
        else l = mid;
    }
    cout << r;

    return 0;

}



```

### æ´›è°·p4554åŒç«¯é˜Ÿåˆ—è§£å†³

æ¨¡æ‹Ÿå¯çŸ¥ï¼Œæˆ‘ä»¬æ¯æ¬¡éƒ½æƒ³èµ°è´¹ç”¨ä¸ºé›¶çš„è·¯ï¼Œå³æ¯æ¬¡éƒ½ä¼˜å…ˆæŠŠè´¹ç”¨ä¸ºé›¶çš„èŠ‚ç‚¹å…¥é˜Ÿ

```c++
#include<iostream>
#include<deque>
#include<cstring>
using namespace std;
typedef pair<int,int> PII;
int n,m,x1,y1,x2,y2;
string map[510];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
deque<PII>q;
int dis[510][510];
int bfs(int x,int y){
    //å…¥é˜Ÿèµ·ç‚¹
    q.push_back({x,y});
    dis[x][y]=0;//è®¾ç½®èµ·ç‚¹è·ç¦»èµ·ç‚¹çš„è·ç¦»æ˜¯é›¶
    while(!q.empty()){
        auto t=q.front();//è·å–å½“å‰é˜Ÿå¤´å…ƒç´ 
        q.pop_front();//æ¯æ¬¡ä¼˜å…ˆè®¿é—®è´¹ç”¨ä¸ºé›¶çš„èŠ‚ç‚¹
        char ch=map[t.first][t.second];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(dis[a][b]>=0) continue;
           
            if(map[a][b]==ch){
                q.push_front({a,b});
                dis[a][b]=dis[t.first][t.second];
            }
            if(map[a][b]!=ch){
                q.push_back({a,b});
                dis[a][b]=dis[t.first][t.second]+1;
            }
          
            if(a==x2&&b==y2) return dis[a][b];
        }
    }
  return -1;
}
int main(){
    while(cin>>n>>m,n||m){//é€—å·è¿ç®—ç¬¦ï¼Œä¼šæ‰§è¡Œä¸¤ä¸ªæ“ä½œæ•°ï¼Œå¹¶è¿”å›æœ€åä¸€ä¸ªæ“ä½œæ•°çš„ç»“æœä½œä¸ºè¿”å›å€¼
        for(int i=0;i<n;i++){
            cin>>map[i];
        }
        
        //æ¯æ¬¡éå†éƒ½éœ€è¦é‡æ–°è®¾ç½®è·ç¦»ä¸ºæ²¡æœ‰è®¿é—®è¿‡
        memset(dis,-1,sizeof dis);
        q.clear();
        cin>>x1>>y1>>x2>>y2;
        int res=bfs(x1,y1);
        cout<<res<<endl;
    }
    return 0;
}
```

### p1746ç¦»å¼€ä¸­å±±è·¯

```c++
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int,int>PII;
PII q[1010*1010];
char map[1010][1010];
int dis[1010][1010];
int vis[1010][1010];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
int n,x1,y1,x2,y2;
int bfs(){
    memset(dis,-1,sizeof dis);
    memset(vis,-1,sizeof vis);
    q[0]={x1,y1};
    q[1]={x2,y2};
    dis[x1][y1]=0;
    dis[x2][y2]=0;
    vis[x1][y1]=1;
    vis[x2][y2]=2;
    int hh=0,tt=1;
    while(hh<=tt){
        auto t=q[hh++];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<1||a>n||b<1||b>n) continue;
            if(map[a][b]=='1') continue;
            if(vis[a][b]+vis[t.first][t.second]==3){
                return dis[a][b]+dis[t.first][t.second]+1;
            }
            if(dis[a][b]>0) continue;
            dis[a][b]=dis[t.first][t.second]+1;
            if(vis[a][b]==-1){
                vis[a][b]=vis[t.first][t.second];
            }
            q[++tt]={a,b};//è¿™é‡Œä½¿å¾—é˜Ÿåˆ—æ˜¯äº¤æ›¿æ’å…¥èµ·ç‚¹å’Œç»ˆç‚¹çš„èŠ‚ç‚¹çš„
        }
    }
    return -1;
    
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%s",map[i]+1);
    }
    scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    int res=bfs();
    cout<<res;
    return 0;
}
```



### æ´›è°·p1379å…«æ•°ç éš¾é¢˜

```c++
#include<iostream>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//è®°å½•èµ°åˆ°è¯¥çŠ¶æ€éœ€è¦å¤šå°‘æ­¥
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    dist[start] = 0;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        if (t == end1) return dist[t];
        int distance = dist[t];
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//çŠ¶æ€å‹ç¼©,è½¬åŒ–ä¸ºçŸ©é˜µçš„ä¸‹æ ‡
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//æ¯æ¬¡äº¤æ¢ä¸Šä¸‹å·¦å³å››ä¸ªä½ç½®
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//è¶Šç•Œ
            int tmp = x2 * 3 + y2;//åˆè½¬åŒ–ä¸ºå­—ç¬¦ä¸²ä¸‹æ ‡
            swap(t[a], t[tmp]);//åœ¨å­—ç¬¦ä¸²ä¸­å°†è¿™ä¸¤ä¸ªä½ç½®äº’æ¢
            if (!dist.count(t)) {//å¦‚æœè¿™ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰è¯•è¿‡
                dist[t] = distance + 1;//è¯•ä¸€è¯•å˜›
                q.push(t);
            }
            swap(t[a], t[tmp]);//å›æº¯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    int res = bfs(start);
    cout << res;
    return 0;

}
```



åŒå‘é˜Ÿåˆ—ä¼˜åŒ–ä»£ç 

```c++


#include<iostream>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//è®°å½•èµ°åˆ°è¯¥çŠ¶æ€éœ€è¦å¤šå°‘æ­¥
unordered_map<string,int>vis;
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    q.push(end1);
    dist[start] = 0;
    dist[end1]=0;
    vis[start]=1;
    vis[end1]=2;
    
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        int flag=vis[t];//è®°å½•å½“å‰èŠ‚ç‚¹çš„æ ‡è®°
        int distance = dist[t];//è®°å½•å½“å‰èŠ‚ç‚¹åˆ°èµ·ç‚¹æˆ–ç»ˆç‚¹çš„è·ç¦»
        
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//çŠ¶æ€å‹ç¼©,è½¬åŒ–ä¸ºçŸ©é˜µçš„ä¸‹æ ‡
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//æ¯æ¬¡äº¤æ¢ä¸Šä¸‹å·¦å³å››ä¸ªä½ç½®
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//è¶Šç•Œ
            int tmp = x2 * 3 + y2;//åˆè½¬åŒ–ä¸ºå­—ç¬¦ä¸²ä¸‹æ ‡
            swap(t[a], t[tmp]);//ç°åœ¨çš„tæ˜¯æ‹“å±•çš„t
            
            if (vis[t]+flag==3){//å¦‚æœå½“å‰èŠ‚ç‚¹å’Œæ‹“å±•èŠ‚ç‚¹ç›¸é‡
                int res1=dist[t];
                swap(t[a],t[tmp]);
                int res2=dist[t];
                return res1+res2+1;
            }
            
            if (!dist.count(t)) {//å¦‚æœè¿™ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰è¯•è¿‡
                dist[t] = distance + 1;//è¯•ä¸€è¯•å˜›
                vis[t]=flag;
                q.push(t);
            }
   
            swap(t[a], t[tmp]);//å›æº¯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    if(start==end1){
        cout<<0;
        return 0;
    }
    int res = bfs(start);
    cout << res;
    return 0;

}
```

###   p2730é­”æ¿

```c++
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<string>
#include<unordered_map>
using namespace std;
unordered_map<string, int>dist;//èµ°åˆ°å½“å‰çŠ¶æ€éœ€è¦å‡ æ­¥
unordered_map<string, pair<char, string>>pre;
queue<string>q;
char arr[2][4];

void to_arr(string s) {
    for (int i = 0; i < 8; i++) {
        if (i < 4) {
            arr[0][i] = s[i];
        }
        else arr[1][7-i] = s[i];
    }
}

string To_string() {
    string res;
    for (int i = 0; i < 4; i++) {
        res += arr[0][i];
    }
    for (int i = 3; i >= 0; i--) {
        res += arr[1][i];
    }
    return res;
}

//äº¤æ¢ä¸Šä¸‹ä¸¤è¡Œ
string move0(string s) {
    to_arr(s);
    for (int i = 0; i < 4; i++) {
        swap(arr[0][i], arr[1][i]);
    }
    return To_string();
}

//å°†æœ€å³è¾¹çš„ä¸€åˆ—æ’å…¥æœ€å·¦è¾¹
string move1(string s) {
    to_arr(s);
    int a = arr[0][3], b = arr[1][3];
    for (int i = 3; i >= 1; i--) {
        for (int j = 0; j < 2; j++) {
            arr[j][i] = arr[j][i - 1];
        }
    }
    arr[0][0] = a;
    arr[1][0] = b;
    return To_string();
}

string move2(string s) {
    to_arr(s);
    int a = arr[0][2];
    arr[0][2] = arr[0][1];
    arr[0][1] = arr[1][1];
    arr[1][1] = arr[1][2];
    arr[1][2] = a;
    return To_string();
}



int bfs(string start, string end) {
    q.push(start);
    dist[start] = 0;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t == end) return dist[end];
        string m[3];
        m[0] = move0(t);
        m[1] = move1(t);
        m[2] = move2(t);
        for (int i = 0; i<3; i++) {
            string s = m[i];
            if (!dist.count(s)) {
                dist[s] = dist[t] + 1;
                pre[s] = {i + 'A',t};
                if (s == end) return dist[end];
                q.push(s);
            } 
           
        }
    }
    return -1;
}
int main() {
    int x;

    string end;
    string start;
    for (int i = 0; i < 8; i++) {
        cin >> x;
        start += char(x + '0');
        end += char(i + 1 + '0');
    }

    int res = bfs(start, end);
    cout << res << endl;
    string res2;
    while (end != start) {
        res2 += pre[end].first;
        end = pre[end].second;
    }
    reverse(res2.begin(), res2.end());
    if (res2.size()) {
        cout << res2;
    }
    return 0;
}

```

### p1443é©¬çš„éå†

bfsæœ‰å¾ˆå¤šç§å½¢å¼å•¦

```c++
#include<iostream>//P1443
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};//8ä¸ªæ–¹å‘
queue<pair<int,int> > q;
int f[500][500];//å­˜æ­¥æ•°
bool vis[500][500];//èµ°æ²¡èµ°è¿‡
int main()
{
	int n,m,x,y;
	memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
	cin>>n>>m>>x>>y;
	f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
	while(!q.empty())
	{
		int xx=q.front().first,yy=q.front().second;q.pop();//å–é˜Ÿé¦–å¹¶å‡ºé˜Ÿ
		for(int i=0;i<8;i++)
		{
			int u=xx+dx[i],v=yy+dy[i];
			if(u<1||u>n||v<1||v>m||vis[u][v])continue;//å‡ºç•Œæˆ–èµ°è¿‡å°±ä¸èµ°
		    vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
		}
	}
	for(int i=1;i<=n;i++)
	 {for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);printf("\n");}//æ³¨æ„åœºå®½ï¼ï¼
	return 0;
}
```



### åŠ›æ‰£p1747å¥½å¥‡æ€ªçš„æ¸¸æˆ

éå†äº†æ‰€æœ‰çš„æƒ…å†µï¼Œå”¯ç‹¬æ²¡æœ‰æƒ³åˆ°æ˜¯æ•°æ®èŒƒå›´å‡ºé—®é¢˜äº†ï¼Œç‰¢å¼Ÿï¼Œæˆ‘æƒ³æŠŠåœ°çƒä¸€æ‹³é”¤çˆ†

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int, int> PII;

int vis[25][25];
int dis[25][25];//åŠè®°å½•è·ç¦»
int mx[] = { -2,-2,-1,1,2,2,2,2,1,-1,-2,-1 };
int my[] = { -1,-2,-2,-2,-2,-1,1,2,2,2,2,1 };

int bfs(int x, int y) {
    if (x == 1 && y == 2 || x == 2 && y == 1) return 2;
    //ç»ˆç‚¹å’Œèµ·ç‚¹éƒ½æ˜¯å·²çŸ¥çš„ï¼ŒåŒå‘é˜Ÿåˆ—
    memset(dis, -1, sizeof dis);
    memset(vis, -1, sizeof vis);
    PII q[25 * 25];//å®šä¹‰åˆ—è¡¨

    q[0] = { x,y };
    q[1] = { 1,1 };
    dis[x][y] = 0;
    dis[1][1] = 0;
    vis[x][y] = 1;
    vis[1][1] = 2;
    int hh = 0, tt = 1;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 12; i++) {
            int a = t.first + mx[i], b = t.second + my[i];
            if (a<=1 || a>21 || b<=1 || b>21) continue;
          
            if (vis[a][b] + vis[t.first][t.second] == 3) {
                return dis[a][b] + dis[t.first][t.second] + 1;
            }
            if (dis[a][b] > 0) continue;
            dis[a][b] = dis[t.first][t.second] + 1;
            if (vis[a][b] == -1) vis[a][b] = vis[t.first][t.second];
            q[++tt] = { a,b };
        }
    }
    return -1;
}


int main() {
    int x1, y1, x2, y2;
    scanf("%d %d", &x1, &y1);
    scanf("%d %d", &x2, &y2);
    int res1 = bfs(x1, y1);
    int res2 = bfs(x2, y2);
    cout << res1 << endl;
    cout << res2 << endl;
    return 0;

}
```



### åŠ›æ‰£p2385

æˆ‘æ±‚æ±‚ä½ äº†ï¼Œæ•°æ®å¼€å¤§ä¸€ç‚¹å§ï¼Œè¦ä¸ç„¶ä½ åˆä»¥ä¸ºæ˜¯å“ªä¸ªåœ°æ–¹å†™é”™äº†ç„¶åæ”¹åŠå¤©å°ä¸‘ï¼











# å›¾

### 133å…‹éš†å›¾

é¢˜è§£1æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé¢˜è§£å·²ç»å†™çš„å¾ˆæ¸…æ¥šäº†ä¸€ä¸ªæ— å‘å›¾å®é™…åœ¨ä»£ç ä¸­å¦‚ä½•å­˜å‚¨ï¼š

![image-20240506194705392](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240506194705392.png)

é¢˜è§£2å¹¿æœï¼Œè¿˜æ˜¯è¦æ¨¡æ‹Ÿä¸€ä¸‹æ‰å¯ä»¥ï¼ï¼

### æœ€çŸ­è·¯å¾„é—®é¢˜

ç‹„å…‹æ–¯ç‰¹æ‹‰ç®—æ³•ï¼Œä¹¦ä¸Šç»™çš„ç®—æ³•ä¼šè¶…æ—¶ï¼Œä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <climits> // for INT_MAX
using namespace std;

int N, M;

void Dijkstra(vector<vector<pair<int, int>>>& adj, vector<long long>& res, vector<int>& ver) // Dijkstra algorithm
{
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    vector<int> s(N + 1, 0); // S[i] = 1 indicates vertex i is in S, S[i] = 0 indicates vertex i is in U

    res[1] = ver[1]; // Initialize the distance to the source vertex
    pq.push({ res[1], 1 });

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        if (s[u]) continue;
        s[u] = 1;

        for (auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (!s[v] && res[u] + weight + ver[v] < res[v]) {
                res[v] = res[u] + weight + ver[v];
                pq.push({ res[v], v });
            }
        }
    }
}

int main() {
    int a, b, c;
    cin >> N >> M;
    vector<int> ver(N + 1);
    vector<long long> res(N + 1, LLONG_MAX);
    res[1] = 0;

    for (int i = 1; i <= N; i++) {
        cin >> ver[i];
    }

    vector<vector<pair<int, int>>> adj(N + 1); // Adjacency list representation

    for (int i = 0; i < M; i++) {
        cin >> a >> b >> c;
        adj[a].push_back({ b, c });
        adj[b].push_back({ a, c }); // If the graph is undirected
    }

    Dijkstra(adj, res, ver);

    for (int i = 2; i <= N; i++) {
        if (res[i] == LLONG_MAX)
            cout << -1 << " "; // If there's no path to the node, output -1
        else
            cout << res[i] << " ";
    }
    cout << endl;

    return 0;
}

```



# æ¨¡æ‹Ÿé¢˜

### èŠ±ç”Ÿé‡‡æ‘˜

æˆ‘ä»¬å‡å®šå¤šå¤šåœ¨æ¯ä¸ªå•ä½æ—¶é—´å†…ï¼Œå¯ä»¥åšä¸‹åˆ—å››ä»¶äº‹æƒ…ä¸­çš„ä¸€ä»¶ï¼š

1. ä»è·¯è¾¹è·³åˆ°æœ€é è¿‘è·¯è¾¹ï¼ˆå³ç¬¬ä¸€è¡Œï¼‰çš„æŸæ£µèŠ±ç”Ÿæ¤æ ªï¼›
2. ä»ä¸€æ£µæ¤æ ªè·³åˆ°å‰åå·¦å³ä¸ä¹‹ç›¸é‚»çš„å¦ä¸€æ£µæ¤æ ªï¼›
3. é‡‡æ‘˜ä¸€æ£µæ¤æ ªä¸‹çš„èŠ±ç”Ÿï¼›
4. ä»æœ€é è¿‘è·¯è¾¹ï¼ˆå³ç¬¬ä¸€è¡Œï¼‰çš„æŸæ£µèŠ±ç”Ÿæ¤æ ªè·³å›è·¯è¾¹ã€‚

ç°åœ¨ç»™å®šä¸€å—èŠ±ç”Ÿç”°çš„å¤§å°å’ŒèŠ±ç”Ÿçš„åˆ†å¸ƒï¼Œè¯·é—®åœ¨é™å®šæ—¶é—´å†…ï¼Œå¤šå¤šæœ€å¤šå¯ä»¥é‡‡åˆ°å¤šå°‘ä¸ªèŠ±ç”Ÿï¼Ÿæ³¨æ„å¯èƒ½åªæœ‰éƒ¨åˆ†æ¤æ ªä¸‹é¢é•¿æœ‰èŠ±ç”Ÿï¼Œå‡è®¾è¿™äº›æ¤æ ªä¸‹çš„èŠ±ç”Ÿä¸ªæ•°å„ä¸ç›¸åŒã€‚



è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸‰ä¸ªæ•´æ•°ï¼Œğ‘€,ğ‘*M*,*N*å’Œğ¾*K*ï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼›è¡¨ç¤ºèŠ±ç”Ÿç”°çš„å¤§å°ä¸ºğ‘€Ã—ğ‘(1â‰¤ğ‘€,ğ‘â‰¤20)*M*Ã—*N*(1â‰¤*M*,*N*â‰¤20)ï¼Œå¤šå¤šé‡‡èŠ±ç”Ÿçš„é™å®šæ—¶é—´ä¸ºğ¾(0â‰¤ğ¾â‰¤1000)*K*(0â‰¤*K*â‰¤1000)ä¸ªå•ä½æ—¶é—´ã€‚æ¥ä¸‹æ¥çš„ğ‘€*M*è¡Œï¼Œæ¯è¡ŒåŒ…æ‹¬ğ‘*N*ä¸ªéè´Ÿæ•´æ•°ï¼Œä¹Ÿç”¨ç©ºæ ¼éš”å¼€ï¼›ç¬¬ğ‘–+1*i*+1è¡Œçš„ç¬¬ğ‘—*j*ä¸ªæ•´æ•°ğ‘ƒğ‘–ğ‘—(0â‰¤ğ‘ƒğ‘–ğ‘—â‰¤500)*P**ij*(0â‰¤*P**ij*â‰¤500)è¡¨ç¤ºèŠ±ç”Ÿç”°é‡Œæ¤æ ª(ğ‘–,ğ‘—)(*i*,*j*)ä¸‹èŠ±ç”Ÿçš„æ•°ç›®ï¼Œ00è¡¨ç¤ºè¯¥æ¤æ ªä¸‹æ²¡æœ‰èŠ±ç”Ÿã€‚

è¾“å‡ºæ ¼å¼

ä¸€ä¸ªæ•´æ•°ï¼Œå³åœ¨é™å®šæ—¶é—´å†…ï¼Œå¤šå¤šæœ€å¤šå¯ä»¥é‡‡åˆ°èŠ±ç”Ÿçš„ä¸ªæ•°ã€‚

æ ·ä¾‹ #1

```none
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
//è¾“å‡º37
```

æˆ‘è®¨åŒæ¨¡æ‹Ÿé¢˜å•Šå•Šå•Šå•Šå•Š

**æ‰¾åˆ°æ‰€æœ‰èŠ±ç”Ÿæ¤æ ª**ï¼šé¦–å…ˆéœ€è¦æ‰¾åˆ°æ‰€æœ‰æœ‰èŠ±ç”Ÿçš„æ¤æ ªï¼Œå¹¶æŒ‰èŠ±ç”Ÿæ•°é‡ä»å¤šåˆ°å°‘æ’åºã€‚

**æ¨¡æ‹Ÿé‡‡æ‘˜è¿‡ç¨‹**ï¼šä»ç¬¬ä¸€è¡Œè·³åˆ°æœ‰èŠ±ç”Ÿçš„æ¤æ ªï¼ŒæŒ‰ç…§èŠ±ç”Ÿæ•°é‡ä»å¤šåˆ°å°‘çš„é¡ºåºç§»åŠ¨ï¼Œè®°å½•æ€»æ—¶é—´å’Œé‡‡æ‘˜çš„èŠ±ç”Ÿæ•°é‡ï¼Œç›´åˆ°æ—¶é—´è€—å°½ã€‚

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;
int dx[4] = {-1,0,1,0};
int dy[4] = {0,1,0,-1};
struct peanut {
    int row;
    int col;
    int num;
};

bool com(const peanut& a, const peanut& b) {
    return a.num > b.num;
}
int main() {
    int n, m, k;
    cin >> n >> m >> k;
    vector<peanut>peanut_nums;
    vector<vector<int>>map(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> map[i][j];
            if (map[i][j] != 0) peanut_nums.push_back({ i,j,map[i][j] });
        }
    }

    sort(peanut_nums.begin(), peanut_nums.end(), com);
    int current_row=-1;
    int current_col = -1;
    int timeused = 0;
    int total = 0;


    for (auto p : peanut_nums) {
        int row = p.row;
        int col = p.col;
        if (current_col == -1 && current_row == -1) {
            timeused += row + 1;
        }

        else timeused += abs(current_row - row) + abs(current_col - col);

        timeused += 1;//é‡‡æ‘˜èŠ±è´¹çš„ä¸€ç§’

        if (timeused + row + 1 > k) break;
        total += p.num;
        current_col = col;
        current_row = row; 
    }
    cout << total;
    return 0;
}

```

### çºªå¿µå“åˆ†ç»„

è´ªå¿ƒåŠ æ¨¡æ‹Ÿï¼Œæˆ‘è®¨åŒæ¨¡æ‹Ÿå•Šå•Šå•Šå•Š

å…ƒæ—¦å¿«åˆ°äº†ï¼Œæ ¡å­¦ç”Ÿä¼šè®©ä¹ä¹è´Ÿè´£æ–°å¹´æ™šä¼šçš„çºªå¿µå“å‘æ”¾å·¥ä½œã€‚ä¸ºä½¿å¾—å‚åŠ æ™šä¼šçš„åŒå­¦æ‰€è·å¾— çš„çºªå¿µå“ä»·å€¼ç›¸å¯¹å‡è¡¡ï¼Œä»–è¦æŠŠè´­æ¥çš„çºªå¿µå“æ ¹æ®ä»·æ ¼è¿›è¡Œåˆ†ç»„ï¼Œä½†æ¯ç»„æœ€å¤šåªèƒ½åŒ…æ‹¬ä¸¤ä»¶çºªå¿µå“ï¼Œ å¹¶ä¸”æ¯ç»„çºªå¿µå“çš„ä»·æ ¼ä¹‹å’Œä¸èƒ½è¶…è¿‡ä¸€ä¸ªç»™å®šçš„æ•´æ•°ã€‚ä¸ºäº†ä¿è¯åœ¨å°½é‡çŸ­çš„æ—¶é—´å†…å‘å®Œæ‰€æœ‰çºªå¿µå“ï¼Œä¹ä¹å¸Œæœ›åˆ†ç»„çš„æ•°ç›®æœ€å°‘ã€‚

ä½ çš„ä»»åŠ¡æ˜¯å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾å‡ºæ‰€æœ‰åˆ†ç»„æ–¹æ¡ˆä¸­åˆ†ç»„æ•°æœ€å°‘çš„ä¸€ç§ï¼Œè¾“å‡ºæœ€å°‘çš„åˆ†ç»„æ•°ç›®ã€‚

è¾“å…¥æ ¼å¼

å…± ğ‘›+2 è¡Œï¼š ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ•´æ•° wï¼Œä¸ºæ¯ç»„çºªå¿µå“ä»·æ ¼ä¹‹å’Œçš„ä¸Šé™ã€‚ ç¬¬äºŒè¡Œä¸ºä¸€ä¸ªæ•´æ•° ğ‘›ï¼Œè¡¨ç¤ºè´­æ¥çš„çºªå¿µå“çš„æ€»ä»¶æ•° ğºã€‚ ç¬¬ 3âˆ¼*n*+2 è¡Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ­£æ•´æ•° ğ‘ƒğ‘– è¡¨ç¤ºæ‰€å¯¹åº”çºªå¿µå“çš„ä»·æ ¼ã€‚

è¾“å‡ºæ ¼å¼

ä¸€ä¸ªæ•´æ•°ï¼Œå³æœ€å°‘çš„åˆ†ç»„æ•°ç›®ã€‚

```none
100 
9 
90 
20 
20 
30 
50 
60 
70 
80 
90
//è¾“å‡º6
```

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;

int main() {
    int sum, n;
    cin >> sum >> n;
    vector<int>arr(n, 0);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    auto print = [](int element) {
        cout << element << " ";
        };
    sort(arr.begin(), arr.end());
    int len = arr.size();
    int cnt = 0;
    for (int i = 0, j = len-1; i <= j; ) {
        if (arr[j] + arr[i] > sum) {
            cnt++;
            j--;
        }
        else {
            cnt++;
            i++;
            j--;
        }
    }

    cout << cnt;
    return 0;
}

```

### å¯»å®

![image-20240717163455656](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240717163455656.png)

![image-20240717163512260](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240717163512260.png)

```
//è¾“å…¥ï¼š
2 3
1 2
0 3
1 4
0 1
1 5
1 2
1
//è¾“å‡º
5
```



å¯¹äºæœ¬é¢˜æ¥è¯´ï¼Œæœ€éš¾çš„å°±æ˜¯å¦‚ä½•æ‰¾åˆ°ç¬¬xä¸ªæœ‰æ¥¼æ¢¯çš„æˆ¿é—´

ä¸‹æ¬¡å†é‡åˆ°è¿™ç§é—®é¢˜ï¼Œä½ éœ€è¦ç”»å›¾ï¼Œä¸€èˆ¬è¿™ç§éƒ½æ˜¯ä¸€ä¸ªåœ†å½¢ï¼Œä¸€èˆ¬éƒ½éœ€è¦ä½¿ç”¨å–æ¨¡è¿ç®—

æ¯”å¦‚æœ¬é¢˜çš„ a = (a + 1 + m) % m;  // é€†æ—¶é’ˆæ–¹å‘ç§»åŠ¨,é€†æ—¶é’ˆé¡ºåºï¼Œaçš„è¶‹åŠ¿æ˜¯å¢åŠ çš„

ä½†æ˜¯æˆ‘ä»¬å¯¹ä»£ç è¿›è¡Œäº†ä¼˜åŒ–ï¼Œå› ä¸ºé¢˜ç›®çš„xçš„å€¼å¯èƒ½å¾ˆå¤§ï¼Œå¦‚æœå¾ˆå¤§çš„è¯ï¼Œä¼šè¶…æ—¶

æ‰€ä»¥å…ˆå¾—åˆ°æ‰€æœ‰èƒ½å¤Ÿç›´æ¥ä¸Šæ¥¼çš„æˆ¿é—´æ•°é‡ï¼Œå†å–æ¨¡è¿ç®—

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    int current_door;
    vector<vector<int>>arr(n * m, vector<int>(2, 0));
    for (int i = 0; i < n * m; i++) {
        cin >> arr[i][0] >> arr[i][1];
    }
    cin >> current_door;
    int current_stair = 1;
    int sum = 0;
    while (current_stair <= n) {
        int temp1 = arr[(current_stair - 1) * m + current_door][0];
        int temp2 = arr[(current_stair - 1) * m + current_door][1];
        if (temp1 == 1) {
            sum = (sum + temp2) % 20123;
            current_stair++;
        }

        else {
            sum = (sum + temp2) % 20123;
            int cnts = 0;
            for (int i = 0; i < m; i++) {
                if (arr[i][0]) cnts++;
            }

            int a = (temp2 % cnts)+current_door;

            //while (cnt < temp2) {
            //    a = (a + 1 + m) % m;  // é€†æ—¶é’ˆæ–¹å‘ç§»åŠ¨
            //    if (arr[(current_stair - 1) * m + a][0] == 1) {
            //        cnt++;
            //    }
            //}
            current_door = a;  // æ‰¾åˆ°ç¬¬ temp2 ä¸ªæœ‰æ¥¼æ¢¯çš„æˆ¿é—´
            current_stair++;
        }
    }

    cout << sum;
    return 0;
}

```





### åŠ›æ‰£100297

# åˆ†æ²»æ€æƒ³

### æ±‚æ£‹ç›˜è¦†ç›–é—®é¢˜

```
#include <iostream>
#include <cstring> // å¼•å…¥ memset

int tile = 1;        // éª¨ç‰Œåºå·
int board[128][128]; // äºŒç»´æ•°ç»„æ¨¡æ‹Ÿæ£‹ç›˜

void chessBoard(int tr, int tc, int dr, int dc, int size)
{
	if (size == 1)
		return;
	int s = size / 2; // åˆ†å‰²æ£‹ç›˜
	int t = tile++;   // tè®°å½•æœ¬å±‚éª¨ç‰Œåºå·

	if (dr < tr + s && dc < tc + s)
	{
		chessBoard(tr, tc, dr, dc, s);
	}
	else
	{
		board[tr + s - 1][tc + s - 1] = t;
		chessBoard(tr, tc, tr + s - 1, tc + s - 1, s);
	}

	if (dr < tr + s && dc >= tc + s)
	{
		chessBoard(tr, tc + s, dr, dc, s);
	}
	else
	{
		board[tr + s - 1][tc + s] = t;
		chessBoard(tr, tc + s, tr + s - 1, tc + s, s);
	}

	if (dr >= tr + s && dc < tc + s)
	{
		chessBoard(tr + s, tc, dr, dc, s);
	}
	else
	{
		board[tr + s][tc + s - 1] = t;
		chessBoard(tr + s, tc, tr + s, tc + s - 1, s);
	}

	if (dr >= tr + s && dc >= tc + s)
	{
		chessBoard(tr + s, tc + s, dr, dc, s);
	}
	else
	{
		board[tr + s][tc + s] = t;
		chessBoard(tr + s, tc + s, tr + s, tc + s, s);
	}
}

int main()
{
	int boardSize, specialRow, specialCol;

	// ç”¨æˆ·è¾“å…¥æ£‹ç›˜å¤§å°
	std::cout << "è¯·è¾“å…¥æ£‹ç›˜å¤§å° (2^k): ";
	std::cin >> boardSize;

	// ç”¨æˆ·è¾“å…¥ç‰¹æ®Šæ–¹å—ä½ç½®
	std::cout << "è¯·è¾“å…¥ç‰¹æ®Šæ–¹å—çš„ä½ç½® (è¡Œ åˆ—): ";
	std::cin >> specialRow >> specialCol;

	// åˆå§‹åŒ–æ£‹ç›˜
	memset(board, 0, sizeof(board));

	chessBoard(0, 0, specialRow, specialCol, boardSize);

	// æ‰“å°æ£‹ç›˜
	for (int i = 0; i < boardSize; i++)
	{
		for (int j = 0; j < boardSize; j++)
		{
			std::cout << board[i][j] << "\t";
		}
		std::cout << "\n\n";
	}
	return 0;
}

```

### åˆ†æ²»æ³•çš„å¿«é€Ÿæ’åºæ±‚ä¸­ä½æ•°

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

double getKth(vector<int>& a, int s1, int t1, vector<int>& b, int s2, int t2, int k) {
	if (s1 > t1) return b[s2 + k - 1]; // aæ•°ç»„ä¸ºç©º
	if (s2 > t2) return a[s1 + k - 1]; // bæ•°ç»„ä¸ºç©º
	if (k == 1) return min(a[s1], b[s2]); // åªéœ€è¦è¿”å›è¾ƒå°çš„å…ƒç´ 

	int m1 = (s1 + t1) < (s1 + k / 2 - 1) ? (s1 + t1) : (s1 + k / 2 - 1);
	int m2 = (s2 + t2) < (s2 + k / 2 - 1) ? (s2 + t2) : (s2 + k / 2 - 1);

	if (a[m1] < b[m2]) {
		return getKth(a, m1 + 1, t1, b, s2, t2, k - (m1 - s1 + 1)); // aæ•°ç»„å–ååŠæ®µ
	}
	else {
		return getKth(a, s1, t1, b, m2 + 1, t2, k - (m2 - s2 + 1)); // bæ•°ç»„å–ååŠæ®µ
	}
}

double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
	int total = a.size() + b.size();
	if (total % 2 == 1) {
		return getKth(a, 0, a.size() - 1, b, 0, b.size() - 1, total / 2 + 1);
	}
	else {
		double left = getKth(a, 0, a.size() - 1, b, 0, b.size() - 1, total / 2);
		double right = getKth(a, 0, a.size() - 1, b, 0, b.size() - 1, total / 2 + 1);
		return (left + right) / 2.0;
	}
}

int main() {
	int n1, n2;
	cout << "è¯·è¾“å…¥æ•°ç»„aã€æ•°ç»„bçš„é•¿åº¦n1ã€n2: ";
	cin >> n1 >> n2;
	vector<int> a(n1), b(n2);

	cout << "è¯·è¾“å…¥aæ•°ç»„çš„æ•°æ®: ";
	for (int i = 0; i < n1; i++) cin >> a[i];
	cout << "è¯·è¾“å…¥bæ•°ç»„çš„æ•°æ®: ";
	for (int i = 0; i < n2; i++) cin >> b[i];

	double median = findMedianSortedArrays(a, b);
	cout << "ä¸­ä½æ•°æ˜¯: " << median << endl;

	return 0;
}
```

# å¸¸ç”¨ç®—æ³•

## å¹¶æŸ¥é›†

```c++
#include <iostream>
#include <vector>

using namespace std;

class DisjointSet {
private:
    vector<int> parent;

public:
    DisjointSet(int size) {
        parent.resize(size);
        for (int i = 0; i < size; ++i) {
            parent[i] = i; // åˆå§‹æ—¶æ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹æ˜¯è‡ªå·±
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // è·¯å¾„å‹ç¼©
        }
        return parent[x];
    }

    void unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY; // åˆå¹¶ä¸¤ä¸ªé›†åˆ
        }
    }
};

int main() {
    DisjointSet ds(5);

    ds.unionSet(0, 1);
    ds.unionSet(2, 3);
    ds.unionSet(0, 4);

    cout << ds.find(3) << endl; // è¾“å‡º 2ï¼Œè¡¨ç¤ºèŠ‚ç‚¹ 3 å’ŒèŠ‚ç‚¹ 2 åœ¨åŒä¸€ä¸ªé›†åˆä¸­

    return 0;
}

```



## äºŒåˆ†æŸ¥æ‰¾

### [ã€ç®—æ³•1-6ã€‘äºŒåˆ†æŸ¥æ‰¾ä¸äºŒåˆ†ç­”æ¡ˆ - é¢˜å• - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/training/111#problems)

### åŸºç¡€äºŒåˆ†

ã€How to avoid pitfalls in Binary Search?ã€‘https://www.bilibili.com/video/BV1EW4y1C7vA?vd_source=afced950d3df908879a570bbf5db28f2



```c++
#include <iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool is_blue(int num, int x) {
	//å…·ä½“æ¡ä»¶
	if (num <= 5) return true;
	else return false;
}
int main() {
	//å‡è®¾æˆ‘è¦æ‰¾æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äºäº”çš„æ•°çš„ä¸‹æ ‡
	int arr[10] = {0};
	for (int i = 0; i < 10; i++) {
		cin >> arr[i];
	}
	int l = -1;
	int r = sizeof(arr) / sizeof(arr[0]);
	int mid;
	while (l + 1 != r) {//åˆ¤å®šæ¡ä»¶ï¼Œl+=rè¯´æ˜å·²ç»éå†äº†æ•´ä¸ªæ•°ç»„
		mid = (l + r) / 2;
		if (is_blue(arr[mid], 5)) l = mid;
		else r = mid;
	}
	cout << r;
	return 0;
}
```



### äºŒåˆ†æ±‚ç«‹æ–¹æ ¹

//è¾“å…¥ä¸€ä¸ªæ•°ï¼Œæ±‚å®ƒçš„ç«‹æ–¹æ ¹ï¼Œè¦æ±‚ä½¿ç”¨é«˜æ•ˆçš„ç®—æ³•ï¼Œç»“æœä¿ç•™å…­ä½å°æ•°

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¿ç•™å…­ä½å°æ•°ï¼Œåˆ™ç²¾åº¦è¦ç•™åˆ°1e-8

```c++
#include <iostream>
#include<vector>
using namespace std;

const double EPS = 1e-8;
bool check(double num, double n) {
	return num * num * num - n<EPS;
}
int main() {
	double n;
	cin >> n;
	double l = -100, r = 100;
	double mid;
	for (int i = 0; i < 50; i++) {
		mid = (r + l) / 2;
		if (check(mid, n)) l = mid;
		else r = mid;
	}
	printf("%6lf", l);

	return 0;
}
```

### æ´›è°·p3853

![image-20240315200520439](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200520439.png)

```c++
/*
å¯¹äºä»»æ„ä¸€ä¸ªç»™å‡ºçš„â€œç©ºæ—·æŒ‡æ•°â€Gï¼Œæˆ‘ä»¬åº”è¯¥æ€æ ·å»åˆ¤æ–­å®ƒæ˜¯å¦ç¬¦åˆé¢˜ç›®çš„æ„æ€å‘¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥æƒ³è±¡ï¼Œæˆ‘ä»¬å·²çŸ¥äº†è¿™æ¡è·¯ä¸Šçš„æ‰€æœ‰çš„è·¯æ ‡ï¼Œæˆ‘ä»¬ä»å¤´å¼€å§‹æšä¸¾ä¸¤ä¸¤ç›¸é‚»çš„è·¯æ ‡çš„é—´è·ï¼Œå¦‚æœå¤§äºG,é‚£ä¹ˆå·²ç»ä¸ç¬¦åˆGä¸ºæœ€å¤§è·ç¦»çš„æ¡ä»¶äº†ï¼Œä¸ºäº†ä½¿Gæ»¡è¶³,æˆ‘ä»¬å°±å¯ä»¥åœ¨å‰ä¸€ä¸ªè·¯æ ‡å‰é¢Gç±³å¤„åŠ ä¸€ä¸ªè·¯æ ‡ï¼Œè¿™æ ·ä¸å‰é¢ä¸€ä¸ªå°±ç¬¦åˆæ¡ä»¶äº†ï¼Œå†åˆ¤æ–­æ–°è®¾çš„è·¯æ ‡å’Œåé¢çš„è·¯æ ‡æ˜¯å¦è·ç¦»å°äºG,å¦‚æœä¸ï¼Œç»§ç»­é‡å¤æ“ä½œè®¾ç½®æ–°è·¯æ ‡

å½“æ–°è®¾çš„è·¯æ ‡æ•°å·²ç»è¶…è¿‡é¢˜ç›®æ‰€ç»™æœ€å¤§å¢è®¾å€¼æ—¶ï¼Œå¦‚æœè¿˜æœ‰è·¯æ ‡ä¸æ»¡è¶³G,ä½†å·²ç»ä¸èƒ½è®¾ç½®æ–°è·¯æ ‡äº†ï¼Œæ‰€ä»¥è¯¥Gå€¼å°±ä¸æ»¡è¶³æ¡ä»¶ã€‚ç›¸åï¼Œåˆ™Gæˆç«‹ã€‚

æ³¨æ„åˆ°ï¼Œå¦‚æœä¸€ä¸ªâ€œç©ºæ—·æŒ‡æ•°â€æˆç«‹ï¼Œé‚£ä¹ˆå¯èƒ½å­˜åœ¨æ¯”å®ƒæ›´å°çš„è§£ï¼Œä½†å¦‚æœä¸€ä¸ªâ€œç©ºæ—·æŒ‡æ•°â€ä¸æˆç«‹ï¼Œé‚£ä¹ˆç­”æ¡ˆåªèƒ½æ¯”è¯¥å€¼æ›´å¤§*/

//æˆ‘æ˜¯å¦‚æ­¤å¼€å¿ƒæˆ‘èƒ½æ¥è§¦åˆ°å¦‚æ­¤ç¾å¦™çš„ç®—æ³•
#include<iostream>
using namespace std;
int L,N,K;
int arr[100010],s[100010];
bool check(int x){
    int cnt=0;
    for(int i=1;i<=N;i++){
        if(s[i]>x){
            cnt++;
            int num=s[i]-x;
            while(num>x){
                cnt++;
                num-=x;
            }
        }
    }
    
    return cnt<=K;
}


int main(){
    cin>>L>>N>>K;
    int highest=0;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
        s[i]=arr[i]-arr[i-1];
    }
    
    arr[N+1]=L;
    s[N+1]=arr[N+1]-arr[N];
    int l=0,r=L+1;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    if(check(l)) cout<<l;
    else cout<<r;
    return 0;
}
```



### **æœ€å°å€¼æœ€å¤§æ¨¡å‹**

![image-20240315200512608](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200512608.png)

#### **æ´›è°·p1873**

```c++
#include<iostream>
using namespace std;
int n,m;
int arr[1000010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=max(0,arr[i]-x);
        if(sum>=m) return true;
    }
    return false;
   
  
}
int main(){
    cin>>n>>m;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
  
    else cout<<l;
    return 0;
}
```



#### **æ´›è°·p2440**

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,k;
int arr[100010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=arr[i]/x;
        if(sum>=k) return true;
    }
    return false;
}

int main(){
    cin>>n>>k;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
    else cout<<l;
    
    return 0;
}
```



#### **æ´›è°·p2678è·³çŸ³å¤´**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int L, N, M;
int arr[50010];

bool check(int x) {
    int cnt = 0;//è®°å½•ç§»åŠ¨çŸ³å¤´çš„æ¬¡æ•°
    int i = 0, now = 0;//iä»£è¡¨çš„æ˜¯å½“å‰çš„çŸ³å¤´ï¼Œi<N+1çš„åŸå› æ˜¯æˆ‘ä»¬ä¸èƒ½æŠŠç»ˆç‚¹æ¬èµ°
    while (i < N + 1) {
        i++;
        if (arr[i] - arr[now] < x) cnt++;
        else now = i;
    }
    return cnt <= M;

}
//ç®—æ³•æ€è·¯
//æ¯æ¬¡éƒ½æŠŠæœ€å°è·ç¦»ç§»èµ°ï¼Œå¹¶ä¸”éšç€ç§»åŠ¨çš„æ¬¡æ•°å˜å¤§ï¼Œæœ€å°è·³è·ƒè·ç¦»æ˜¯åœ¨å˜å¤§çš„
//äºŒåˆ†ï¼Œå‡è®¾ä¸­é—´çš„å€¼æ˜¯ç­”æ¡ˆï¼Œé‚£ä¹ˆæŒ‰ç…§æ¯”è¿™ä¸ªç­”æ¡ˆå°çš„çŸ³å¤´ä¸€å®šä¼šè¢«ç§»èµ°ï¼Œå¹¶ä¸”ç§»èµ°çš„çŸ³å¤´ä¸€å®šæ˜¯Mä¸ª
//æ‰€ä»¥äºŒåˆ†çš„åˆ¤æ–­æ¡ä»¶å°±æ˜¯ï¼Œç§»èµ°çš„çŸ³å¤´çš„ä¸ªæ•°æ˜¯ä¸æ˜¯Mï¼Œå¦‚æœå¤§äºMï¼Œå°±è¯´æ˜ä¸æ˜¯ç­”æ¡ˆ
//å¦‚æœæˆ‘ä»¬å‡è®¾çš„æ¡ä»¶ç¬¦åˆï¼Œæˆ‘ä»¬è¿˜è¦æ£€æŸ¥æ¯”å®ƒå°çš„åœ°æ–¹æ˜¯ä¸æ˜¯æœ‰ç­”æ¡ˆ

int main() {
    cin >> L >> N >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &arr[i]);
    }
    arr[N + 1] = L;  //ç›¸å½“äºç»ˆç‚¹ 
    int l = 0, r = L + 1;//è¾¹ç•Œæ¡ä»¶
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;//è¿™ä¸ªæ˜¯æˆ‘ä»¬å‡è®¾çš„ç­”æ¡ˆ
        if (check(mid)) l = mid;
        else r = mid;
    }

    if (check(r)) cout << r;
    else cout << l;

}
```

#### ACWing1236é€’å¢ä¸‰å…ƒç»„

éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š1.æ³¨æ„æ•°æ®çš„æ•°é‡çº§ï¼Œä¸¤ä¸ª10çš„äº”æ¬¡æ–¹ç›¸ä¹˜ï¼Œå¾—åˆ°çš„æ˜¯10çš„åæ¬¡æ–¹ï¼Œè¶…è¿‡intçš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥è¦å¼€long long

ç¬¬äºŒä¸ªå°±æ˜¯**å½“ç¨‹åºå‡ºé—®é¢˜æ—¶ï¼Œå¦‚æœç¡®ä¿¡è‡ªå·±çš„é€»è¾‘æ˜¯ï¼Œæ²¡é—®é¢˜çš„ï¼Œå°±è¦é‡æ–°æ£€æŸ¥ä¸€éï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½æ˜¯å› ä¸ºä¸€äº›å°ç»†èŠ‚å‡ºé”™è€Œä¸æ˜¯é€»è¾‘å‡ºé”™**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
int N;
int a[100010];
int b[100010];
int c[100010];
bool check1(int num, int x) {
    return num < x;
}

bool check2(int num, int x) {
    return num <= x;
}
int func1(int num) {
    //æ‰¾æ•°ç»„ä¸­æœ€åä¸€ä¸ªå°äºnumçš„ä¸‹æ ‡
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check1(a[mid], num)) l = mid;
        else r = mid;
    }
    return l;

}
int func2(int num) {
    //æ‰¾æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äºnumçš„ä¸‹æ ‡
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check2(c[mid], num)) l = mid;
        else r = mid;
    }
    return r;

}
int main() {
    cin >> N;
    LL res = 0;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &b[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &c[i]);
    }

    //äºŒåˆ†æ³•
    sort(a+1, a + N+1);
    sort(b+1, b + N+1);
    sort(c+1, c + N+1);
    for (int i = 1; i <= N; i++) {
        LL x = func1(b[i]);
        LL y = func2(b[i]);
        res += (x * (N - y + 1));
    }
    cout << res;
    return 0;
}
```

### å˜ç§äºŒåˆ†

#### åŠ›æ‰£33æœç´¢æ—‹è½¬æ’åºæ•°ç»„

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

```

### æ•°çš„ä½ç½®

![image-20240719160307338](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719160307338.png)



```c++
#include <iostream>
#include <vector>

using namespace std;

bool func2(vector<int>& arr, int mid, int x) {
    return arr[mid] < x;
}

bool func3(vector<int>& arr, int mid, int x) {
    return arr[mid] <= x;
}

pair<int, int> func1(vector<int>& arr, int x) {
    int n = arr.size();
    int l1 = -1, r1 = n;
    int l2 = -1, r2 = n;
    int mid;

    // æ‰¾èµ·å§‹ä½ç½®
    while (l1 + 1 != r1) {
        mid = (l1 + r1) / 2;
        if (func2(arr, mid, x)) l1 = mid;
        else r1 = mid;
    }

    // ç¡®ä¿ r1 ä¸è¶Šç•Œå¹¶ä¸” arr[r1] == x
    if (r1 >= n || arr[r1] != x) r1 = -1;

    // æ‰¾ç»ˆæ­¢ä½ç½®
    while (l2 + 1 != r2) {
        mid = (l2 + r2) / 2;
        if (func3(arr, mid, x)) l2 = mid;
        else r2 = mid;
    }

    // ç¡®ä¿ l2 ä¸è¶Šç•Œå¹¶ä¸” arr[l2] == x
    if (l2 < 0 || arr[l2] != x) l2 = -1;

    return { r1, l2 };
}

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    for (int i = 0; i < q; i++) {
        int k;
        cin >> k;
        pair<int, int> p = func1(arr, k);
        cout << p.first << " " << p.second << endl;
    }

    return 0;
}

```



## åŒæŒ‡é’ˆ

[åŒæŒ‡é’ˆç®—æ³•-CSDNåšå®¢](https://blog.csdn.net/qq_54773252/article/details/122836179?ops_request_misc=%7B%22request%5Fid%22%3A%22171059884416800226527499%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171059884416800226527499&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122836179-null-null.142^v99^pc_search_result_base1&utm_term=åŒæŒ‡é’ˆç®—æ³•&spm=1018.2226.3001.4187)

åŒæŒ‡é’ˆä¸»è¦æœ‰ä¸¤ç§ï¼šå¿«æ…¢æŒ‡é’ˆå’Œå¯¹æ’æŒ‡é’ˆ

### åŠ›æ‰£16æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        //åŒæŒ‡é’ˆ
        int n=nums.size();
        sort(nums.begin(),nums.end());
        int best=1e7;
        auto update=[&](int cur){
            if(abs(cur-target)<abs(best-target)){
                best=cur;
            }
        };

        for(int i=0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]) continue;//ä¸è®¡ç®—é‡å¤æƒ…å†µ
            

            //ä½¿ç”¨åŒæŒ‡é’ˆ
            int j=i+1,k=n-1;
            while(j<k){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==target) return target;
                update(sum);
                if(sum>target){
                    int k0=k-1;
                    while(j<k0&&nums[k0]==nums[k]) k0--;
                    k=k0;
                }
                else{
                    int j0=j+1;
                    while(j0<k&&nums[j0]==nums[j]) j0++;
                    j=j0;
                }
        }
    }
    return best;

    }
};
```

### åŠ›æ‰£15ä¸‰æ•°ä¹‹å’Œ

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        // æšä¸¾ a
        for (int first = 0; first < n; ++first) {
            // éœ€è¦å’Œä¸Šä¸€æ¬¡æšä¸¾çš„æ•°ä¸ç›¸åŒ
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c å¯¹åº”çš„æŒ‡é’ˆåˆå§‹æŒ‡å‘æ•°ç»„çš„æœ€å³ç«¯
            int third = n - 1;
            int target = -nums[first];
            // æšä¸¾ b
            for (int second = first + 1; second < n; ++second) {
                // éœ€è¦å’Œä¸Šä¸€æ¬¡æšä¸¾çš„æ•°ä¸ç›¸åŒ
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // éœ€è¦ä¿è¯ b çš„æŒ‡é’ˆåœ¨ c çš„æŒ‡é’ˆçš„å·¦ä¾§
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // å¦‚æœæŒ‡é’ˆé‡åˆï¼Œéšç€ b åç»­çš„å¢åŠ 
                // å°±ä¸ä¼šæœ‰æ»¡è¶³ a+b+c=0 å¹¶ä¸” b<c çš„ c äº†ï¼Œå¯ä»¥é€€å‡ºå¾ªç¯
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};


```



### 18å››æ•°ä¹‹å’Œ

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> quadruplets;
        if (nums.size() < 4) {
            return quadruplets;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        for (int i = 0; i < length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
            for (int j = i + 1; j < length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                int left = j + 1, right = length - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
};


```



### æ´›è°·p1102

æˆ‘ä»¬è€ƒè™‘é¢˜ç›®è¦æ±‚æ±‚å‡ºæ‰€æœ‰`A-B=C`çš„æ•°å¯¹ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå°†åŸæ•°ç»„æ’åºï¼Œç„¶åå°±ä¼šå‘ç°æ¯ä¸ªæ•°Aï¼Œå¯¹åº”çš„æ•°Bä¸€å®šæ˜¯ä¸€æ®µè¿ç»­çš„åŒºé—´ã€‚

ç„¶åæˆ‘ä»¬å†è€ƒè™‘å¦‚ä½•å»æ‰¾åˆ°è¿™ä¸ªåŒºé—´ã€‚

æˆ‘ä»¬æ˜¾ç„¶æ˜¯è¦æ‰¾åˆ°è¿™ä¸ªè¿ç»­åŒºé—´çš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹ã€‚

è€ƒè™‘åˆ°æ’åºä¹‹ååºåˆ—çš„æœ‰åºæ€§ï¼Œæˆ‘ä»¬æšä¸¾æ¯ä¸ªæ•°ï¼Œä»–ä»¬çš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹éƒ½æ˜¯**å•è°ƒä¸é™**çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨two-pointersï¼Œä¹Ÿå°±æ˜¯åŒæŒ‡é’ˆæ¥ç»´æŠ¤è¿™ä¸ªä¸œè¥¿ã€‚

![image-20240316225049443](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240316225049443.png)

ä»£ç å¾ˆç®€æ´ã€‚

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1 , a + 1 + n);
	int l = 1, r1 = 1 , r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```



### åŠ›æ‰£27ç§»é™¤å…ƒç´ 

soooooooeasy!!!!

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int le=nums.size();
        int i=0,j=0;
        while(i<le){
            if(nums[i]==val) j++;
            else nums[i-j]=nums[i];
            i++;
        }
        nums.resize(le-j);
        return le-j;


    }
};
```



### åŠ›æ‰£11ç››æœ€å¤šæ°´çš„å®¹å™¨

ç”±é¢˜æ„å¯çŸ¥ï¼Œå®¹å™¨çš„é«˜åº¦æ˜¯ç”±çŸ­æ¿å†³å®šçš„ï¼Œå‡è®¾åˆå§‹å®¹å™¨çš„çŸ­æ¿å’Œé•¿ç‰ˆåˆ†åˆ«åœ¨ä¸¤ç«¯

å¦‚æœå‘å†…ç§»åŠ¨çŸ­æ¿ï¼ŒçŸ­æ¿çš„é•¿åº¦æœ‰å¯èƒ½å˜å¤§ï¼Œè™½ç„¶å®¹å™¨çš„å®½åº¦å˜å°äº†ï¼Œä½†æ˜¯ä»ç„¶å¯èƒ½ä½¿å¾—å®¹å™¨çš„ä½“ç§¯å˜å¤§

å¦‚æœç§»åŠ¨é•¿æ¿ï¼Œåˆ™å®¹å™¨çš„ä½“ç§¯ä¸€å®šå˜å°

ç”±æ­¤å¯çŸ¥åªè¦åœ¨æ¯æ¬¡ç§»åŠ¨ä¸­ç§»åŠ¨çŸ­æ¿ï¼Œåœ¨åˆ¤æ–­ä½“ç§¯æ˜¯å¦å˜å¤§å³å¯

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int le = height.size();
        int r1 = 0, r2 = le - 1;//çŸ­æ¿é•¿æ¿
        int res = 0;
        while(r1<r2){
            if(height[r1]<height[r2]){
                res=max(res,min(height[r1],height[r2])*(r2-r1));
                r1++;
            }
            else{
                 res=max(res,min(height[r1],height[r2])*(r2-r1));
                r2--;
            }
        }
        return res;
    }
};
```

### ACWing1236é€’å¢ä¸‰å…ƒç»„

```c++
//æ»¡è¶³æ¡ä»¶A-B<0  B-C<0
//æšä¸¾Bï¼Œæ‰€ä»¥å‡è®¾æ¯æ¬¡Bçš„å€¼éƒ½æ˜¯å›ºå®šçš„ï¼Œæˆ‘ä»¬çŸ¥é“Aiçš„å€¼æ˜¯æœ€åä¸€ä¸ªå°äºBçš„å€¼ï¼Œé‚£ä¹ˆAiä¹‹å‰çš„å€¼éƒ½æ˜¯å°äºBçš„ï¼ŒåŒç†ï¼Œæœ€åä¸€ä¸ªå°äºBçš„Ciä¹‹åçš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å¤§äºBçš„
//æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾åˆ°è¿™äº›æ•°

```



```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;
const int N = 1e5+10;
int num[3][N];

int main() {
    int n;
    scanf("%d", &n);
    for(int i = 0; i < 3; ++i) 
        for(int j = 1; j <= n; ++j) 
            scanf("%d", &num[i][j]);
    for(int i = 0; i < 3; ++i)
        sort(num[i]+1, num[i]+n+1);

    LL ans = 0;
    //æšä¸¾Bï¼Œå¯»æ‰¾Aæ»¡è¶³çš„ä¸ªæ•°ä»¥åŠCæ»¡è¶³çš„ä¸ªæ•°ç›¸ä¹˜
    int a = 1, c = 1;
    for(int i = 1; i <= n; ++i) {
        int key = num[1][i];
        while(a<=n && num[0][a] < key) a++;
        while(c<=n && num[2][c] <= key) c++;

        ans += (LL)(a-1)*(n-c+1);

    }
    cout<<ans<<endl;
    return 0;
}

```



### åŠ›æ‰£80

åŒæŒ‡é’ˆ

## æ»‘åŠ¨çª—å£

åˆ¤æ–­çª—å£æ˜¯å¦æ»¡è¶³

å‰”é™¤å†—ä½™å…ƒç´ 

#### 3åŠ›æ‰£æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­—ä¸²

æˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤æœ€é•¿ä¸é‡å¤å­ä¸²ï¼Œ

æˆ‘ä»¬çŸ¥é“ï¼Œr0-rkä¹‹é—´çš„å­—ç¬¦ä¸²æ˜¯ä¸é‡å¤çš„ï¼Œåˆ™r1-rkä¹‹é—´çš„å­—ä¸²ä¹Ÿæ˜¯ä¸é‡å¤çš„ï¼Œè¿™æ˜¯è¯¥é¢˜è§£çš„åŸºç¡€

å½“å‡ºç°é‡å¤å­—ç¬¦çš„æ—¶å€™ï¼Œå‡ºåˆ—æœ€å·¦è¾¹ï¼Œæ­¤æ—¶r1-rkä¸€å®šæ˜¯ä¸é‡å¤çš„å•¦

```c++
//æ»‘åŠ¨çª—å£
//unordered_set
class Solution {
public:

    int lengthOfLongestSubstring(string s) {
        unordered_set<char>occ;
        int n=s.size();
        int rk=-1,ans=0;//ä¸€èˆ¬æ»‘åŠ¨æ•°ç»„éƒ½ç”¨-1ä½œä¸ºå¼€å§‹
        for(int i=0;i<n;i++){
            if(i!=0){
                occ.erase(s[i-1]);
            }
            while(rk+1<n&&!occ.count(s[rk+1])){
                occ.insert(s[rk+1]);
                ++rk;
            }
            ans=max(ans,rk-i+1);
        }
        return ans;

    }
};
```

#### æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ—

å®šä¹‰ä¸€ä¸ªæ•°ç»„æ¥è®°å½•æ¯ä¸ªå…ƒç´ ä¸Šä¸€æ¬¡åœ¨æ•°ç»„ä¸­å‡ºç°çš„ä½ç½®ã€‚

æˆ‘ä»¬éœ€è¦éå†æ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå¯¹äºå½“å‰å…ƒç´ ï¼Œå¦‚æœå½“å‰å…ƒç´ å¯¹åº”çš„å€¼ä¸Šä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œå°±æ˜¯é‚£ä¸ªè®°å½•ä½ç½®æ•°ç»„å¯¹åº”çš„å€¼åœ¨æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ—çš„èŒƒå›´å†…ï¼Œè¯´æ˜ä¸Šæ¬¡å·²ç»æœ‰ä¸€ä¸ªè¿™æ ·çš„å…ƒç´ å‡ºç°äº†ï¼Œåˆ™éœ€è¦æ›´æ–°æœ€é•¿è¿ç»­ä¸é‡å¤å­åºåˆ—ï¼Œstartçš„ä½ç½®åº”è¯¥æ˜¯å½“å‰å…ƒç´ çš„ä½ç½®

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int>arr(n, 0);
    vector<int>record(100001, -1);
    for (int i = 0; i < n; i++) cin >> arr[i];
    int start = 0, end = 0;
    int max_len = INT_MIN;
    for (; end < n; end++) {
        if (record[arr[end]] >= start) {
            //è¿™ä¸ªæ„æ€æ˜¯arr[end]ä¸Šæ¬¡å‡ºç°çš„ä½ç½®åœ¨startä¹‹åï¼Œè¯´æ˜å…ƒç´ é‡å¤
            start = record[arr[end]] + 1;
        }
        
        record[arr[end]] = end;
        max_len = max(max_len, end - start + 1);
        
    }


    return 0;
}

```



### ä¸å¤ªç”œçš„ç³–æœ

ç»™ä½ ä¸€ä¸ªæ•°ç»„å’Œä¸€ä¸ªå€¼m,æ±‚æœ€çŸ­è¿ç»­å­ä¸²ä¹‹å’Œå¤§äºç­‰äºm

```c++
//è¾“å…¥
10 15 
5 1 3 5 10 7 4 9 2 8 
//è¾“å‡º
2
//è§£é‡Šï¼š5 10æˆ–è€…10 7
```

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#include <climits> 

using namespace std;

bool check(vector<int>& prefix_sum, int mid, int target) {
    return prefix_sum[mid] < target;
}
int binary_search(vector<int>& prefix_sum, int low,int high,int target) {
    int l = low-1, r = high+1;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check(prefix_sum, mid, target)) l = mid;
        else r = mid;
    }

    if (r!=high+1) return r;
    else return -1;

}
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> sweetness(n+1,0);
    int min_Len = INT_MAX;

    for (int i = 1; i <= n; i++) {
        cin >> sweetness[i];
    }

    vector<int>prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + sweetness[i];
    }

    for (int i = 1; i <= n; i++) {
        int target = prefix_sum[i] + m;
        int index = binary_search(prefix_sum, i,n,target);
        if(index!=-1) min_Len = min(min_Len, index - i);
        
    }

    if (min_Len != INT_MAX) cout << min_Len;

    return 0;
}
```

### åŠ›æ‰£27åˆ é™¤é¡ºåºè¡¨æ‰€æœ‰å€¼ä¸ºxçš„å…ƒç´ 

è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸ºOï¼ˆnï¼‰ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºOï¼ˆ1ï¼‰

å¿«æ…¢æŒ‡é’ˆ

å¿«æŒ‡é’ˆæ‰¾åˆ°æ•°ç»„ä¸­éœ€è¦æ›´æ–°çš„æ•°æ®

æ»¡æŒ‡é’ˆæ‰¾åˆ°éœ€è¦æ›´æ–°çš„ä½ç½®

```c++
//æ•´ä½“å»ºè¡¨
void func1(vector<int>& arr, int x) {
	int n = arr.size();
	int k = 0;
	for (int i = 0; i < n; i++) {
		if (arr[i] != x) {
			arr[k] = arr[i];
			k++;
		}		
	}

	arr.resize(k);
}

//å…ƒç´ ç§»åŠ¨æ³•
void func2(vector<int>& arr, int x) {
	int i = 0;
	int n = arr.size();
	int k = 0;
	while (i < n) {
		if (arr[i] == x) {
			k++;
		}
		else {
			arr[i - k] = arr[i];
		}

		i++;
	}

	arr.resize(n - k);
}
```



### æŠŠæ•°ç»„ä¸­å¥‡æ•°æ”¾åˆ°å¶æ•°çš„å‰é¢

```c++
//åŒºé—´åˆ’åˆ†æ³•
void func(vector<int>& arr) {
	int i = -1;
	int j = 0;
	int n = arr.size();
	for (j; j < n; j++) {
		if (arr[j] % 2 == 1) {
			i++;
			if (i != j) {
				swap(arr[i], arr[j]);
			}
		}
		
	}
	
}
```



### åŠ›æ‰£26åˆ é™¤æœ‰åºæ•°ç»„çš„é‡å¤é¡¹

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return n;
        int fast=1;
        int slow=0;
        while(fast<n){
           if(nums[fast]==nums[slow]) fast++;
           else{
            slow++;
            nums[slow]=nums[fast];
            fast++;
           }
        }

        return slow+1;

        
    }
};
```

### åˆ¤æ–­å­åºåˆ—



ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º ğ‘›*n* çš„æ•´æ•°åºåˆ— ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›ä»¥åŠä¸€ä¸ªé•¿åº¦ä¸º ğ‘š*m* çš„æ•´æ•°åºåˆ— ğ‘1,ğ‘2,â€¦,ğ‘ğ‘šã€‚è¯·ä½ åˆ¤æ–­ ğ‘åºåˆ—æ˜¯å¦ä¸º ğ‘åºåˆ—çš„å­åºåˆ—ã€‚å­åºåˆ—æŒ‡åºåˆ—çš„ä¸€éƒ¨åˆ†é¡¹æŒ‰**åŸæœ‰æ¬¡åºæ’åˆ—**è€Œå¾—çš„åºåˆ—ï¼Œä¾‹å¦‚åºåˆ— ğ‘1,ğ‘3,ğ‘5æ˜¯åºåˆ— ğ‘1,ğ‘2,ğ‘3,ğ‘4,ğ‘5çš„ä¸€ä¸ªå­åºåˆ—ã€‚



ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° ğ‘›,ğ‘šã€‚ ç¬¬äºŒè¡ŒåŒ…å« ğ‘›ä¸ªæ•´æ•°ï¼Œè¡¨ç¤º ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å« ğ‘šä¸ªæ•´æ•°ï¼Œè¡¨ç¤º ğ‘1,ğ‘2,â€¦,ğ‘ğ‘šã€‚



å¦‚æœ ğ‘ åºåˆ—æ˜¯ ğ‘ åºåˆ—çš„å­åºåˆ—ï¼Œè¾“å‡ºä¸€è¡Œ `Yes`ã€‚ å¦åˆ™ï¼Œè¾“å‡º `No`ã€‚



åˆ©ç”¨å•è°ƒæ€§

```c++
#include <iostream>
#include <vector>
#include<climits>

using namespace std;

int main() {
    int n, m,target;
    cin >> n >> m>>target;
    vector<int>text(n, 0);
    vector<int>pattern(m, 0);
    for (int i = 0; i < n; i++) cin >> text[i];
    for (int i = 0; i < m; i++) cin >> pattern[i];
    int i = 0, j = m - 1;
    while (i < n && m >= 0) {
        if (text[i] + pattern[j] > target) j--;
        else if (text[i] + pattern[j] < target) i++;
        else {
            cout << i << " " << j;
            break;
        }
    }

    return 0;
}

```



## KMP

### kmp1

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
class Solution {
public:
	//å¦‚ä½•é«˜æ•ˆçš„çœ‹å‡ºå‰ç¼€å’Œåç¼€æ˜¯å¦ç›¸ç­‰
	vector<int>Arry(string pattern)
	{
		int index = 0;
		vector<int> arry(pattern.size(), 0);
		//æˆ‘ä»¬ä»ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªå­—ç¬¦å¼€å§‹æ¯”è¾ƒï¼Œæ‰€ä»¥index=0,i=1
		//indexè¡¨ç¤ºå…ƒç´ ä¸‹æ ‡ï¼Œå¹¶ä¸”æ€»æ˜¯æŒ‡å‘æœ€å°ç›¸åŒå‰ç¼€çš„æœ«ç«¯ï¼Œåˆšå¼€å§‹åŒ¹é…æ²¡æœ‰æœ€å°å‰ç¼€ï¼Œæ‰€ä»¥index=0
		for (int i = 1; i < pattern.size();)
		{
			//å¦‚æœpattern==index,è¯´æ˜å‡ºç°äº†æœ€å°å‰ç¼€
			if (pattern[i] == pattern[index])
			{
					
				arry[i] = index + 1;
				index++;
				i++;
			}

			else
			{
				//å¦‚æœä»–ä»¬çš„å€¼ä¸ä¸€æ ·ï¼Œè¯´æ˜æˆªæ­¢åˆ°ä¸‹æ ‡pattern[i]å…ƒç´ å‡ºç°äº†ä¸ä¸€æ ·çš„å…ƒç´ 
				if (index != 0)
				{
					//å›æº¯åˆ°å¯¹åº”æ•°ç»„çš„å€¼æ‰€ä»£è¡¨çš„é‚£ä¸€ä¸ªå­—ç¬¦
					index = arry[index - 1];
				}
				else
				{
					//è¿™é‡Œçš„å‰ææ˜¯pattern[i]!=pattern[index],å¹¶ä¸”index=0,è¯´æ˜ç›®å‰çš„æœ€å°å‰ç¼€æ˜¯0
					arry[i] = 0;
					i++;
				}
			}
		}
		return arry;

	}

	int KMP(string text, string pattern)
	{
		vector<int>arry = Arry(pattern);
		int i = 0, j = 0;
		int k = 0;
		while (i < text.size() && j < pattern.size())
		{
			k++;
			if (text[i] == pattern[j])
			{
				i++;
				j++;
			}
			else
			{
				if (j != 0)
				{
					//æ­¤æ—¶è¦è¿›è¡Œå›æº¯
					//å¦‚æœjçš„å€¼ä¸ç­‰äºé›¶ï¼Œå°±æŠŠæ¨¡å¼ä¸²æŒ‡é’ˆç§»åŠ¨åˆ°arryæ•°ç»„æŒ‡å‘çš„é‚£ä¸ªæœ€é•¿ç›¸åŒå‰ç¼€é‚£é‡Œ
					j = arry[j - 1];
				}
				else
				{
					//å¦‚æœæ˜¯é›¶å°±ç›´æ¥é‡æ–°éå†æ¨¡å¼ä¸²
					i++;
				}
			}
		}
		cout << k;
		if (j == pattern.size())
		{
			return i - pattern.size();
		}
		else
		{
			return -1;
		}
	}
	
};

//å¯¹äºå­—ç¬¦ä¸²abcabcabc,è¿”å›çš„æ•°ç»„æ˜¯0 0 0 1 2 3 4 5 6
//å‰ç¼€å‡½æ•°ï¼šå­—ç¬¦ä¸²æœ€é•¿çš„ç›¸ç­‰çš„çœŸå‰ç¼€å’ŒçœŸåç¼€çš„é•¿åº¦
//è¯¥ç®—æ³•æ±‚çš„å­—ç¬¦ä¸²å‰iï¼ˆåŒ…æ‹¬iï¼‰çš„å­ä¸²çš„å‰ç¼€å‡½æ•°
vector<int> prefix_function(string s) {
	int n = (int)s.length();
	vector<int> pi(n);
	for (int i = 1; i < n; i++) {
		int j = pi[i - 1];
		while (j > 0 && s[i] != s[j]) j = pi[j - 1];
		if (s[i] == s[j]) j++;
		pi[i] = j;
	}
	return pi;
}

//è¯¥ç®—æ³•ä¼šæ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰åŒ¹é…å­ä¸²çš„ä¸‹æ ‡ï¼Œç‰›ç‰›ç‰›ï¼ï¼ï¼
vector<int> find_occurrences(string text, string pattern) {
	string cur = pattern + '#' + text;
	int sz1 = text.size(), sz2 = pattern.size();
	vector<int> v;
	vector<int> lps = prefix_function(cur);
	for (int i = sz2 + 1; i <= sz1 + sz2; i++) {
		if (lps[i] == sz2) v.push_back(i - 2 * sz2);
	}
	return v;
}


int main() {
	string text = "abcabcabc";
	string pattern = "abc";
	vector<int>v = find_occurrences(text, pattern);
	for (auto i : v) cout << i << ' ';
	

}



```

### kmp2

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
const int MaxSize = 100;
void getnext(string pattern,int next[]) {
	int n = pattern.size();
	int i = 0, j = -1;
	next[0] = -1;
	while (i < n-1) {
		if (j == -1 || pattern[i] == pattern[j]) {
			i++;
			j++;
			next[i] = j;
		}
		else j = next[j];//jå›é€€
	}	
}

void getnextval(string pattern, int nextval[]) {
	int i = 0, j = -1;
	int n = pattern.size();
	nextval[0] = -1;
	while (i < n - 1) {
		if (j == -1 || pattern[i] == pattern[j]) {
			i++;
			j++;
			if (pattern[i] != pattern[j]) nextval[i] = j;
			else nextval[i] = nextval[j];
		}
		else j = nextval[j];
	}
}

int KMP2(string text, string pattern) {
	int l1 = text.size(), l2 = pattern.size();
	int next[MaxSize];
	getnext(pattern, next);
	int i = 0, j = 0;
	while (i < l1 && j < l2) {
		if (j == -1 || text[i] == pattern[j]) {
			i++;
			j++;
		}
		else j = next[j];
	}
	if (j >= l2) return i - l2;
	else return -1;
}

```



## éå†é¡ºåºé—®é¢˜

```c++
//æ­£åºéå†ï¼šä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³
int main() {
    for (int i = 0; i <=10; i++) {
        for (int j = 0; j <=10; j++) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}

//å€’å™éå†ï¼šä»ä¸‹åˆ°ä¸Šï¼Œä»å·¦åˆ°å³
int main() {
    for (int i = 10; i >=0; i--) {
        for (int j = 10; j >=0; j--) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}

//ä»ä¸Šåˆ°ä¸‹ï¼Œæ­£ä¸‰è§’
int main() {
    for (int i = 0; i <=10; i++) {
        for (int j = 0; j <=i; j++) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}

//æœ¬éå†é¡ºåºç”¨äºï¼ˆiï¼Œjï¼‰çŠ¶æ€éœ€è¦ä»(i+1,j+1)çŠ¶æ€å¾—åˆ°çš„æ—¶å€™
int main() {
    for (int i = 10; i >=0; i--) {
        for (int j = 10; j >=i; j--) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}
```

## å¿«é€Ÿå¹‚ç®—æ³•

https://www.bilibili.com/video/BV16Z4y1M7y1/?spm_id_from=333.337.search-card.all.click

å¿«é€Ÿå¹‚ç®—æ³•ç”¨äºè®¡ç®—å¹‚é¢„ç®—ï¼Œï¼ˆå½“nå¾ˆå¤§çš„æ—¶å€™ï¼Œæœ´ç´ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºo(n),è¿™ä¸ªç®—æ³•å¯ä»¥è¿›è¡Œæé€Ÿ),åŸç†å°±æ˜¯æŠŠnè½¬åŒ–æˆ2çš„å¹‚è¿ç®—ï¼Œå†ç®€åŒ–,æ—¶é—´å¤æ‚åº¦ä¸ºo(logn)



æ¯”å¦‚åŠ›æ‰£ç¬¬50é“é¢˜è¦æ±‚æ‰‹åŠ¨æ“å‡ºpowå‡½æ•°

éœ€è¦çŸ¥é“çš„æ˜¯å¿«é€Ÿå¹‚å¯¹è´Ÿæ•°ä»ç„¶é€‚ç”¨



//æ³¨é‡Šï¼Œæœ‰æ—¶å€™çœ‹åˆ°è‡ªå·±å†™çš„ä¸€å¨å±å±…ç„¶è¿‡äº†ä¹Ÿä¼šæ‰¶é¢è‹¦ç¬‘

```c++
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};

```

## é«˜ç²¾åº¦ç®—æ³•

### é«˜ç²¾åº¦åŠ æ³•

é«˜ç²¾åº¦åŠ æ³•å¯¹æ¯”é«˜ç²¾åº¦å‡æ³•ç®€å•äº†å¥½å¤š

1.å¤„ç†è¿›ä½é—®é¢˜ï¼Œcarryè®°å½•è¿›ä½ï¼Œæœ€åè¦åˆ¤æ–­è¿›ä½æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸ä¸ºé›¶ï¼Œè¿˜è¦åŠ ä¸Šè¿›ä½

```c++
#include <iostream>
#include <string>
#include <algorithm>

// é«˜ç²¾åº¦åŠ æ³•å‡½æ•°
std::string highPrecisionAdd(const std::string& num1, const std::string& num2) {
    int len1 = num1.size();
    int len2 = num2.size();
    int maxLength = std::max(len1, len2);

    std::string result;
    int carry = 0; // è¿›ä½

    // ä»æœ€ä½ä½å¼€å§‹é€ä½ç›¸åŠ  
    for (int i = 0; i < maxLength; i++) {
        int digit1 = (i < len1) ? num1[len1 - 1 - i] - '0' : 0;
        int digit2 = (i < len2) ? num2[len2 - 1 - i] - '0' : 0;
        int sum = digit1 + digit2 + carry;
        carry = sum / 10;
        result.push_back(sum % 10 + '0');
    }

    // æœ€åå¤„ç†è¿›ä½
    if (carry) {
        result.push_back(carry + '0');
    }

    // åè½¬ç»“æœå­—ç¬¦ä¸²
    std::reverse(result.begin(), result.end());

    return result;
}

int main() {
    std::string num1, num2;
    std::cout << "Enter the first large number: ";
    std::cin >> num1;
    std::cout << "Enter the second large number: ";
    std::cin >> num2;

    std::string result = highPrecisionAdd(num1, num2);
    std::cout << "Result of addition: " << result << std::endl;

    return 0;
}

```



### é«˜ç²¾åº¦å‡æ³•

é«˜ç²¾åº¦åŠ æ³•éœ€è¦è§£å†³çš„é—®é¢˜ï¼š

1.å¦‚æœä¸¤ä¸ªæ•°ç›¸ç­‰ï¼Œç›´æ¥è¿”å›0å³å¯

2.å¦‚æœä¸¤ä¸ªæ•°ä¸ç­‰ï¼Œå¦‚ä½•è®©å¤§çš„é‚£ä¸ªæ•°æ”¾åˆ°å‰é¢ï¼Œå¹¶å¤„ç†è´Ÿå·çš„é—®é¢˜

3.å¦‚ä½•å¤„ç†å€Ÿä½é—®é¢˜ï¼Œæ¯”å¦‚100å€Ÿä½

4.å¦‚ä½•å¤„ç†ä¸¤ä¸ªæ•°çš„ä½æ•°ä¸ä¸€è‡´é—®é¢˜

5.å»é™¤å‰å¯¼é›¶

```c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// å­—ç¬¦ä¸²å‡æ³•ï¼Œç”¨äºé«˜ç²¾åº¦å‡æ³•è¿ç®—
string subtract(string& a, string& b) {
    // ç¡®ä¿ a >= b
    if (a == b) {
        return "0";
    }

    bool flag = false;
    if (a.size() < b.size()) {
        swap(a, b);
        flag = true;
    }

    else if (a.size() == b.size() && a < b) {
        swap(a, b);
        flag = true;
    }

    string result;
    int carry = 0;
    int lenA = a.size();
    int lenB = b.size();

    for (int i = 0; i < lenA; ++i) {
        int numA = a[lenA - 1 - i] - '0';
        int numB = i < lenB ? b[lenB - 1 - i] - '0' : 0;

        int temp = numA - numB - carry;

        if (temp < 0) {
            temp += 10;
            carry = 1;
        }
        else {
            carry = 0;
        }

        result.push_back(temp + '0');
    }
    
    

    // å»é™¤ç»“æœä¸­çš„å‰å¯¼é›¶
    while (result.size() > 1 && result.back() == '0') {
        result.pop_back();
    }
    
    reverse(result.begin(), result.end());

    
    if (flag) result.insert(result.begin(), '-');
    return result;
}

int main() {
    string a, b;
    
    cin >> a;
    //cout << "Enter the subtrahend: ";
    cin >> b;
    cout << "Result: " << subtract(a, b) << endl;
    return 0;
}

```



### é«˜ç²¾åº¦ä¹˜æ³•

é«˜ç²¾åº¦ä¹˜æ³•æ²¡æœ‰ç¿»è½¬å­—ç¬¦ä¸²

ä½¿ç”¨vectoræ•°ç»„å­˜å‚¨æ¯ä¸€ä½æ•°å­—ï¼Œæœ€åè®°å¾—è½¬åŒ–æˆå­—ç¬¦ä¸²å³å¯

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0); 
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? 0 : ans;
}
int main() {
    string a, b;
    cin >> a >> b;
    string ans = multiple(a, b);
    cout << ans;
    return 0;
}

```



### é«˜ç²¾åº¦é™¤æ³•

1.é«˜ç²¾åº¦é™¤ä»¥ä½ç²¾åº¦ï¼ˆé€ä½è¯•å•†ï¼‰ 

```c++
#include<iostream>
#include<string>
using namespace std;
string func(string a, string b) {
	long long y = stoll(b);
	int la = a.size();
	string c(la, '0');
	long long sum = 0, carry = 0;
	for (int i = 0; i < la; i++) {
		sum = (carry * 10 + a[i] - '0');
		c[i] = (sum / y)+'0';
		carry = sum % y;
	}

	int i = 0;
	while (c.size()>1&&c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



2.é«˜ç²¾åº¦é™¤ä»¥é«˜ç²¾åº¦

ä»¥å‡æ³•ä»£æ›¿é™¤æ³•çš„è¿ç®—

```c++
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string result;

	int na = a.size();
	int nb = b.size();

	int i;
	int carry = 0;

	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1]-'0';
		int numb = i < nb ? b[nb - i - 1]-'0' : 0;
		int temp = numa - numb - carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else carry = 0;

		result.push_back(temp + '0');
	}


	while (result.size() > 1 && result.back() == '0') {
		result.pop_back();
	}

	reverse(result.begin(), result.end());
	return result;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	string c;
	int cnt = 0;
	char ch;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			cnt++;
			a = func2(a, temp);
		}
		ch = cnt + '0';
		c += ch;
		cnt = 0;
	}

	//å»é™¤å‰å¯¼é›¶
	int i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



### é«˜ç²¾åº¦å–æ¨¡

1.é«˜ç²¾åº¦å–æ¨¡ä½ç²¾åº¦

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
	string a, b;
	cin >> a >> b;
	a += b;
	int result = 0;
	int mod = 1000000007;
	for (auto i : a) {
		result = (result * 10 + (i - '0')) % mod;
	}

	cout << result;
}
```





2é«˜ç²¾åº¦å–æ¨¡é«˜ç²¾åº¦

```
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string c;

	int na = a.size();
	int nb = b.size();

	int carry = 0;
	int i;
	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1] - '0';
		int numb = i < nb ? b[nb - 1 - i] - '0' : 0;
		int temp = numa - numb-carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else {
			carry = 0;
		}
		c.push_back(temp + '0');

	}

	reverse(c.begin(), c.end());
	i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	
	return c;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	if (issmaller(a, b)) return a;
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			a = func2(a, temp);
		}
	}
	return a;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```

## æ—¶é—´é—®é¢˜

### 24å°æ—¶åˆ¶è½¬æ¢ä¸º12å°æ—¶åˆ¶

```c++
#include <iostream>
#include <string>

using namespace std;

string convertTo12HourFormat(int hour) {
    if (hour <= 12) {
        return to_string(hour) + " AM";
    } else {
        return to_string(hour - 12) + " PM";
    }
}

int main() {
    int hour;
    cout << "Enter hour in 24-hour format: ";
    cin >> hour;

    cout << "Time in 12-hour format: " << convertTo12HourFormat(hour) << endl;

    return 0;
}

```

### æ—¶é—´åŠ å‡æ³•

**æ—¶é—´åŠ å‡æ³•å¯ä»¥é€šè¿‡å°†æ—¶é—´è½¬æ¢ä¸ºåˆ†é’Ÿæ•°è¿›è¡Œè®¡ç®—ï¼Œç„¶åå†å°†ç»“æœè½¬æ¢å›æ—¶é—´æ ¼å¼ã€‚**

ç»™ä¸€ä¸ªæ—¶é—´ï¼Œæ±‚è¯¥æ—¶é—´æå‰45åˆ†é’Ÿçš„æ—¶é—´

```c++
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    int h, m;
    char colon;
    cin >> h >> colon >> m;

    // è®¡ç®—å½“å‰æ—¶é—´æ€»å…±çš„åˆ†é’Ÿæ•°
    int totalMinutes = h * 60 + m;

    // è®¡ç®—45åˆ†é’Ÿä¹‹å‰çš„æ—¶åˆ»
    totalMinutes -= 45;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // è°ƒæ•´åˆ°å‰ä¸€å¤©
    }

    // è®¡ç®—æ–°çš„å°æ—¶å’Œåˆ†é’Ÿ
    int newHour = totalMinutes / 60;
    int newMinute = totalMinutes % 60;

    // è¾“å‡ºç»“æœ
    cout << newHour << ":" << newMinute / 10 << newMinute % 10 << endl;

    return 0;
}

```



### æ—¶åŒºè½¬æ¢



```c++
#include <iostream>

using namespace std;

// å°†ç»™å®šæ—¶é—´è½¬æ¢ä¸ºUTCæ—¶é—´
void convertToUTC(int& hour, int& minute, int& offset) {
    // è®¡ç®—UTCæ—¶é—´
    int totalMinutes = hour * 60 + minute - offset;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // è°ƒæ•´åˆ°å‰ä¸€å¤©
    }
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

// å°†UTCæ—¶é—´è½¬æ¢ä¸ºç›®æ ‡æ—¶åŒºçš„æ—¶é—´
void convertToTimeZone(int& hour, int& minute, int& offset) {
    // è®¡ç®—ç›®æ ‡æ—¶åŒºçš„æ—¶é—´
    int totalMinutes = hour * 60 + minute + offset;
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

int main() {
    int hour, minute, offset, targetOffset;
    cout << "Enter hour and minute: ";
    cin >> hour >> minute;
    cout << "Enter offset of current time zone: ";
    cin >> offset;
    cout << "Enter offset of target time zone: ";
    cin >> targetOffset;

    // å°†ç»™å®šæ—¶é—´è½¬æ¢ä¸ºUTCæ—¶é—´
    convertToUTC(hour, minute, offset);

    // å°†UTCæ—¶é—´è½¬æ¢ä¸ºç›®æ ‡æ—¶åŒºçš„æ—¶é—´
    convertToTimeZone(hour, minute, targetOffset);

    cout << "Time in target time zone: " << hour << ":" << minute << endl;

    return 0;
}

```



### æ—¶é—´å·®

```c++
#include <iostream>

using namespace std;

// å°†æ—¶é—´è½¬æ¢ä¸ºåˆ†é’Ÿæ•°
int timeToMinutes(int hour, int minute) {
    return hour * 60 + minute;
}

// è®¡ç®—æ—¶é—´å·®
void calculateTimeDifference(int hour1, int minute1, int hour2, int minute2, int& diffHour, int& diffMinute) {
    // å°†æ—¶é—´è½¬æ¢ä¸ºåˆ†é’Ÿæ•°
    int time1 = timeToMinutes(hour1, minute1);
    int time2 = timeToMinutes(hour2, minute2);

    // è®¡ç®—å·®å€¼
    int diffMinutes = time2 - time1;
    if (diffMinutes < 0) {
        diffMinutes += 24 * 60;  // è°ƒæ•´åˆ°å‰ä¸€å¤©
    }

    // å°†å·®å€¼è½¬æ¢ä¸ºå°æ—¶å’Œåˆ†é’Ÿ
    diffHour = diffMinutes / 60;
    diffMinute = diffMinutes % 60;
}

int main() {
    int hour1, minute1, hour2, minute2;
    cout << "Enter first time (hour and minute): ";
    cin >> hour1 >> minute1;
    cout << "Enter second time (hour and minute): ";
    cin >> hour2 >> minute2;

    int diffHour, diffMinute;
    calculateTimeDifference(hour1, minute1, hour2, minute2, diffHour, diffMinute);

    cout << "Time difference: " << diffHour << " hours " << diffMinute << " minutes" << endl;

    return 0;
}

```

