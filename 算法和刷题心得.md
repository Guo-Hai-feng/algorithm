# 排序算法

### 快速排序

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 20//设记录不超过20个
typedef int KeyType;//设置关键字为整型
typedef struct {//记录每个记录（数据元素）的结构
	KeyType key;//关键字
	//..其他数据项
}RedType;//Record Type

typedef struct {//定义顺序标结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量，r[0]一般做哨兵或缓冲区
	int length;//顺序表的长度,不算缓冲区的长度
}SqList;

int Partion(SqList& L, int low, int high) {
	L.r[0] = L.r[low];
	int pivotkey = L.r[low].key;
	while (low < high) {
		while (low < high && L.r[high].key >= pivotkey) --high;
		L.r[low] = L.r[high];
		while (low < high && L.r[low].key <= pivotkey) ++low;
		L.r[high] = L.r[low];
	}
	L.r[low] = L.r[0];
	return low;//此时high=low=中间位置

}
void QSort(SqList& L, int low, int high) {
	int pivotloc;  
	if (low < high) {
		//长度大于一
		pivotloc = Partion(L, low, high);
		//将L.R[low..high]一分为二，pivotloc为枢轴元素排好序的位置
		QSort(L, low, pivotloc - 1);//对低子表递归排序
		QSort(L, pivotloc + 1, high);//对高子表进行递归排序
	}
}


```

### 希尔排序

```
#include<iostream>
using namespace std;
#define MAXSIZE 20//设记录不超过20个
typedef int KeyType;//设置关键字为整型
typedef struct {//记录每个记录（数据元素）的结构
	KeyType key;//关键字
	//..其他数据项
}RedType;//Record Type

typedef struct {//定义顺序标结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量，r[0]一般做哨兵或缓冲区
	int length;//顺序表的长度
}SqList;


void Shellnsert(SqList &L, int dk){
	int i, j;
	for (i = dk + 1; i <= L.length; i++) {
		if (L.r[i].key < L.r[i - dk].key) {
			L.r[0] = L.r[i];
			for (j = i - dk; j > 0 && (L.r[0].key < L.r[j].key); j = j - dk) {
				L.r[j + dk] = L.r[j];
			}
			L.r[j + dk] = L.r[0];
		}
	}
}
void ShellSort(SqList& L, int dlta[], int t) {
	//按增量序列dlta[0..t-1]对顺序表L做希尔排序
	int k;
	for (k = 0; k < t; ++k) {
		Shellnsert(L, dlta[k]);
	}
}
```

### 选择排序

```
#include<iostream>
using namespace std;
#define MAXSIZE 20//设记录不超过20个
typedef int KeyType;//设置关键字为整型
typedef struct {//记录每个记录（数据元素）的结构
	KeyType key;//关键字
	//..其他数据项
}RedType;//Record Type

typedef struct {//定义顺序标结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量，r[0]一般做哨兵或缓冲区
	int length;//顺序表的长度,不算缓冲区的长度
}SqList;

void selectSort(SqList& L) {
	for (int i = 1; i < L.length; i++) {
		int k = i;
		for (int j = i + 1; j <= L.length; j++) {
			if (L.r[j].key < L.r[k].key) {
				k = j;
			}
		}
		if (k != i) {
			RedType temp;
			temp = L.r[i];
			L.r[i] = L.r[k];
			L.r[k] = temp;
		}
	}
}
```

### 冒泡排序

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 20//设记录不超过20个
typedef int KeyType;//设置关键字为整型
typedef struct {//记录每个记录（数据元素）的结构
	KeyType key;//关键字
	//..其他数据项
}RedType;//Record Type

typedef struct {//定义顺序标结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量，r[0]一般做哨兵或缓冲区
	int length;//顺序表的长度
}SqList;

void bubble_sort(SqList& L) {
	int m, i, j;
	RedType x;//交换时临时存储
	for (m = 1; m < L.length - 1; m++) {
		for (j = 1; j <= L.length - m; j++) {
			if (L.r[j].key > L.r[j + 1].key) {
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;
			}
		}
	}
}

void bubble_sort2(SqList& L) {
	int m, i, j,flag=1;//增加了一个标志
	RedType x;//交换时临时存储
	for (m = 1; m < L.length - 1&&flag==1; m++) {
		flag = 0;
		for (j = 1; j <= L.length - m; j++) {
			if (L.r[j].key > L.r[j + 1].key) {//发生交换次序,flag=1,如果没有发生交换，flag=0
				flag = 1;
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;
			}
		}
	}
}
```

### 折半插入排序

```
#include<iostream>
using namespace std;
#define MAXSIZE 20//设记录不超过20个
typedef int KeyType;//设置关键字为整型
typedef struct {//记录每个记录（数据元素）的结构
	KeyType key;//关键字
	//..其他数据项
}RedType;//Record Type

typedef struct {//定义顺序标结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量，r[0]一般做哨兵或缓冲区
	int length;//顺序表的长度
}SqList;

void BinsertSort(SqList* L) {
	int i, j;
	for (i = 2; i <= L->length; i++) {//依次插入第2~n个元素
		L->r[0] = L->r[i];//当前插入元素存到烧饼位置
		int low = 1, high = i - 1;//采用二分查找法插入位置
		while (low <= high) {
			int mid = (low + high) / 2;
			if (L->r[0].key < L->r[mid].key)
				high = mid - 1;
			else low = mid + 1;
		}//循环结束，high+1是插入位置
		for (j = i - 1; j >= high + 1; --j) L->r[j + 1] = L->r[j];//移动元素
		L->r[high + 1] = L->r[0];//插入到正确位置
	}
}
```

### 直接插入排序

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 20//设记录不超过20个
typedef int KeyType;//设置关键字为整型
typedef struct {//记录每个记录（数据元素）的结构
	KeyType key;//关键字
	//..其他数据项
}RedType;//Record Type

typedef struct {//定义顺序标结构
	RedType r[MAXSIZE + 1];//存储顺序表的向量，r[0]一般做哨兵或缓冲区
	int length;//顺序表的长度
}SqList;

void InsertSorted(SqList &L) {
	int i, j;
	for (i = 2; i < L.length; i++) {
		if (L.r->key < L.r[i - 1].key) {//若"<"马，则需要将L.r[i]插入有序子表
			L.r[0] = L.r[i];//复制为哨兵
			for (j = i - 1; L.r[0].key < L.r[j].key; --j) {
				L.r[j + 1] = L.r[j];//记录后移
				//注意不是移动key值，因为假定为有其他数据项
			}
			L.r[j + 1] = L.r[0];
		}
	}
}

```



### 88力扣合并两个有序数组

注解：课本学到的是构建一个额外的数组，本题固定了这个空间在num1,**所以使用倒叙**就可以了

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1;
        int j=n-1;
        int k=m+n-1;
        while(i>=0&&j>=0){
            if(nums1[i]>=nums2[j]){
                nums1[k]=nums1[i];
                k--;
                i--;
            }
            else{
                nums1[k]=nums2[j];
                k--;
                j--;
            }
        }
        while(i>=0){
            nums1[k]=nums1[i];
            k--;
            i--;
        }
        while(j>=0){
            nums1[k]=nums2[j];
            k--;
            j--;
        }

    }
};
```

### 力扣LCR075数组的相对排序

![image-20240229234611341](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234611341.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            if (rank.count(x)) {
                return rank.count(y) ? rank[x] < rank[y] : true;
            }
            else {
                return rank.count(y) ? false : x < y;
            }
        });
        return arr1;
    }
};
//sort函数接收三个参数，前两个参数是排序的起点和终点迭代器，最后一个参数是一个自定义函数，用来定义排序规则

/*[&]是lambda表达式的捕获列表（Capture List）。在C++中，lambda表达式可以捕获外部作用域中的变量，以便在lambda函数体中使用。捕获列表指定了如何捕获这些变量。

[&]是一种捕获列表的形式，其中的&表示捕获外部作用域中的所有变量并按引用（reference）捕获。这意味着lambda函数体中使用的外部变量都是通过引用访问的，对这些变量的修改会影响到外部作用域中的原始变量。

在这段代码中，lambda表达式 [&](int x, int y) 捕获了所有外部作用域中的变量，并以引用的方式访问它们。这样做的目的是在lambda函数体中可以使用 rank 这个外部作用域中的变量，而不需要额外传递参数。*/

=
```



![image-20240229234951333](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229234951333.png)



```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        for (int i = 0; i < arr2.size(); ++i) {
            rank[arr2[i]] = i;
        }
        auto mycmp = [&](int x) -> pair<int, int> {
            return rank.count(x) ? pair{0, rank[x]} : pair{1, x};
        };
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return mycmp(x) < mycmp(y);
        });
        return arr1;
    }
};
```



![image-20240229235107812](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240229235107812.png)

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        unordered_map<int, int> rank;
        int n = arr2.size();
        for (int i = 0; i < n; ++i) {
            rank[arr2[i]] = i - n;
        }
        sort(arr1.begin(), arr1.end(), [&](int x, int y) {
            return (rank.count(x) ? rank[x] : x) < (rank.count(y) ? rank[y] : y);
        });
        return arr1;
    }
};

```

### 堆排序

#### 15届蓝桥杯爬山

```c++
#include <iostream>
#include<cmath>
#include<queue>
using namespace std;
//堆维护最值+贪心
//时间复杂度nlogn

int main() {
    priority_queue<int>pq;//大根堆
    int n, p, q; cin >> n>>p >> q;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        pq.push(x);
    }

    while (p || q) {
        int cur = pq.top();
        pq.pop();
        if (p) {
            cur = sqrt(cur);
            p--;
        }
        else if(q){
            cur /= 2;
            q--;
        }
        pq.push(cur);
    }

    int s=0;
    while (!pq.empty()) {
        s += pq.top();
        pq.pop();
    }

    cout << s;

    
    return 0;
}

```

### 拓扑排序

#### 207课程表

详情[拓扑排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/topo/)

### 逆序对

给定一个序列𝑎1,𝑎2,…,𝑎𝑛，如果存在𝑎𝑖>𝑎𝑗，那么我们称之为逆序对，求逆序对的数目。 比如：𝑎=[4,2,3,1,5]逆序对有：(4,2)、(4,3)、(4,1)、(2,1)、(3,1)(4,2)、(4,3)、(4,1)、(2,1)、(3,1) 共5对。

我破防了哈哈哈,自己写的代码超时了

![image-20240719110147918](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719110147918.png)

```c++
#include <iostream>
#include <vector>

using namespace std;


long long mergeAndCount(vector<int>& arr, vector<int>& temp, int left, int mid, int right) {
    int i = left; 
    int j = mid + 1; 
    int k = left; 
    long long inv_count = 0; 

    
    while ((i <= mid) && (j <= right)) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        }
        else {
            temp[k++] = arr[j++];

           
            inv_count += (mid + 1) - i;
        }
    }

    
    while (i <= mid)
        temp[k++] = arr[i++];

    
    while (j <= right)
        temp[k++] = arr[j++];

    
    for (i = left; i <= right; i++)
        arr[i] = temp[i];

    return inv_count;
}


long long mergeSortAndCount(vector<int>& arr, vector<int>& temp, int left, int right) {
    long long inv_count = 0;
    if (left < right) {
        int mid = (left + right) / 2;

        
        inv_count += mergeSortAndCount(arr, temp, left, mid);

       
        inv_count += mergeSortAndCount(arr, temp, mid + 1, right);

        
        inv_count += mergeAndCount(arr, temp, left, mid, right);
    }
    return inv_count;
}

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<int> temp(n);
    long long inv_count = mergeSortAndCount(arr, temp, 0, n - 1);

    cout << inv_count << endl;

    return 0;
}


```



# 位运算

### 力扣位1的个数

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;

        // 遍历二进制表示中的每一位
        while (n != 0) {
            // 判断最低位是否为1
            if (n & 1) {
                count++;
            }
            // 右移一位，继续判断下一位
            n >>= 1;
        }

        return count;
    }
};

```



### 异或运算

异或运算的性质如下：

1. 任何数和0做异或运算，结果仍然是原来的数，即 a ^ 0 = a。
2. 任何数和其本身做异或运算，结果是0，即 a ^ a = 0。
3. 异或运算满足**交换律和结合律**，即 a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b。
4. 异或运算可以用来交换两个变量的值，例如：a = a ^ b; b = a ^ b; a = a ^ b;。

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
       int ans=nums[0];
       if(nums.size()>1)
       {
           for(int i=1;i<nums.size();i++)
           {
               ans=ans^nums[i];
           }
       }

    return ans;
    }
};
```

### 力扣汉明距离

int c = 100;

c>>=1//右移一位，表示除二

c>>=2//右移两位，表示除4

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int c = x ^ y;
        int count = 0;
        while(c != 0){
            if(c & 1){
                count +=1;
            }
            c>>=1;
        }
        return count;      
    }
};
```

### 力扣颠倒二进制位

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int count = 32; // 直接设置为32，无需循环计算
        long sum = 0;
        while (n != 0 && count > 0) {
            if (n & 1) {
                sum |= (1 << (count - 1)); // 使用位运算代替求幂操作
            }
            count -= 1;
            n >>= 1;
        }
        return sum;
    }
};

```

`sum |= (1 << (count - 1));` 是一个位运算操作，用于将 `sum` 的第 `(count-1)` 位设置为1。(从第0位开始计数)

1. `(count - 1)` 计算出要设置的位的位置。在二进制中，最低位的位置是0，依次递增。
2. `1 << (count - 1)` 是将数字1左移 `(count - 1)` 位。这实际上是在二进制中将1移动到指定的位置，其余位填充为0。
3. `sum |= (1 << (count - 1));` 利用 `|=` 按位或等于操作符，将 `sum` 的第 `(count-1)` 位设置为1。如果 `sum` 的这一位原本是0，它将变为1；如果原本是1，则保持不变。

#### 检测奇偶性

```c++
#include <iostream>

int main() {
    int number;

    std::cout << "Enter an integer: ";
    std::cin >> number;

    if (number & 1) {
        std::cout << "The number is odd." << std::endl;
    }
    else {
        std::cout << "The number is even." << std::endl;
    }

    return 0;
}

```



#### 循环位移

```c++
#include <iostream>
//不考虑二进制负数

int leftRotate(unsigned int value, int shift) {
    // 使用位运算实现左循环位移
    return (value << shift) | (value >> (sizeof(value) * 8 - shift));
}

int main() {
    unsigned int number = 0b110110;  // 二进制表示为 110110

    // 左循环位移3位
    unsigned int rotatedNumber = leftRotate(number, 3);
    return 0;
}

```



1. `(value << shift)`: 这部分将 `value` 左移 `shift` 位，即将二进制数左移 `shift` 位。例如，如果 `value` 是 `110110`，而 `shift` 是 `3`，那么这部分的结果就是 `110`。
2. `(value >> (sizeof(value) * 8 - shift))`: 这部分是将 `value` 右移 `(sizeof(value) * 8 - shift)` 位。`sizeof(value)` 返回的是 `value` 变量所占用的字节数，通常为 4（32 位系统）或 8（64 位系统）。因此，`(sizeof(value) * 8)` 返回的是 `value` 变量所占用的位数。`(sizeof(value) * 8 - shift)` 就是剩余的位数，即右移的位数。例如，如果 `value` 是 `110110`，而 `shift` 是 `3`，那么这部分的结果就是 `110000000`。
3. `|`: 这是按位或操作符，它会将两个操作数的对应位进行或操作，即只要有一个位是 1，结果的对应位就是 1。

1. 





# 字符串

### 15届蓝桥杯R格式

高精度加法加高精度乘法加快速幂

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0);
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? "0" : ans;
}

int finddot(double d) {
    string dd = to_string(d);
    int i = 0;
    i = dd.find('.');
    return dd.size() - 1 - i;

}

string quickmultiple(int n) {
    string ans = "1";
    string b = "2";
    while (n) {
        if (n & 1) {
            ans = multiple(ans, b);
        }
        b = multiple(b,b);
        
        n >>=1;
    }
    return ans;
}

//再写一个高精度加法，万一是999.5
int main() {
    int n;
    string d;
    cin >> n >> d;
    int dotindex = d.find('.');
    int count = d.size() - dotindex - 1;
    d.erase(d.begin() + dotindex, d.begin() + dotindex + 1);
    string two = quickmultiple(n);
    string ans = multiple(two, d);
   
    //不是简单的向上取整
    int judge = ans[ans.size() - count] - '0';
    if (judge > 4) {
        int carry = 1;
        int n = ans.size()-count;
        while (n--) {      
           int sum= ans[n] -'0'+carry;
           ans[n] = sum % 10 + '0';
           carry = sum / 10;
        }
        if (carry != 0) {
            ans.insert(ans.begin(), carry % 10 + '0');
        }

        ans.resize(ans.size() - count);

        cout << ans;
        
    }
    else {
        ans.resize(ans.size() - count);
        cout << ans;

    }
    
    return 0;
}

```





### 十六进制转八进制

数据范围：保证每个十六进制数，位数不多余100000位

第一行输入n表示有n个十六进制数

第2-n+1行输入十六进制数



//需要注意的是这个数太大，我们只能通过字符串读取

```c++
#include<bits/stdc++.h>
using namespace std;
string hextobin(string hexstring) {
	string binstring;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': binstring += "0000";
			break;
		case '1': binstring += "0001";
			break;
		case '2': binstring += "0010";
			break;
		case '3': binstring += "0011"; 
			break;
		case '4': binstring += "0100";
			break;
		case '5': binstring += "0101";
			break;
		case '6': binstring += "0110";
			break;
		case '7': binstring += "0111";
			break;
		case '8': binstring += "1000";
			break;
		case '9': binstring += "1001";
			break;
		case 'A': binstring += "1010";
			break;
		case 'B': binstring += "1011";
			break;
		case 'C': binstring += "1100";
			break;
		case 'D': binstring += "1101";
			break;
		case 'E': binstring += "1110";
			break;
		case 'F': binstring += "1111";
			break;
		}
	}
	return binstring;
}

string bintooct(string binstring){
	string octstring;
	int n=binstring.size();
	string tmp;
	int tmpt;
	for(int i=0;i<n;i+=3){
		tmp=binstring.substr(i,3);
		tmpt=((tmp[0]-'0')*pow(2,2))+((tmp[1]-'0')*pow(2,1))+(tmp[2]-'0');
		octstring+=tmpt+'0';
	}
	return octstring;
}
int main() {
	int n;
	cin >> n;
	string hexstring,binstring,octstring;
	for (int i = 0; i < n; i++) {
		cin >> hexstring;
		binstring=hextobin(hexstring);
		int addzero=3-(binstring.size()%3);
		binstring.insert(0,addzero,'0');
		octstring=bintooct(binstring);
		cout<<octstring<<endl;
	}

	return 0;

}

```



### 十六进制转十进制

题目条件是不大于八位的十六进制数，八位的最大值是FFFFFFFF，恰好是64位int的最大值

```c++
#include<bits/stdc++.h>
using namespace std;
int hextodec(string hexstring){
	string decstring;
	int ans;
	int n=hexstring.size();
	for (int i=0;i<n;i++) {
		switch (hexstring[i]) {
		case '0': ans+=0;
			break;
		case '1': ans+=pow(16,n-i-1);
			break;
		case '2': ans+=2*pow(16,n-i-1);
			break;
		case '3': ans+=3*pow(16,n-i-1); 
			break;
		case '4': ans+=4*pow(16,n-i-1);
			break;
		case '5': ans+=5*pow(16,n-i-1);
			break;
		case '6': ans+=6*pow(16,n-i-1);
			break;
		case '7': ans+=7*pow(16,n-i-1);
			break;
		case '8': ans+=8*pow(16,n-i-1);
			break;
		case '9': ans+=9*pow(16,n-i-1);
			break;
		case 'A': ans+=10*pow(16,n-i-1);
			break;
		case 'B': ans+=11*pow(16,n-i-1);
			break;
		case 'C': ans+=12*pow(16,n-i-1);
			break;
		case 'D': ans+=13*pow(16,n-i-1);
			break;
		case 'E': ans+=14*pow(16,n-i-1);
			break;
		case 'F': ans+=15*pow(16,n-i-1);
			break;
			}
		}
	return ans;	
}



int main() {
	string hexstring;
    int decstring;
    cin >> hexstring;
	decstring=hextodec(hexstring);
	cout<<decstring;

	return 0;

}
```



### 十进制转16进制

题目要求的是该数字在int的范围之内

偷懒做法：

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	cout<<hex<<num;
	return 0;

}
```



辗转相除

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int num;
	cin>>num;
	string hexstring="";
	while(num>0){
		int x=num%16;
		switch(x){
			case 0: hexstring.insert(0,"0");
				break;
			case 1: hexstring.insert(0,"1");
				break;
			case 2: hexstring.insert(0,"2");
				break;
			case 3: hexstring.insert(0,"3");
				break;
			case 4: hexstring.insert(0,"4");
				break;
			case 5: hexstring.insert(0,"5");
				break;
			case 6: hexstring.insert(0,"6");
				break;
			case 7: hexstring.insert(0,"7");
				break;
			case 8: hexstring.insert(0,"8");
				break;
			case 9: hexstring.insert(0,"9");
				break;
			case 10: hexstring.insert(0,"A");
				break;
			case 11: hexstring.insert(0,"B");
				break;
			case 12: hexstring.insert(0,"C");
				break;
			case 13: hexstring.insert(0,"D");
				break;
			case 14: hexstring.insert(0,"E");
				break;
			case 15: hexstring.insert(0,"F");
				break;
		}
		num/=16;  
	}
	cout<<hexstring;
	
	return 0;

}
```

如果需要排序字典序的，有时候可以利用数组，数组下标表示字典序，因为'a'的ASCII码是97，z的ASCII码是122，所以都减去97，得到1~25的值

### 蓝桥日期问题（103）

![image-20240227213938918](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240227213938918.png)

```c++
#include<iostream>
using namespace std;
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//检查日期是否合法
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
int main() {
	int a, b, c;
	scanf("%d/%d/%d", &a, &b, &c);//第一步格式输入
	for (int i = 19600101; i <= 20591231; i++) {
		int y = i / 10000;//i/10000的意思是从后面截断四位数，舍去，只留前面的
		int m = i % 10000 / 100;//i%10000的意思是从后面截断四位数，只留后面的
		int d = i % 100;//求一个数的后两位
		if (check(y, m, d)) {
			if ((y % 100 == a && m == b && d == c) || (y % 100 == c && m == b && d == a) ||
				(y % 100 == c && m == a && d == b)) {
				printf("%d-%02d-%02d\n", y, m, d);//注意格式打印
			}
		}

	}
}
```

常见的判断日期是否合法可以用到的代码

```c++
const int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
bool check(int y, int m, int d) {
	//检查日期是否合法
	if (m == 0 || m>12||d==0) return false;
	if (m != 2 && d > days[m]) return false;
	if (m == 2) {
		if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0) {
			if (d > 29) return false;
		}
		else {
			if (d > 28) return false;
		}
	}
	return true;

}
```



### 力扣判断回文串

判断一个串是否是回文串：双指针

```c++
bool check(string s){
    for(int i=0;j=s.size()-1;i<j;i++,j--){
        if(s[i]!=s[j]) return false;
    }
    return true;
}
```

### 蓝桥刷题统计2098

n的大小给到了10e18,要开long long

```c++
#include <iostream>
using namespace std;
typedef long long ll;
int main()
{
  // 请在此输入您的代码
  ll a,b,n;
  scanf("%lld%lld%lld",&a,&b,&n);
  ll m=a*5+b*2;
  ll wsum=n/m;
  ll ans=wsum*7;
  n%=m;
  int w=1;
  while(n>0){
    if(w==8){
      w=1;
    }
    if(w<=5){//如果今天在周一到周五
      n-=a;
    }
    else{//如果今天在周末
      n-=b;
    }
    w++;
    ans++;
  }
  printf("%lld",ans);


  return 0;
}
```



### 力扣交换字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**双指针**

```java
    public void reverseString(char[] s) {
        int length = s.length;
        //两个指针一个从第1个，一个从最后一个开始，
        //两两交换
        int left = 0;
        int right = length - 1;
        while (left < right) {
            swap(s, left++, right--);
        }
    }

    private void swap(char[] array, int i, int j) {
        //第1种交换方式
        char temp = array[i];
        array[i] = array[j];
        array[j] = temp;

        //第2种交换方式
//        array[i] = (char) (array[i] + array[j]);
//        array[j] = (char) (array[i] - array[j]);
//        array[i] = (char) (array[i] - array[j]);

        //第3种交换方式
//        array[i] = (char) (array[i] - array[j]);
//        array[j] = (char) (array[i] + array[j]);
//        array[i] = (char) (array[j] - array[i]);

        //第4种交换方式
//        array[i] ^= array[j];
//        array[j] ^= array[i];
//        array[i] ^= array[j];
    }


```





```c++
#include<iostream>
#include<vector>
using namespace std;
class Solution {
public:
    void reverseString(vector<char>& s) {
        if (s.empty() || s.size() == 0)
        {
            return;
        }
        reverseStringhelper(s, 0, s.size() - 1);
    }
    void reverseStringhelper(vector<char>& s, int left, int right)
    {
        if (left >= right)
        {
            return;
        }
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        reverseStringhelper(s, ++left, --right);
    }
};
```

### 力扣翻转数字

core:**判断整数溢出**

```java
//何其幸运能够学习到如此美妙的算法!!!!
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0) {
            //每次取末尾数字
            int tmp = x%10;
            //判断是否 大于 最大32位整数
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
    }
}
```

### 力扣字符串第一个不重复的字符

给定一个字符串 `s` ，找到 *它的第一个不重复的字符，并返回它的索引* 。如果不存在，则返回 `-1` 

```c++
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<int, int> frequency;
        for (char ch: s) {
            ++frequency[ch];
        }
        for (int i = 0; i < s.size(); ++i) {
            if (frequency[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};

```

### 蓝桥字符串转化成整数

![image-20240302195337802](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302195337802.png)

1.**字符串去除前导空格**

cin输入自动去除空格！！！

**转化成数字时判断溢出**

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231205163818189.png" alt="image-20231205163818189" style="zoom: 80%;" />



**完整代码**

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s;
    cin >> s;

    // 判断是否为空字符串
    if (s.empty()) {
        cout << 0;
        return 0;
    }

    int i = 0;
    bool flag = true; // 默认为正数
    int res = 0;

    // 处理负号
    if (s[0] == '-') {
        flag = false;
        i++;
    }

    // 去除前导零
    while (i < s.size() && s[i] == '0') {
        i++;
    }

    // 处理数字部分
    while (i < s.size()) {
        int tmp = s[i] - '0';

        // 判断是否会溢出
        if ((res > INT_MAX / 10) || (res == INT_MAX / 10 && tmp > INT_MAX % 10)) {
            cout << (flag ? INT_MAX : INT_MIN);
            return 0;
        }

        // 更新结果
        res = res * 10 + tmp;
        i++;
    }

    cout << (flag ? res : -res);
    return 0;
}

```

**自动机做法**

```python
INT_MAX = 2 ** 31 - 1
INT_MIN = -2 ** 31

class Automaton:
    def __init__(self):
        self.state = 'start'
        self.sign = 1
        self.ans = 0
        self.table = {
            'start': ['start', 'signed', 'in_number', 'end'],
            'signed': ['end', 'end', 'in_number', 'end'],
            'in_number': ['end', 'end', 'in_number', 'end'],
            'end': ['end', 'end', 'end', 'end'],
        }
        
    def get_col(self, c):
        if c.isspace():
            return 0
        if c == '+' or c == '-':
            return 1
        if c.isdigit():
            return 2
        return 3

    def get(self, c):
        self.state = self.table[self.state][self.get_col(c)]
        if self.state == 'in_number':
            self.ans = self.ans * 10 + int(c)
            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)
        elif self.state == 'signed':
            self.sign = 1 if c == '+' else -1

class Solution:
    def myAtoi(self, str: str) -> int:
        automaton = Automaton()
        for c in str:
            automaton.get(c)
        return automaton.sign * automaton.ans


```

### 蓝桥串的处理

![image-20240208145227753](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208145227753.png)

**1.输入，cin和scanf一样，会截断空格**

**2.输出,记得cout输出变量时会输出字符，但是如果只是一个计算结果，如cout<<s-32此时会输出数字,所以在本题解中进行了类型转换**

```c++
#include<iostream>
#include<string>
using namespace std;
void change(char& ch) {
	ch = ch - 32;//把小写字母大写
}
int main() {
	string ss;
	getline(cin, ss);//getline也没有截断的特性，即接收空格
	int len = ss.length();
	if (isalpha(ss[0])) {
		change(ss[0]);
	}
	for (int i = 0, j = 1; i < len; i++, j++) {
		if (ss[i] == ' '&&j<len) {
			if (ss[j] == ' ') continue;
			else {
				//如果ss[i]是空格而ss[j]不是空格，说明是单词开头
				cout << ss[i];
				change(ss[j]);
			}
		}
		else if ((isdigit(ss[i]) && isalpha(ss[j])) || (isalpha(ss[i]) && isdigit(ss[j]))) {
			cout << ss[i] << '_';
		}

		else {
			cout << ss[i];
		}
		
	}
	return 0;
}
```

### 蓝桥密文搜索

![image-20240208180432011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240208180432011.png)



```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
map<string, int>mp;
string str, s;
int n;
int main() {
	cin >> str >> n;
	while (n--) {
		cin >> s;
		sort(s.begin(), s.end());
		mp[s]++;
	}
	int ans=0;
	cout << endl;
	for (int i = 0; i <= str.size() - 8; i++) {
		string t = str.substr(i, 8);
		sort(t.begin(), t.end());
		ans += mp[t];
	}

	return 0;
}
```



### 哈希表实例

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义哈希表的节点结构
typedef struct Node {
    char key;
    int count;
    struct Node* next;
} Node;

// 定义哈希表结构
typedef struct {
    Node** array;
    int size;
} HashMap;

// 初始化哈希表
HashMap* initHashMap(int size) {
    //问题一
    //头节点是一个哈希表指针，初始化不用开辟多余空间！！！
    HashMap* hashMap = (HashMap*)malloc(sizeof(HashMap));
    if (hashMap == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    hashMap->size = size;
    
    //问题二，一般都用一个二维指针来存储哈希桶，经过我浪费的时间来看，这样构建比较简单！！！
    //注意二维数组的构建哦，这里使用了calloc函数一次到位了，否则还要多一个for循环来实现二维数组的动态分配内存
    hashMap->array = (Node**)calloc(size, sizeof(Node*));
    if (hashMap->array == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }

    return hashMap;
}

// 哈希函数，简单地返回字符的ASCII码对哈希表大小取余
int hashFunction(char key, int size) {
    return (int)key % size;
}

// 在哈希表中查找节点
Node* findNode(HashMap* hashMap, char key) {
    //首先找到哈希桶中对应的的位置
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];

    //在该位置中找是否有符合条件的
    while (current != NULL) {
        if (current->key == key) {
            return current;
        }
        current = current->next;
    }

    return NULL;
}

// 插入节点或更新计数
void insertOrUpdate(HashMap* hashMap, char key) {
    //老规矩，找到哈希桶中对应的位置
    int index = hashFunction(key, hashMap->size);
    Node* current = hashMap->array[index];
    //查找，看是否找到，如果原结构中已经有了，就计数加一
    Node* node = findNode(hashMap, key);

    if (node != NULL) {
        // 节点已存在，更新计数
        node->count++;
    } 
    //如果没找到，需要头插法加入哈希桶对应的位置中去哦
    else {
        // 节点不存在，插入新节点
        Node* newNode = (Node*)malloc(sizeof(Node));
        if (newNode == NULL) {
            perror("Memory allocation failed");
            exit(EXIT_FAILURE);
        }

        newNode->key = key;
        newNode->count = 1;
        
        //头插法
        newNode->next = current;
        hashMap->array[index] = newNode;
    }
}

// 统计字符串中每个字符的出现次数
void countCharacters(HashMap* hashMap, const char* str) {
    while (*str != '\0') {
        insertOrUpdate(hashMap, *str);
        str++;
    }
}

// 打印哈希表内容
void printHashMap(HashMap* hashMap) {
    printf("Character Counts:\n");
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            printf("'%c': %d\n", current->key, current->count);
            current = current->next;
        }
    }
}

// 释放哈希表的内存
void freeHashMap(HashMap* hashMap) {
    for (int i = 0; i < hashMap->size; i++) {
        Node* current = hashMap->array[i];
        while (current != NULL) {
            Node* next = current->next;
            free(current);
            current = next;
        }
    }
    free(hashMap->array);
    free(hashMap);
}

int main() {
    const char* inputString = "programming";
    int hashMapSize = 10;

    HashMap* hashMap = initHashMap(hashMapSize);

    countCharacters(hashMap, inputString);

    printHashMap(hashMap);

    freeHashMap(hashMap);

    return 0;
}

```



### 力扣67二进制求和

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int la=a.size();
        int lb=b.size();
        while(la<lb){
            a='0'+a;
            ++la;    
        }
        while(lb<la){
            b='0'+b;
            ++lb;         
        }
        
        int j=b.size()-1;
        for(j;j>0;j--){
            a[j]=a[j]-'0'+b[j];//把字符串转化成数字相加再转化回来
            if(a[j]>='2'){
                a[j]=(a[j]-'0')%2+'0';
                a[j-1]=a[j-1]+1;//注意这里！字符2和字符1的ASCII码只相差1

            }            
        }
        
        //涉及到进位问题，我们需要单独把第零位拿出来算
        a[0]=a[0]-'0'+b[0];
        if(a[0]>='2'){
                a[0]=(a[0]-'0')%2+'0';
                a='1'+a;

            }
            return a;
    }
};
```





### 去除两端空格

```c++
int main() {
    string s = "     hello    ";
    int i = 0;
    for (i; s[i] == ' '; i++);
    int j = 0;
    for (j = s.size(); s[j] == ' '; --j);
    int n = j - i + 1;
    s = s.substr(i, n);
    cout << s;
}

```

### 去除适当空格，使字符串表示一个正确的句子

```c++
#include <iostream>
#include <sstream>
using namespace std;
void trim(string &s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    你好       世界   巴拉巴拉     ";
    trim(s);
    int i = 0;
    while (i < s.size()) {
        if (s[i] == ' ') {
            int j = i;
            while (s[j] == ' ') j++;
            s.replace(i, j-i, " ");
            i+=1;
            continue;
        }
        i++;      
    }
    cout << s;   
    return 0;
}



```



### 力扣500键盘行

变化的哈希表，题解设置了每个字母所在的行号，使得查询变得快捷

遍历啦

```c++
class Solution {
public:
    vector<string> findWords(vector<string>& words) {
        vector<string> ans;
        string rowIdx = "12210111011122000010020202";
        for (auto & word : words) {
            bool isValid = true;
            char idx = rowIdx[tolower(word[0]) - 'a'];
            for (int i = 1; i < word.size(); ++i) {
                if(rowIdx[tolower(word[i]) - 'a'] != idx) {
                    isValid = false;
                    break;
                }
            }
            if (isValid) {
                ans.emplace_back(word);
            }
        }
        return ans;
    }
};

```

### 去除字符串指定字符

比如我想去除字符串里面的空格

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

void trim(string& s) {
    int len = s.size();
    int i = 0, j = 0;
    for (i; s[i] == ' '; i++);
    for (j = len - 1; s[j] == ' '; j--);
    s = s.substr(i, j - i + 1);
}
int main() {
    std::string s = "    你好       世界   巴拉巴拉     ";
    trim(s);
    int i = 0;
    int k = 0;
    int n = s.size();
    while (i < n) {
        if (s[i] == ' ') k++;
        else s[i - k] = s[i];
        i++;
    }
    s.resize(n - k);
    cout << s;
    return 0;
}
```

### 力扣100330操作后字符串的最短长度

先看两个代码，我真的破防了

```c++
class Solution {
public:
    int minimumLength(string s) {
        int n = s.size();
        unordered_map<char, int>a;
        int i = 0;
        while (i < s.size()) {
            a[s[i]]++;
            if (a[s[i]] == 3) {
                int k = 0;
                for (; s[k] != s[i]; k++);

                s.erase(k, 1);
                s.erase(i - 1, 1);
                a.clear();
                i = 0;

            }
            else i++;

        }

        return s.size();
    }
};
//这个是你写的狗屎代码，时间复杂度太高了
```





```c++
//这个是别人写的代码
//基本思路就是，记录每个字符出现的次数，如果该字符出现的次数小于3，那么这个字符的数量就全部保留在操作后的数组中
//如果这个字符的数量大于3，并且个数为奇数，那么这个字符会被删除到只为1个
//如果这个字符的数量大于3并且个数是偶数，那么这个字符会被删除到只有2个

class Solution {
public:
    int minimumLength(string s) {
        unordered_map<char,int>a;
        int n=s.size();
        for(int i=0;i<n;i++) a[s[i]]++;
        int cnt=0;

        for(auto i:a){
            if(i.second<3) cnt+=i.second;
            else if(i.second%2==1) cnt+=1;
            else cnt+=2;
        }
        return cnt;

    }
};
```



### 力扣100360将1移动到末尾位置的最大操作次数

这一道题和上面那道题我记一辈子，羞辱我啊啊啊啊

本题的题解其实你已经知道大概怎么写了，但是思路还是不够清晰

具体请看别人写的清晰的代码

```c++
class Solution {
public:
    int maxOperations(string s) {
        int n=s.size();
        int cnt=0;
        int cnt_num1=0;
        for(int i=0;i<n;i++){
            if(s[i]=='1') cnt_num1++;
            else if(i&&s[i-1]=='1'){
                cnt+=cnt_num1;
            }
        }
        return cnt;
        
    }
};
```

### 括号匹配

```c++
#include<iostream>
#include<string>
using namespace std;
typedef char ElemType;
const int MaxSize = 30;
typedef struct {
	ElemType data[MaxSize];
	int top;
}SqStack;

void init(SqStack*& s) {
	s = (SqStack*)malloc(sizeof(SqStack));
	s->top = -1;
}

void DestoryStack(SqStack*& s) {
	free(s);
}

bool StackEmpty(SqStack* s) {
	return s->top == -1;
}

bool push(SqStack*& s, ElemType e) {
	if (s->top == MaxSize) return false;
	else {
		s->top++;
		s->data[s->top] = e;
		return true;
	}
}

bool pop(SqStack*& s, ElemType& e) {
	if (s->top == -1) return false;
	else {
		s->top--;
		e = s->data[s->top];
		return true;
	}
}

bool GetTop(SqStack* s, ElemType& e) {
	if (s->top == -1) return false;
	e = s->data[s->top];
	return true;
}
bool BracketMatching(string s) {
	SqStack* a;
	init(a);
	int n = s.size();
	for (int i = 0; i < n; i++) {
		char ch = s[i];
		switch (ch) {
		case '(':
		case '[':
		case '{':
			push(a, ch);
			break;
		case ')':
			if (GetTop(a, ch)) {
				if (ch != '(') return false;
				pop(a, ch);
			}
			else return false;
			break;
		case ']':
			if (GetTop(a, ch)) {
				if (ch != '[') return false;
				pop(a, ch);
			}
			else return false;
			break;
		case '}':
			if (GetTop(a, ch)) {
				if (ch != '{') return false;
				pop(a, ch);
			}
			else return false;
			break;
		}
	}
	DestoryStack(a);
	return true;

}
```



# 顺序表

哑节点dummy，如果题目不给哨兵节点的话，可以自己开辟一个，计算比较方便

### 力扣237删除链表的节点

```c
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val=node->next->val;
        node->next=node->next->next;
      
        
    }
};
```



### 力扣合并两个链表



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
//我是小猫怪，遇到好的题解只会大喊：喵！！！！！！
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* pstr1 = list1;
    struct ListNode* pstr2 = list2;
    struct ListNode* head = NULL; // 用于保存合并后的链表的头指针
    struct ListNode* tail = NULL; // 用于保存合并后的链表的尾指针

    while (pstr1 && pstr2) {
        // 比较两个链表的当前节点值，将较小值的节点插入合并后的链表
        if (pstr1->val <= pstr2->val) {
            if (tail == NULL) {
                head = tail = pstr1;
            } else {
                tail->next = pstr1;
                tail = pstr1;
            }
            pstr1 = pstr1->next;
        } else {
            if (tail == NULL) {
                head = tail = pstr2;
            } else {
                tail->next = pstr2;
                tail = pstr2;
            }
            pstr2 = pstr2->next;
        }
    }

    // 处理剩余的节点
    if (pstr1 != NULL) {
        if (tail == NULL) {
            head = pstr1;
        } else {
            tail->next = pstr1;
        }
    } else if (pstr2 != NULL) {
        if (tail == NULL) {
            head = pstr2;
        } else {
            tail->next = pstr2;
        }
    }

    return head;
}

```



### 快慢指针

1.快指针每次走两步，慢指针每次走一步，快指针到达链表尾部时，因为慢指针走的步数一定是快指针的一半，所以此时慢指针在链表中部

2.快指针先走k-1步，然后慢指针和快指针再每次都走一步，当快指针到链表尾部时，慢指针此时就在链表的倒数第k个节点

3.快指针每次走两步，慢指针每次走一步，如果快慢指针能相遇，说明链表有环，此时让快指针重新回到头指针的位置然后让快慢指针每次都走一步，下次相遇的节点就是入环节点

![image-20240302230930445](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240302230930445.png)

第一次相遇之后，如果fast回到头节点，则它走了l步时，慢指针走了（n-1）+c-x步，正好在入环节点



4.**fast走3步，4步，5步或者走n步呢，请证明**

结论：fast走n步n如果大于2，不一定会相遇。

如果fast一次走三步。，slow进环以后，他们的距离是n。

假设n是偶数，则它们的距离变化：n   n-2   n-4   n-6...2 0,如果n是奇数，它们的距离变化：n   n-2   n-4   n-6...1 -1;所以如果n是偶数能追上，n是奇数追不上

如果fast一次走4步，则它们的距离变化为n   n-3   n-6...同以上分析

### 力扣92翻转链表2

穿针引线，先翻转目标链表，在把链表连起来

```c++
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // 也可以使用递归反转一个链表
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // 注意：切断链接
        pre->next = nullptr;
        rightNode->next = nullptr;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};


```

### 力扣86分隔链表

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smlDummy = new ListNode(0), *bigDummy = new ListNode(0);
        ListNode *sml = smlDummy, *big = bigDummy;
        while (head != nullptr) {
            if (head->val < x) {
                sml->next = head;
                sml = sml->next;
            } else {
                big->next = head;
                big = big->next;
            }
            head = head->next;
        }
        sml->next = bigDummy->next;
        big->next = nullptr;
        return smlDummy->next;
    }
};

```

### 力扣143重排链表

```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        ListNode* mid = middleNode(head);
        ListNode* l1 = head;
        ListNode* l2 = mid->next;
        mid->next = nullptr;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    void mergeList(ListNode* l1, ListNode* l2) {
        ListNode* l1_tmp;
        ListNode* l2_tmp;
        while (l1 != nullptr && l2 != nullptr) {
            l1_tmp = l1->next;
            l2_tmp = l2->next;

            l1->next = l2;
            l1 = l1_tmp;

            l2->next = l1;
            l2 = l2_tmp;
        }
    }
};

```

### 力扣82删除重复元素

### 力扣155最小栈

### 力扣1249移除无效的括号

思路：如果是左括号，那么就入栈，如果是右括号，有两种情况，栈为空，说明之前的括号完全匹配，删除即可，如果栈不为空，说明栈顶的左括号和该右括号匹配，出栈左括号

```c++
class Solution {
public:
    string minRemoveToMakeValid(string s) {
        stack<int> braket;
        int sLen = s.size();
        for(int i =0; i<sLen ; ++i){
            if(s[i] == '(' || s[i] == ')'){
                if(s[i] == '(') braket.push(i);
                else if(braket.empty()) {
                    s.erase(i,1);
                    --sLen;//这是一个非常有意思的写法
                    //一般来说因为删除字符串元素之后，字符串大小会改变，所以for循环的条件应该是
                    //i<s.size()
                    //但是这个时间复杂度比较高
                    //所以使用这个变量
                    --i;
                }
                else braket.pop();
            }
        }
        while(!braket.empty()){
            int i = braket.top();
            s.erase(i,1);
            braket.pop();
        }
        return s;
    }
};
```

### 力扣227基本运算器

不多说，审题，题目已经加粗标黑了条件，没有负数，没有括号，简化板的求后缀表达式再求值

注意根据后缀表达式求值的时候，

int a=pop();

int b=pop();

结果都是b-a。还有除零错误的规避

### 力扣1441

栈的特点，先进的元素一定先出，所以对于严格递增序列，想要构建135这样的数组，必须要进栈2，再出栈2，进栈4，再出栈4这样

### 返回元素第K大元素

```c++
#include<bits/stdc++.h>
int main(){
    priority_queue<int>a;
    vector<int>b;
    for(int num:b){
        a.push(num);
        if(a.size()>k) a.pop();
    }
    return a.top();
}
```

### 力扣2两数相加



# 数学/设计

### 最小公倍数

数学上：求A  B的最小公倍数=A*B/GCD(最大公约数)

### 最大公约数

辗转相除算法

辗转相除法一般指欧几里得算法。是指用于计算两个非负整数a，b的最大公约数。那么辗转相除法的原理是什么？

1、 原理：设两数为a、b(ab)，用gcd(a，b)表示a，b的最大公约数，r=a(mod b)为a除以b的余数，k为a除以b的商，即a÷b=k。。。。。。。r。辗转相除法即是要证明gcd(a，b)=gcd(b，r)。

2、 第一步：令c=gcd(a，b)，则设a=mc，b=nc。

3、 第二步：根据前提可知r=a-kb=mc-knc=(m-kn)c。

4、 第三步：根据第二步结果可知c也是r的因数。

5、 第四步：可以断定m-kn与n互质(假设m-kn=xd，n=yd(d1)，则m=kn+xd=kyd+xd=(ky+x)d，则a=mc=(ky+x)cd，b=nc=ycd，则a与b的一个公约数cdc，故c非a与b的最大公约数，与前面结论矛盾)，因此c也是b与r的最大公约数。

6、 从而可知gcd(b，r)=c，继而gcd(a，b)=gcd(b，r)。

7、 证毕。以上步骤的操作是建立在刚开始时r≠0的基础之上的。即m与n亦互质。

```c++
//辗转相除法
int main() {
	int a;
	int b;    
	printf("请输入两个正整数：");
	scanf("%d %d", &a, &b);
	int k = 0;
	while (k = a % b) {
		a = b;
		b = k;
	}
	printf("最大公约数为:%d\n", b);
	return 0;
}
```



### 埃氏筛

质数筛是一种用于**找出一定范围内所有质数的算法**。其中最著名的是埃拉托斯特尼斯筛法（Sieve of Eratosthenes）。这个算法的基本思想是从小到大依次标记并删除每个数的倍数，最终剩下的未被标记的数就是质数。

二刷，记得在分配空间时多分配一个

该算法的思想是：质数的个数一定不是质数

100以内的质数的个数是25个

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	//质数筛
	vector<int>arr(101,1);
	int n;
	cin>>n;
	arr[2]=true;
	for(int i=2;i*i<=n;i++){
		if(arr[i]==1){
			for(int j=i*i;j<=n;j+=i){
				arr[j]=0;
			}
		}
	}
	
	for(int i=2;i<=n;i++){
		if(arr[i]) cout<<i<<' ';
	}
    return 0;
}

```





### 欧拉筛

欧拉筛法的主要思想是每个合数只会被它的最小质因数标记一次，这样可以减少重复操作，从而提高效率。



```c++
#include <iostream>
#include <vector>
using namespace std;
vector<int> eulerSieve(int n) {
    vector<bool> is_prime(n + 1, true);  // 初始化布尔数组
    vector<int> primes;  // 存储质数的数组

    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);  
        }


        for (int j = 0; j < primes.size() && primes[j] * i <= n; ++j) {
            //首先对于质数35，它的因子有1 5 7 35，它的最小质因子是5
            
            is_prime[primes[j] * i] = false;  // 标记合数
            //如果i能够整除primes[j],那么根据上一行代码，对于任何大于primes[j]的质数primes[k]
            //其乘积primes[k]*i会被后续的质数标记，所以停止循环，避免很多不必要的标记
            //同时也使一个合数只被标记一次
            if (i % primes[j] == 0) {
                break;  // 如果 i 能被 primes[j] 整除，跳出循环
            }
        }
    }
    return primes;
}

int main() {
    int n;
    cout << "请输入一个正整数 n：";
    cin >> n;

    vector<int> primes = eulerSieve(n);

    cout << "小于等于 " << n << " 的质数有：";
    for (int prime : primes) {
        cout << prime << " ";
    }
    cout << endl;

    return 0;
}

```



### 



### 约数问题

$$
36=2^2*3^2\\那么36的约数个数=（2+1）*（2+1）
\\36的约数之和=(2^0+2^1+2^2)*(3^0+3^1+3^2)
$$



#### 求一个数的全部约数

约数的概念很简单，如果a 能够整除b ，那么a 是 b的约数， b是 a的倍数。

求一个数的所有约数，算法思想和求质数一样，如果i整除n,那么n/i也整除n

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

const int N = 1e5 + 5;


vector<int>get_divisors(int n) {
	vector<int>res;
	for (int i = 1; i <= n / i; i++) {
		if (n % i == 0) {
			res.push_back(i);
			if (i != n / i) res.push_back(n/i);  // 这个判断是防止加两次 n/i 进去
		}
	}
	//sort(res.begin(), res.end());  // 如果不要求排序，也可以不用。
	return res;
	
}
int main() {
	int n;
	cin >> n;
	vector<int>res=get_divisors(n);
	for (auto i : res) cout << i << " ";
	return 0;
}
```



#### 求一个数的约数的个数

![image-20240725171217346](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240725171217346.png)

```c++
#include <iostream>
#include<unordered_map>
using namespace std;
const int MOD = 1e9 + 7;
using namespace std;
  
unordered_map<int, int> mp;

void get_cnt(int n) {
	for (int i = 2; i <= n / i; i++) {  // 分解质因数
		while (n % i == 0) {
			n /= i;
			mp[i]++;  // 统计这个质因数的指数
		}
	}
	if (n > 1) mp[n]++;  // 单独处理比 n/i 大的质因子
}

int main() {
	int n, x;
	long long res = 1;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		get_cnt(x);
	}

	for (auto i : mp) res = res * (i.second + 1) % MOD;  // 计算结果
	cout << res;
	return 0;
}
```



#### 约数之和

![image-20240725173415720](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240725173415720.png)

初始时，`sum = 1`。

第一次循环：`sum = (1 * a + 1) % MOD = (a + 1) % MOD`。

第二次循环：`sum = ((a + 1) * a + 1) % MOD = (a^2 + a + 1) % MOD`。

第三次循环：`sum = ((a^2 + a + 1) * a + 1) % MOD = (a^3 + a^2 + a + 1) % MOD`。

```c++
#include <iostream>
#include<unordered_map>
using namespace std;
const int MOD = 1e9 + 7;
unordered_map<int, int> mp;
void get_cnt(int num) {
	for (int i = 2; i <= num; i++) {
		while (num % i == 0) {
			mp[i]++;
			num /= i;
		}
	}

	//这里忘记了！！！
	if (num > 1) mp[num]++;
}

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int temp;
		cin >> temp;
		get_cnt(temp);
	}
	long long res = 1;
	for (auto i : mp) {
		long long sum = 1, a = i.first, b = i.second;
		while (b--) {
			sum = (sum * a + 1) % MOD;
		}
		res = (res * sum) % MOD;
	}

	cout << res;

	return 0;
}
```



### 把数字转化成字符串

```c++
#include <iostream>
#include <string>

std::string intToString(int number) {
    // 处理特殊情况，如果数字是0，直接返回字符串"0"
    if (number == 0) {
        return "0";
    }

    std::string result;  // 用于存储最终的字符串结果

    // 处理负数情况
    if (number < 0) {
        result.push_back('-');
        number = -number;  // 将负数转换为正数进行处理
    }

    // 逐位提取数字并转换为字符，然后拼接到结果字符串中
    while (number > 0) {
        char digit = '0' + (number % 10);  // 提取最后一位数字并转换为字符
        result.insert(result.begin(), digit);  // 在字符串的开头插入字符
        number /= 10;  // 去掉已经处理的最后一位数字
    }

    return result;
}

int main() {
    int number = -12345;
    std::string str_number = intToString(number);

    std::cout << "Number as string: " << str_number << std::endl;

    return 0;
}

```

### 力扣罗马数字转换

题干被你吃掉了，啊啊啊啊啊，长点心吧啊啊啊啊啊

```c++
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int>a;
        a['I'] = 1;
        a['V'] = 5;
        a['X'] = 10;
        a['L'] = 50;
        a['C'] = 100;
        a['D'] = 500;
        a['M'] = 1000;
        int i = 0;
        int num = 0;
        int len = s.length() - 1;
        for (i = 0; i < len; i++) {
            char temp1 = s[i];
            char temp2 = s[i + 1];   
            int num1 = a[temp1];
            int num2 = a[temp2];
            if (num1 >= num2) {
                num += num1;
            }
            else {
                num -= num1;
            }
        }
        num +=a[s[i]];
        return num;


    }
};
```

### 力扣12整数转罗马数字

```c++
class Solution {
public:
    string intToRoman(int num) {
        vector<int>nums = { 1000,900,500,400,100,90,50,40,10,9,5,4,1 };
        vector<string>roman = { "M","CM","D","CD","C",
        "XC","L","XL","X","IX","V","IV","I" };
        int n = nums.size();
        string res;
        for (int i = 0; i < n; i++) {
            while (num >= nums[i]) {
                num -= nums[i];
                res += roman[i];
            }
        }

        return res;
    }
};
```



### 洗牌算法

[卡牌大师：玩转“洗牌算法”，幸运女神在微笑 (*^_^*) - 掘金 (juejin.cn)](https://juejin.cn/post/6984925268754317320)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime> // 用于获取当前时间戳

class Solution {
private:
    std::vector<int> original_nums;
    std::vector<int> current_nums;

public:
    Solution(const std::vector<int>& nums) {
        original_nums = nums;
        current_nums = nums;
        // 使用当前时间戳作为种子，以增加随机性
        srand(static_cast<unsigned>(time(nullptr)));
    }

    std::vector<int> reset() {
        current_nums = original_nums;
        return original_nums;
    }

    std::vector<int> shuffle() {
        int len = current_nums.size();

        while (len > 1) {
            int randIndex = rand() % len;
            --len;

            // 交换元素
            std::swap(current_nums[len], current_nums[randIndex]);
        }

        return current_nums;
    }
};

int main() {
    // 示例用法
    std::vector<int> nums = {1, 2, 3, 4, 5};
    Solution obj(nums);

    std::cout << "Initial Array: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> shuffled = obj.shuffle();
    std::cout << "Shuffled Array: ";
    for (int num : shuffled) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    std::vector<int> resetted = obj.reset();
    std::cout << "Resetted Array: ";
    for (int num : resetted) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

`static_cast<unsigned>` 是 C++ 中的静态类型转换（static cast）。在这个上下文中，`unsigned` 是一种整数类型，而 `static_cast<unsigned>` 用于将某个值转换为无符号整数类型。

具体来说，`static_cast<unsigned>` 将其后的表达式转换为 `unsigned` 类型。这样的转换可能用于避免警告或错误，或者是为了满足特定的类型要求。

在前述代码中，`static_cast<unsigned>(time(nullptr))` 将 `time(nullptr)` 的返回值转换为无符号整数类型 `unsigned`。这是因为 `srand` 函数接受的参数类型是 `unsigned int`，为了匹配这个类型，进行了相应的类型转换。

### 力扣3178

遇到这种数学的就要想起高中的思想



### 100340三角形的最大高度

$$
等差数列的求和公式：S_n=\frac{(a_1+a_n)n}{2}\\
等比数列的求和公式：S_n=\frac{a_1(1-q^n)}{1-q}
$$



### 判断三个顶点是否构成直角三角形

题目链接：https://atcoder.jp/contests/abc362/tasks/abc362_b

需要注意的是：你的题解写成了整型，但是sqrt pow函数还是采用double类型才是正确的，然后判断两个double类型的数据是否相等是相减，差值是否小于1e-6

```c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;

int main() {
    vector<vector<int>> arr(3, vector<int>(2, 0));
    for (int i = 0; i < 3; i++) {
        cin >> arr[i][0] >> arr[i][1];
    }

    // 计算三边的长度
    double a = sqrt(pow(arr[0][0] - arr[1][0], 2) + pow(arr[0][1] - arr[1][1], 2));
    double b = sqrt(pow(arr[1][0] - arr[2][0], 2) + pow(arr[1][1] - arr[2][1], 2));
    double c = sqrt(pow(arr[0][0] - arr[2][0], 2) + pow(arr[0][1] - arr[2][1], 2));

    // 比较平方值来判断是否是直角三角形
    if (abs(pow(a, 2) + pow(b, 2) - pow(c, 2)) < 1e-6 || 
        abs(pow(a, 2) + pow(c, 2) - pow(b, 2)) < 1e-6 || 
        abs(pow(b, 2) + pow(c, 2) - pow(a, 2)) < 1e-6) {
        cout << "Yes";
    } else {
        cout << "No";
    }

    return 0;
}

```

### 力扣z字形变换

设置一个变量表示当前的方向，goingdown,当goingdown的值为true时表示当前方向是向下的，反之是向上的



```c++
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1) return s;
        bool goingdown=false;
        vector<string> rows(min(numRows,int(s.size())));
        int currow=0;
       
        for(char c:s){
            rows[currow]+=c;
            if(currow==0||currow==numRows-1) goingdown=!goingdown;
            currow+=goingdown?1:-1;
        }

        string res;
        for(auto i:rows) res+=i;
        return res;
       
  
    }
};
```

### ISBN编码

每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 99 位数字、11 位识别码和 33 位分隔符，其规定格式如 `x-xxx-xxxxx-x`，其中符号 `-` 就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4`就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 00 代表英语；第一个分隔符 `-` 之后的三位数字代表出版社，例如 670670 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以 11 加上次位数字乘以 22 ……以此类推，用所得的结果 mod 11mod11，所得的余数即为识别码，如果余数为 1010，则识别码为大写字母 𝑋*X*。例如 ISBN 号码 `0-670-82162-4` 中的识别码 44 是这样得到的：对 `067082162` 这 99 个数字，从左至右，分别乘以 1,2,…,91,2,…,9 再求和，即 0×1+6×2+……+2×9=1580×1+6×2+……+2×9=158，然后取 158 mod 11158mod11 的结果 44 作为识别码。

你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 `Right`；如果错误，则输出你认为是正确的 ISBN 号码。

输入格式

一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。

输出格式

一行，假如输入的 ISBN 号码的识别码正确，那么输出 `Right`，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 `-`）。

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    string s;
    cin >> s;
    int n = s.size();
    int sum = 0;
    for (int i = 0,j=1; i < n - 1; i++) {
        if (s[i] != '-') {
            sum += (s[i] - '0') * j;
            j++;
        }
    }

    sum = sum % 11;
    char t;
    if (sum == 10) t = 'X';
    else  t = sum + '0';

    if (t == s[n - 1]) cout << "Right";
    else {
        s[n - 1] = t;
        cout << s;
    }
   
    return 0;
}

```

### 向上取整的算法

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (dividend == 0) return 0;
        int cnt = 0;
        if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {
            while (dividend > 0 && cnt <= 2147483647) {     
                dividend -= divisor;
                 cnt++;         
            }
            return cnt;
      }
        else {
            int a = abs(dividend);
            int b = abs(divisor);
          
            while (a > 0&&cnt<=2147483647) {
                
                a -= b;
                cnt++;
            }
            return cnt==2147483647?-2147483648:-cnt;
        }

    }
};
int main() {
	Solution a;
    cout << a.divide(10,3);	
}

```

### 力扣29两数相除

注意代码中temp和multiplier的数据类型是long long 

因为有一个比较特殊的数据(2147483648 2)

在乘2过程中这两个值会爆int

因为两个数据只在int范围内，所以只存在最小负数除以-1的时候会爆int,这种情况要单独拎出来写

几种特殊情况：

1.被除数是0，则答案是0

2.除数是1，则答案是被除数

3.除数是-1 当被除数是最小负数的时候，返回最大正数，其他情况返回被除数的相反数

4.其他情况，要符号是相同的还是相异的，如果是相异的还要取反

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (dividend == 0) return 0;
        if (divisor == 1) return dividend;
        if (divisor == -1) {
            if (dividend == INT_MIN) return INT_MAX;
            else return -dividend;
        }

        long long a = labs(dividend);
        long long b = labs(divisor);
        int result = 0;
        bool nevigate = (dividend < 0) ^ (divisor < 0);
        while (a >= b) {
            long long temp = b;
            long long multiplier = 1;
            while ((temp << 1) <= a) {
                temp <<= 1;
                multiplier <<= 1;
            }

            a -= temp;
            result += multiplier;
        }

        if (nevigate) result = -result;
        return result;

    }
};

int main() {
    Solution a;
    cout << a.divide(2147483647,2);
}

```

### 小文的好数组

![image-20240720202041905](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240720202041905.png)

我累了，这么简单的题目你不会写

```c++
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

int main() {

    int n;
   cin >> n;
    vector<int> arr(n, 0);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    int i = 0;
    for (int i = 0; i < n; i++) {
        if (i != 0&&arr[i] < arr[i - 1]) {
            cout<< n << endl;
            return 0;
        }
    }
   
    cout<< 0 << endl;
    

    

    return 0;
}

```



# 动态规划

### 最优二叉搜索树

```c++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// 定义 binarysearchtree 函数
double binarysearchtree(int n, vector<double>& p, vector<double>& q) {
    vector<vector<double>> e(n + 2, vector<double>(n + 1, 0)); // 期望代价表
    vector<vector<double>> w(n + 2, vector<double>(n + 1, 0)); // 概率和表

    // 初始化
    for (int i = 1; i <= n + 1; ++i) {
        e[i][i - 1] = q[i - 1];
        w[i][i - 1] = q[i - 1];
    }

    // 填表
    for (int l = 1; l <= n; ++l) { // 子树长度从 1 到 n
        for (int i = 1; i <= n - l + 1; ++i) {
            int j = i + l - 1;
            e[i][j] = INT_MAX;
            w[i][j] = w[i][j - 1] + p[j] + q[j];
            for (int r = i; r <= j; ++r) { // 尝试以 r 为根
                double cost = e[i][r - 1] + e[r + 1][j] + w[i][j];
                if (cost < e[i][j]) {
                    e[i][j] = cost;
                }
            }
        }
    }

    return e[1][n]; // 返回最小期望代价
}

int main() {
    int n = 4; // 键的个数
    vector<double> p = {0.15, 0.10, 0.05, 0.10}; // 每个键的概率
    vector<double> q = {0.05, 0.10, 0.05, 0.05, 0.10}; // 每个伪键的概率

    double min_cost = binarysearchtree(n, p, q);
    cout << "The minimum expected cost of the optimal binary search tree is: " << min_cost << endl;

    return 0;
}

```



### 斐波那契数列

```c++
int func(int n) {
    if (n == 0 || n == 1) return 1;
    else {
        vector<int>dp(n);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n-1];
    }
}

//滚动数组
int func1(int n) {
    if (n == 0 || n == 1) return 1;
    else {
        int sum = 0;
        int dp0 = 1, dp1 = 1;
        for (int i = 2; i < n;i++) {
            sum = dp0 + dp1;
            dp0 = dp1;
            dp1 = sum;
        }
        return sum;
    }
}

```



### 力扣爬楼梯

根据推理得出：爬上第n级台阶的方案数=爬上n-1级台阶的方案数+爬上n-2级台阶的方案数

**递归（dfs）**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        return climbStairs(n-1)+climbStairs(n-2);

    }
};
```



**记忆化递归**

```c++
class Solution {
public:
    int climbStairs(int n) {
        int *mem=new int[n+1];//创建记忆数组
        //记忆数组中存储的是第i级台阶需要的步数，当需要使用的时候是直接使用即可
        //空间换时间
        return func(n,mem);

    }
    
    int func(int n,int*mem){
        if(mem[n]>0){
            return mem[n];
        }
        if(n==1){
            mem[1]=1;
        }
        
        else if(n==2){
            mem[2]=2;
        }
        
        else{
            mem[n]=func(n-1,mem)+func(n-2,mem);
        }
        return mem[n];
    }
};
```

**动态规划(递推)**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int*mem=new int[n+1];
        mem[1]=1;
        mem[2]=2;
        for(int i=3;i<=n;i++){
            mem[i]=mem[i-1]+mem[i-2];
        }
        return mem[n];

    }
};
```



**滚动数组**

优化了动态规划，因为我们只需要最后一个n级台阶的解，不需要其他的，所以这些被细化的子问题被覆盖也可以

```c++
class Solution {
public:
    int climbStairs(int n) {
              if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int first=1;
        int second=2;
        int third;
        for(int i=3;i<=n;i++){
            third=first+second;
            first=second;
            second=third;

        }
        return third;

    }
};
```

**通项公式矩阵形式**

斐波那契数列的矩阵表达：

![image-20240207173623609](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173623609.png)

![image-20240207173936045](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207173936045.png)



```c++
class Solution {
public:
    //该函数模拟矩阵相乘
    vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {
        vector<vector<long long>> c(2, vector<long long>(2));
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }
        return c;
    }
    

    vector<vector<long long>> matrixPow(vector<vector<long long>> a, int n) {
        vector<vector<long long>> ret = {{1, 0}, {0, 1}};//这里利用单位矩阵和任何矩阵相乘都等于1来初始化
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    int climbStairs(int n) {
        vector<vector<long long>> ret = {{1, 1}, {1, 0}};
        vector<vector<long long>> res = matrixPow(ret, n);
        return res[0][0];
    }
};

```

**Binet's  Formula**

就是用数学的方法解矩阵M的n次方，你们数学好的到底要怎么样

![image-20240207175746964](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175746964.png)

![image-20240207175813215](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240207175813215.png)

### 使用最小花费爬楼梯

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n=cost.size();
        vector<int>dp(n+1);
        dp[0]=0;
        dp[1]=0;
        for(int i=2;i<=n;i++){
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }

        return dp[n];

    }
};==
```

### 不同路径

求二叉树的叶子节点数目

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
using namespace std;

int func(int x,int y,int endx,int endy) {
    if (x > endx || y > endy) return 0;
    if (x == endx && y == endy) return 1;
    return func(x + 1, y,endx,endy) + func(x, y + 1,endx,endy);



}
int main() {
    cout << func(0,0, 2,2);
}
```



### 不同路径II

```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        //dp[i][j]表示机器人到达(i,j)的全部路径
        int n=obstacleGrid.size();
        int m=obstacleGrid[0].size();
        vector<vector<int> >dp(n,vector<int>(m,0));
        if(obstacleGrid[0][0]==1) dp[0][0]=0;
        else dp[0][0]=1;

        for(int j=1;j<m;j++){
            if(obstacleGrid[0][j]==1) dp[0][j]=0;
            else dp[0][j]=dp[0][j-1];
        }
        for(int i=1;i<n;i++){
            if(obstacleGrid[i][0]==1) dp[i][0]=0;
            else dp[i][0]=dp[i-1][0];
        }

        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(obstacleGrid[i][j]==1) dp[i][j]=0;
                else dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }

        return dp[n-1][m-1];
       

    }
};
```



### 整数拆分

```c++
//可以把一个整数拆解成两个数、三个和三个以上的数

//所以递推公式中，还要有j*(i-j)
class Solution {
public:
    int integerBreak(int n) {
        vector<int>dp(n + 1);
        dp[0] = 0;
        dp[1] = 0;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
                
                
            }
        }
        return dp[n];

    }
};

```

### 求组合数

$$
C\binom{n}{m}= C\binom{n}{m-1}+C\binom{n-1}{m-1}
$$

```c++
long long func(int n, int m) {
    if (m == 0 && n == 0) return 1;
    if (m == n) return 1;
    if (n == 0) return 1;
    return func(n, m - 1) + func(n - 1, m - 1);
}

long long func2(int n, int m) {
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

  
    for (int i = 0; i <= n; i++) dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (i == j) dp[i][j] = 1;
            else {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
    }

    return dp[n][m];
}
```

### 不同的二叉搜索树

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<long long>dp(n+1);
        dp[0]=1;
        
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
        
    }
};
```





### 01背包问题

每件物品只能选择一次



```c++
#include<iostream> 
#include<vector>
using namespace std;
const int N=1010;
int dp[N];
int volum[N];
int values[N];
int f[N][N];
int main(){
	int n,v;//物品数和背包能存放的最大重量
	cin>>n>>v;
	for(int i=1;i<=n;i++){
		cin>>volum[i]>>values[i];
	}
	
	//f(x,w),w代表的是能选的物品数目，w代表的是背包的容量
	//最终输出f(n,v); 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=v;j++){
			if(j<volum[i]) f[i][j]=f[i-1][j];
			else{
				f[i][j]=max(f[i-1][j],f[i-1][j-volum[i]]+values[i]);
			}
			
		} 
	}
	
	cout<<f[n][v];
	return 0;	
	 
} 

```



#### 01背包一维数组

dp[j]代表的是当物品数目为i的时候，背包容量为j时能得到的最大价值

进行倒叙是要保证每个物品只被添加了一次

先遍历物品，再遍历背包保证物品只添加一次



```c++
#include<iostream>
using namespace std;
int dp[1010];
int v[1010];//代表物品的体积数组
int w[1010];//代表物品的价值数组 
int main(){
	int n,m;//n,m分别代表物品数目和背包容量
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i];
	} 
	
	for(int i=1;i<=n;i++){
		for(int j=m;j>=v[i];j--){
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);		
		}	
    }	
	cout<<dp[5];	
	return 0;	
} 
```

#### 416分割等和子集

这里的物品体积和价值都是num[i]

本题是求能否装满一个背包

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if(sum%2!=0) return false;
        int n=nums.size();
        int a=sum/2;

        vector<int>dp(a+1);
        dp[0]=0;

        for(int i=0;i<n;i++){
            for(int j=a;j>=nums[i];j--){
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }

        
        return dp[a]==a;



    }
};
```



#### 1049最后一块石头的重量

本题是求背包的最大价值

如果把石头分成两组，那么最后剩下的差值是两组石头总重量的差值

所以只需要把石头分成尽可能相等的两组即可

如何把石头分成尽可能相等的两组？创造一个背包容量为sum/2的背包，求出背包的最大价值

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum=accumulate(stones.begin(),stones.end(),0);
        int n=stones.size();
        int a=sum/2;
        //sum/=2;
        vector<int>dp(a+1);
        dp[0]=0;
        for(int i=0;i<n;i++){
            for(int j=a;j>=stones[i];j--){
                dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }

        return abs((sum-dp[a])-dp[a]);

    }
};
```



#### 目标和

本题求装满背包有多少种方法

```c++
class Solution {
public:

    int findTargetSumWays(vector<int>& nums, int target) {
        int sum=accumulate(nums.begin(),nums.end(),0);
        if((sum+target)%2==1||(sum+target<0)) return 0;
        int left=(sum+target)/2;
        int n=nums.size();
        vector<int>dp(left+1);
        dp[0]=1;
        for(int i=0;i<n;i++){
            for(int j=left;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
            }
        }
        return dp[left];

    }
};
```



#### 二维01背包

如果采用顺序遍历，当我们更新 `f[j][k]` 时，`f[j - v[i]][k - m[i]]` 可能已经包含了当前物品 `i` 的贡献，这样在计算时会出现重复使用物品 `i` 的情况。

倒序遍历确保在更新 `f[j][k]` 时，`f[j - v[i]][k - m[i]]` 还没有被当前物品 `i` 更新过，从而保证物品 `i` 只能被使用一次。

```c++
#include <bits/stdc++.h>

using namespace std;

int n, V, M;
const int N = 1e3 + 5;
int v[N], m[N], w[N], f[N][N];

signed main () {
    cin >> n >> V >> M;
    for (int i = 1; i <= n; i ++) {
        cin >> v[i] >> m[i] >> w[i];//体积，重量，价值
    }
    
    
    //f[V][M]表示背包体积为V,质量为的时候，所能存放的最大价值
    //不断更细f[V][M],当i的值变为N的时候，是要求的答案    
    for (int i = 1; i <= n; i ++)
        for (int j = V; j >= v[i]; j --)
            for (int k = M; k >= m[i]; k --)
                f[j][k] = max (f[j - v[i]][k - m[i]] + w[i], f[j][k]);//动态转移方程，01 背包的思路
    cout << f[V][M];
}


```

#### 力扣一和零

本题是求 给定背包容量，装满背包最多有多少个物品。

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len=strs.size();
        vector<vector<int>>dp(m+1,vector<int>(n+1,0));
        dp[0][0]=0;
        for(int i=0;i<len;i++){
            int a=0,b=0;
            for(auto i:strs[i]){
                if(i=='0') a++;
                else b++;
            }
            for(int j=m;j>=a;j--){
                for(int k=n;k>=b;k--){
                    dp[j][k]=max(dp[j][k],dp[j-a][k-b]+1);
                }
            }
        }
        return dp[m][n];

    }
};
```





### 完全背包

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N];
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
}
```



#### 518零钱兑换II

完全背包先遍历物品再遍历背包得到的是组合数，因为先遍历物品，保证了物品数组靠前的物品先被选择

先遍历背包再遍历物品得到的是排列数。因为第二层循环中每一个物品都会被选一次，被选中意味着放在排列开头，所以是有顺序变化的。

```c++
class Solution {
public:
int change(int amount, vector<int>& coins) {
vector<int> dp(amount + 1, 0);
dp[0] = 1;
for (int i = 0; i < coins.size(); i++) { // 遍历物品
for (int j = coins[i]; j <= amount; j++) { // 遍历背包
dp[j] += dp[j - coins[i]];
 }
 }
return dp[amount];
 }
};
```

#### 力扣零钱兑换

本题求最小数

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n=coins.size();
        vector<long long>dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<n;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]=min(dp[j],dp[j-coins[i]]+1);

            }
        }

        return dp[amount]==INT_MAX?-1:dp[amount];

    }
};
```

#### 单词拆分

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string>wordset(wordDict.begin(),wordDict.end());
        int n=s.size();
        int len=wordDict.size();
        vector<bool>dp(n+1,false);
        dp[0]=true;//空字符串
        for(int i=1;i<=n;i++){
            for(int j=0;j<i;j++){
                string temp=s.substr(j,i-j);
                if(wordset.find(temp)!=wordset.end()&&dp[j]){
                    dp[i]=true;
                }
            }
        }
        return dp[n];
       
    }
};
```

记忆化搜索

```c++
class Solution {
private:
bool backtracking (const string& s,
const unordered_set<string>& wordSet,
vector<bool>& memory,
int startIndex) {
if (startIndex >= s.size()) {
return true;
 }
// 如果memory[startIndex]不是初始值了，直接使⽤memory[startIndex]的结果
if (!memory[startIndex]) return memory[startIndex];
for (int i = startIndex; i < s.size(); i++) {
string word = s.substr(startIndex, i - startIndex + 1);
if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory,
i + 1)) {
return true;
 }
 }
memory[startIndex] = false; // 记录以startIndex开始的⼦串是不可以被拆分的
return false;
 }
public:
bool wordBreak(string s, vector<string>& wordDict) {
unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
vector<bool> memory(s.size(), 1); // -1 表示初始化状态
return backtracking(s, wordSet, memory, 0);
 }
};
```







### 背包问题求方案数、具体方案

[背包问题求方案数、具体方案-CSDN博客](https://blog.csdn.net/qq_43851311/article/details/128981355?ops_request_misc=&request_id=&biz_id=102&utm_term=背包问题最佳方案数&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128981355.142^v100^pc_search_result_base1&spm=1018.2226.3001.4187)

#### 货币系统

给你一个n种面值的货币系统，，求组成面值为m的货币有多少种

```c++
//推到过程
//dp[i][j]==dp[1][j]+dp[i[j-v[i]]]
//我们可以知道dp[i-1][j]表示不适用当前面值的货币所有的方案数，再加上使用了该货币的方案数就是所求的
//使用了该货币的方案数等于dp[i][j-v[i]],即我们默认使用了一次v[i]货币，现在总面值变成了j-v[i]
#include<iostream>
using namespace std;
int money[1010];
long long dp[1010][1010];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>money[i];
		dp[i][0]=1;
	}
	


	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){	
			if(j<money[i]) dp[i][j]=dp[i-1][j];
			else dp[i][j]=dp[i-1][j]+dp[i][j-money[i]];
		}
	}
	cout<<dp[n][m];

    return 0;
}

```



#### ACWing278

```c++
#include<iostream>
using namespace std;
long long dp[10010];
int num[110];
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>num[i];
    }
    
    dp[0]=1;//显然什么都不选也是一种方案数
    for(int i=1;i<=n;i++){
        for(int j=m;j>=num[i];j--){
            dp[j]=dp[j]+dp[j-num[i]];
        }
    }
    
    cout<<dp[m];
   
    return 0;
}
```



#### ACWing1023

```c++
#include<iostream>
using namespace std;
int money[]={0,1,2,5,10};
int dp[1010];
int main()
{
	int n;
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=4;i++){
		for(int j=money[i];j<=n;j++){
			dp[j]=dp[j]+dp[j-money[i]];
		}
	}
	cout<<dp[n];
    return 0;
}


```

### 打家劫舍II

如何把环形转化成线性，这是最困难的地方。

```c++
class Solution {
public:
    int func(vector<int>nums,int start,int end){
        int n=nums.size();
        vector<int>dp(n);
        dp[start]=nums[start];
        dp[start+1]=max(nums[start],nums[start+1]);
        for(int i=start+2;i<n;i++){
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }

        return dp[end];
    }
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return nums[0];
        if(n==2) return max(nums[0],nums[1]);
        int res1=func(nums,0,n-2);
        int res2=func(nums,1,n-1);
        return max(res1,res2);


    }
};
```

### 力扣打家劫舍III

树形DP入门

本质上还是二叉树的递归运算，采用后续遍历的方式

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>func(TreeNode*root){
        if(root==nullptr) return vector<int>{0,0};

        vector<int>left=func(root->left);
        vector<int>right=func(root->right);
        vector<int>dp(2,0);
        dp[0]=max(right[0],right[1])+max(left[0],left[1]);
        dp[1]=root->val+left[0]+right[0];
        return vector<int>{dp[0],dp[1]};

       

    }
    int rob(TreeNode* root) {
        vector<int>dp=func(root);
        return max(dp[0],dp[1]);




    }
};
```

### 买股票的最佳时期

本题可以使用暴力解法



```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0],dp[n-1][1]);
        

    }
};
```

### 买股票的最佳时期II

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2,0));
        dp[0][0]=-prices[0];
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0],dp[n-1][1]);


    }
};
```

### 买股票的最佳时期III

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(5,0));
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[0][2]=0;
        dp[0][3]=-prices[0];
        dp[0][4]=0;
        for(int i=1;i<n;i++){
            dp[i][0]=dp[i-1][0];
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
            dp[i][2]=max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3]=max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4]=max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }

        return dp[n-1][4];

    }
};
```

### 买股票的最佳时期IV

本题是买股票的最佳时期III的延申，其实题目没有变化，不涉及动态规划思路的创新，只是不知道如何把k表达出来

每次买卖，都有买到和卖出两种状态，设计变量j，j+1表示买到，j+2表示卖出，所以j是+=2变化的

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2*k+1,0));
        for(int j=0;j<2*k;j++){
            if(j%2==0) dp[0][j]=0;
            else dp[0][j]=-prices[0];
        }

        for(int i=1;i<n;i++){
            for(int j=0;j<2*k;j+=2){
                dp[i][j+1]=max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
                dp[i][j+2]=max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
            }
        }

        return dp[n-1][2*k];

    }
};
```

### 买股票的最佳时期含冷冻期

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(4,0));
        dp[0][0]=-prices[0];//0表示持股
        dp[0][1]=0;//1表示保持卖出状态
        dp[0][2]=0;//2表示当天卖出
        dp[0][3]=0;//3表示冷冻期
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],
            max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));
            dp[i][1]=max(dp[i-1][1],dp[i-1][3]);
            dp[i][2]=dp[i-1][0]+prices[i];
            dp[i][3]=dp[i-1][2];
        }

        return max(dp[n-1][3],max(dp[n-1][1],dp[n-1][2]));

    }
};
```

### 买股票的最佳时期含手续费

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(3,0));
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        dp[0][2]=-fee;
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],
            max(dp[i-1][2]-prices[i],dp[i-1][1]-prices[i]));
            dp[i][1]=max(dp[i-1][2],dp[i-1][1]);
            dp[i][2]=dp[i-1][0]+prices[i]-fee;
        }

        return max(dp[n-1][1],dp[n-1][2]);

    }
};
```

### 最长递增子序列

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n=nums.size();
        vector<int>dp(n,1);
       
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=max(dp[j]+1,dp[i]);
                }           
            }
            
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

### 最长连续递增子序列

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        vector<int>dp(n, 1);
        for (int i = 1; i < n; i++) {
            if(nums[i-1]<nums[i]){
                dp[i]=dp[i-1]+1;
            }       
        }
        return *max_element(dp.begin(), dp.end());
    }
};

```

### 最长重复子数组

看讲义的题解

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n1=nums1.size();
        int n2=nums2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        int res=0;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                if(dp[i][j]>res) res=dp[i][j];
            }
        }
        return res;
    }
};
```

### 最长公共子序列

设dp[i] [j]是以text1[0…i-1],text2[0..j-1]为结尾的最长公共子序列的长度。

对于text1 =“abcde” 和text2=“ace”,如果text1[i-1]==text2[j-1],比如，则我们只需要看上一种状态dp[i-1] [j-1]+1

如果text1[i-1]!=text2[j-1],则我们还需要判断两种情况

比如abc ace中c!=e,那我们还需要比较abc和ac,ab和ace才可以判断出最长公共序列的长度

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1=text1.size(),n2=text2.size();
        int a;
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        int res=0;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(text1[i-1]==text2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n1][n2];

    }
};
```

### 力扣1036不相交的线

和最长公共子序列一个套路啦

```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n1=nums1.size();
        int n2=nums2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(nums1[i-1]==nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n1][n2];

    }
};
```

### 力扣53最大连续子数组和

简简单单的啦

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>dp(n);
        dp[0]=nums[0];
        for(int i=1;i<n;i++){
            dp[i]=max(nums[i],dp[i-1]+nums[i]);
        }

        return *max_element(dp.begin(),dp.end());

    }
};
```

### 力扣392判断子序列问题

本题和最长公共子序列非常的相似，是判断一个字符串是不是另一个字符串的子序列

在最长公共子序列问题中，如果当前比较的元素不相同，那么我们要分别讨论删除两字符串当前字符之后的最长公共子序列

但是在这一题，我们有一个字符串是固定的，因为要满足该字符串是另一个字符串的子序列，那么这个字符串的每一个字母都需要是另一个字符串的子序列，如果也删除该字符串的字符，有可能出现：abcdefg    aide这两个字符串，后一个字符串就不是前一个字符串的子序列

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n1=s.size();
        int n2=t.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(s[i-1]==t[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=dp[i][j-1];
            }
        }

        return dp[n1][n2]==n1;

    }
};
```

### 力扣115不同的子序列

看题解，题解写的很清楚

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        int n1=s.size();
        int n2=t.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=1;i<=n1;i++) dp[i][0]=1;
        for(int i=1;i<=n2;i++) dp[0][i]=0;
        dp[0][0]=1;
        int a=1e9+7;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(s[i-1]==t[j-1])
                {
                    dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%a;
                } 
                else dp[i][j]=(dp[i-1][j])%a;
            }
        }

        return dp[n1][n2];

    }
};
```

### 力扣583两个字符串的删除操作

本题的dp[i] [j]的含义是：以i-1结尾为结尾的字符串word1,和以j-1为结尾的字符串word2,删除字符相同的最小步数

注意定义！！！

所以如果word1[i]==word2[j],那么这个字母不用删除，看前面的字符就可以

如果不相同，可以考虑删除两字符串的任意一个字符

对于dp[i] [0]表示的是如果word2是空串，则word1需要删除所有字符才能与之相匹配

与此相同的还有dp[0] [j]

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=0;i<=n1;i++) dp[i][0]=i;
        for(int j=0;j<=n2;j++) dp[0][j]=j;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1);
            }
        }

        return dp[n1][n2];
    }
};
```

### 力扣72编辑距离

题解讲的挺好的

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1=word1.size();
        int n2=word2.size();
        vector<vector<int>>dp(n1+1,vector<int>(n2+1,0));
        for(int i=0;i<=n1;i++) dp[i][0]=i;
        for(int j=0;j<=n2;j++) dp[0][j]=j;
        for(int i=1;i<=n1;i++){
            for(int j=1;j<=n2;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=min(min(dp[i][j-1]+1,dp[i-1][j]+1),dp[i-1][j-1]+1);
                }

            }
        }

        return dp[n1][n2];

    }
};
```

### 力扣647回文子串

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240712180757705.png" alt="image-20240712180757705" style="zoom:67%;" />

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int n=s.size();
        int res=0;
        vector<vector<bool>>dp(n,vector<bool>(n,false));
        for(int i=n-1;i>=0;i--){
            for(int j=n-1;j>=i;j--){
                if(s[i]==s[j]){
                    if(j-i<=1){
                        dp[i][j]=true;
                        res++;
                    }
                    else{
                        if(dp[i+1][j-1]==true){
                             dp[i][j]=true;
                             res++;
                        }
                        else dp[i][j]=false;
                    }
                }
            }
        }

        return res;


    }
};
```

### 力扣516最长回文子序列

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n=s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++)
            dp[i][i] = 1;
        for (int i = n - 1; i >= 0; i--) {
            for (int j =i+1 ; j <n; j++) {//遍历顺序从左往右，从下往上
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

### 5力扣最长回文子串

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        string res = s.substr(0, 1);
        int maxlen = 1;
        vector<vector<bool>>dp(n, vector<bool>(n, false));

        for (int i = 0; i < n; i++) dp[i][i] = true;

        for (int i = n - 1; i >= 0; i--) {
            for (int j =i+1; j<n; j++) {
                if (s[i] == s[j]) {
                    if (j - i == 1) {
                        dp[i][j] = true;
                        if (j - i + 1 > maxlen) {
                            maxlen = j - i + 1;
                            res = s.substr(i, j - i + 1);
                        }
                    }

                    else {
                        if (dp[i + 1][j - 1] == true) {
                            dp[i][j] = true;
                            if (j - i + 1 > maxlen) {
                                maxlen = j - i + 1;
                                res = s.substr(i, j - i + 1);
                            }
                        }
                    }
                }
            }
        }

        return res;
    }
};
```



### 硬币问题

硬币问题可以贪心的情况通常包括以下几种：

1. 每一种面值的硬币都可以无限使用：如果每种面值的硬币数量是无限的，并且面值之间满足某种关系，比如每种面值都是前一种面值的整数倍，那么可以使用贪心算法。
2. 面值之间满足某种性质：如果硬币的面值之间存在某种特殊的关系，比如是等比数列、斐波那契数列等，那么也可以使用贪心算法。
3. 最优子结构性质：硬币问题的最优解可以由子问题的最优解组合而成，而且子问题之间相互独立，不存在依赖关系。

当我们要凑出w=15，首先面临三种情况的选择

当我们选择了价值为1的硬币时，问题转化成了1+凑出价值为14的问题

当我们选择了价值为5的硬币的时候，问题转化成了1+凑出价值为10的问题

当我们选择了价值为11的硬币的时候，问题转化成了凑出价值为4的问题



![image-20240402214153424](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402214153424.png)



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
    int dp[100], i;
    dp[0] = 0;//f(0)的情况，价值为0那我们还凑个集贸啊，硬币数直接为0即可
    int cost;
    for (int i = 1; i <= 15; i++) {
        cost = 9999;
        if (i - 1 >= 0) cost = min(cost, dp[i - 1] + 1);//表示我们使用了此硬币一次，所以加一
        if (i - 5 >= 0) cost = min(cost, dp[i - 5] +1);
        if (i - 11 >= 0)cost = min(cost, dp[i - 11] + 1);
        dp[i] = cost;
        printf("dp[%d]=%d\n", i, dp[i]);
    }


    return 0;
}

```

![image-20240402215125353](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240402215125353.png)



















### 力扣53最大子数组和

看题解，写的很精彩



### 力扣比特位计数

方法一就是遍历数组，每一次都计算x&(x-1)变成零所需要的次数，但是这有很多重复计算

所以动态规划

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
};


```





### 力扣1668最大重复子字符串

KMP算法





# 递归调用

### 直接插入排序

```c++
#include<iostream>
#include<vector>
using namespace std;
void func(vector<int>& array, int n, int i) {
	if (i == 0) return;
	func(array, n, i - 1);
	if (array[i] < array[i - 1]) {
		int tmp = array[i];
		int j = i - 1;
		do {
			array[j + 1] = array[j];
			j--;
		} while (j >= 0 && array[j] > tmp);
	}
	

} 

```

### 0/1背包

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 10;
vector<int>x(N, 0);
int func(vector<int>value, vector<int>weight, int i, int rw) {
	int n = value.size();
	if (i >= n || rw < 0) return 0;
	int max1 = 0;
	int max2 = 0;
	if (rw >= weight[i]) {
		max1 = func(value, weight, i + 1, rw - weight[i])+value[i];
	}

	max2 = func(value, weight, i + 1, rw);

	if (max1 > max2) {
		x[i] = 1;
		return max1;
	}
	else {
		x[i] = 0;
		return max2;
	}
	

}

void knap(vector<int>value, vector<int>weight, int i, int rw) {
	int result = func(value, weight, 0, rw);
	int n = value.size();
	cout << "方案为:" <<endl;
	int sum = 0;
	for (int i = 0; i < n; i++) {
		if (x[i] == 1) {
			cout << "物品 " << i << ":" << "价值: " << value[i] << "重量: " << weight[i] << endl;
			sum += value[i];
		}
	}

	cout << "总价值:"<<sum << endl;
}
int main() { 
	vector<int>value = { 4,4,3,1 };
	vector<int>weight = { 5,3,2,1 };
	int rw = 6;
	knap(value, weight, 0, rw);

}
```



### 求解简单表达式

```
#include<iostream>
#include<string>
using namespace std;
class Solution {
	string text;
	int n;
public:
	int func1(string s) {
		text = s;
		n = s.size();
		int i = 0;
		return func2(s, i, n);
	}

	int func2(string s, int& i, int n) {
		int answer = 0;
		int sgn = 1;
		while (i < n) {
			if (s[i] == '(') {
				i++;
				int sd= func2(s, i, n);
				answer += sd;
			}
			else if (s[i] == '-') {
				sgn = -1;
				i++;	
			}

			else if (s[i] - '0' >= 0 && s[i] - '0' <= 9) {
				int d = 0;
				while (i < n && (s[i] - '0' >= 0 && s[i] - '0' <= 9)) {
					d = d * 10 + (s[i] - '0');
					i++;
				}
				answer +=d*sgn;
			}
			else if (s[i] == '+') {
				sgn = 1;
				i++;
			}
			else {
				i++;
				return answer;
			}

		}
		return answer;	
	}	
};

int main() {
	Solution a;
	cout<<a.func1("(4+5+(2-3)-2");
	return 0;
}
```





# 递推求解

### 例题1

![image-20240313044505011](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044505011.png)



只有一根折线的情况

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313044533512.png" alt="image-20240313044533512" style="zoom:50%;" />

有两根折线的情况

![image-20240313045453327](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045453327.png)

可知一根折线会与另一个折现有4个交点

所以状态转移方程  f(n)=4*(n-1)+1,其中(n-1)是交点数，交点数加一就是线段数

### 骨牌铺满问题



![image-20240313045653763](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045653763.png)

这一题的状态转移方程是斐波那契数列

假设f(n-1)已经知道，那么有两种情况

第一种是最后一个格子放数条，那么只有这一种放法，总共有f(n-1)种

第二种是最后两个格子放横条，因为上面两个各自放了横条，那么下面那两个格子也只能放横条，也只有一种方法，总共有f(n-2)种

所以f(n)=f(n-1)+f(n-2)



![image-20240313045940604](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313045940604.png)





![image-20240313050000122](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050000122.png)



<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050438505.png" alt="image-20240313050438505" style="zoom:50%;" />

状态转移方程f(n)=f(n-1)+f(n-2)+f(n-4)



![image-20240313050730568](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240313050730568.png)





# 穷举法

### 求回文串的个数

穷举的时间复杂度比较高

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<set>
using namespace std;
bool ispal(string& s, int i, int j) {
	int low = i, high = j;
	while (i <= j) {
		if (s[i] != s[j]) return false;
		i++;
		j--;
	}

	return true;
}
int countSubstring(string& s) {
	int n = s.size();
	set<string>myset;
	for (int i = 0; i < n; i++) {
		for (int j = i; j < n; j++) {
			if(ispal(s, i, j)) myset.insert(s.substr(i, j - i + 1));
		}
	}

	return myset.size();
}


int main() {
	string s = "mokkori";
	cout << countSubstring(s);
	
}
```



优化算法

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<set>
using namespace std;
void cnt(set<string>&myset,int n,string& s, int l, int r) {
	
	while (l>=0&&r<n&&s[l]==s[r]) {
		myset.insert(l, r - l + 1);
		l--;
		r++;
	}

	
}
int countSubstring(string& s) {
	set<string>myset;
	int n = s.size();
	for (int c = 0; c < n; c++) {
		cnt(myset, n, s, c, c);
	}

	for (int c = 0; c < n-1; c++) {
		cnt(myset, n, s, c, c + 1);
	}

	return myset.size();
}


int main() {
	string s = "mokkori";
	cout << countSubstring(s);
	
}
```



### 求幂集

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>> pset1(int n) {		//解法1
	vector<vector<int>> ps;				//存放幂集
	for (int i = 0; i < (1 << n); i++) {			//执行2^n次
		vector<int> e;
		for (int j = 0; j < n; j++) {
			if (i & (1 << j))
				e.push_back(j + 1);
		}
		ps.push_back(e);
	}
	return ps;
}
void powerset1(int n) {
	vector<vector<int>> ps;
	ps = pset1(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}


vector<vector<int>> pset2(int n) {				//求幂集算法2
	vector<vector<int>> ps;							//存放幂集
	vector<int> e;
	ps.push_back(e);										//添加{}空集合元素
	for (int i = 1; i <= n; i++) {								//循环添加1～n
		vector<vector<int>> A = ps;					//A存放上一步得到的幂集
		for (auto it = A.begin(); it != A.end(); ++it)
			(*it).push_back(i);							//在A的每个集合元素末尾添加i
		for (auto it = A.begin(); it != A.end(); ++it)
			ps.push_back(*it);							//将A的每个集合元素添加到ps中
	}
	return ps;
}

void powerset2(int n) {
	vector<vector<int>> ps;
	ps = pset2(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}

vector<vector<int>> pset3(int n) {			//解法3
	vector<vector<int>> ps;				//存放幂集
	vector<int> e;
	ps.push_back(e);						//添加{}空集合元素
	for (int i = 1; i <= n; i++) {				//循环添加1～n
		int m = ps.size();
		for (int j = 0; j < m; j++) {
			vector<int> e = ps[j];			//取出e=ps[j]
			e.push_back(i);					//在e的末尾添加i
			ps.push_back(e);				//再将e添加到ps中 
		}
	}
	return ps;
}

void powerset3(int n) {
	vector<vector<int>> ps;
	ps = pset3(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}


vector<vector<int>> pset4(int n) {		//解法3：递归算法 
	if (n == 0)
		return { {} };
	vector<vector<int>> ps;				//存放幂集
	ps = pset4(n - 1);						//求求出1-n-1的幂集ps 
	int m = ps.size();
	for (int j = 0; j < m; j++) {
		vector<int> e = ps[j];			//取出e=ps[j]
		e.push_back(n);					//在e的末尾添加n
		ps.push_back(e);				//再将e添加到ps中 
	}
	return ps;
}

void powerset4(int n) {
	vector<vector<int>> ps;
	ps = pset4(n);
	for (int i = 0; i < ps.size(); i++) {
		printf("{");
		for (int j = 0; j < ps[i].size(); j++) {
			if (j == 0)
				printf("%d", ps[i][j]);
			else
				printf(" %d", ps[i][j]);
		}
		printf("}  ");
	}
	printf("\n");
}

int main() {
	int n = 3;
	printf("1～%d的幂集\n", n);
	printf("  解法1: "); powerset1(n);
	printf("  解法2: "); powerset2(n);
	printf("  解法3: "); powerset3(n);
	printf("  解法4: "); powerset4(n);
	return 0;
}

```

### 0/1背包问题

```c++
#include<iostream>
#include<vector>
using namespace std;
void func(vector<int>value,vector<int>weight,int n,int maxweight) {
	int maxv = 0;
	int maxw = 0;
	int maxi;
	
	for (int choose = 0; choose < (1 << n); choose++) {
		int sumv = 0, sumw = 0;
		for (int j = 0; j < n; j++) {
			if (choose & (1 << j)) {
				sumv += value[j];
				sumw += weight[j];
			}
		}

		if (sumw <= maxweight && sumv >= maxv) {
			maxv = sumv;
			maxw = sumw;
			maxi = choose;
		}
	}

	cout << "最佳方案: " << endl;
	cout << "选中物品:{";
	//把数字i的二进制位数显示出来
	for (int i = 0; i < n; i++) {
		if (maxi & (1 << i)) {
			cout << i << " ";
		}
	}

	cout << "}" << endl;
	cout << "总重量为:"<<maxw<<" 总价值为:" << maxv << endl;
	
}

int main() {
	vector<int>value = {4,4,3,1};
	vector<int>weight = {5,3,2,1};
	int n = 4;
	int maxweight=6;
	func(value, weight, n,maxweight);
	
}

```



### 全排列

迭代和增量

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>>res(int n){
	vector<vector<int>>ps = { {1} };
	//采用迭代的算法
	for (int i = 2; i <= n; i++) {
		vector<vector<int>>temp = ps;
		ps.clear();
		for (auto it = temp.begin(); it != temp.end(); it++) {
			vector<int>e= (*it);
			for (int j = e.size(); j >=0; j--) {
				vector<int>el = e;
				auto place = el.begin() + j;
				el.insert(place, i);
				ps.push_back(el);
			}
			
		}
	}

	return ps;
}
int main() {
	vector<vector<int>>ps = res(3);
	for (int i = 0; i < ps.size(); i++) {
		for (int j = 0; j < ps[i].size(); j++) {
			cout << ps[i][j] << " ";
		}

		cout << endl;
	}
}
```



递归做法

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>>res(int n){
	if(n==1) return { {1} };
	vector<vector<int>>ps = res(n - 1);

	vector<vector<int>>temp = ps;
	ps.clear();
	for (auto it = temp.begin(); it != temp.end(); it++) {
		vector<int>e= (*it);
		for (int j = e.size(); j >=0; j--) {
			vector<int>el = e;
			auto place = el.begin() + j;
			el.insert(place, n);
			ps.push_back(el);
		}
		
	}
	 
	return ps;
}
int main() {
	vector<vector<int>>ps = res(3);
	for (int i = 0; i < ps.size(); i++) {
		for (int j = 0; j < ps[i].size(); j++) {
			cout << ps[i][j] << " ";
		}

		cout << endl;
	}
}
```



STL

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<int>e;
	vector<vector<int>>ps;
	for (int i = 1; i <= n; i++) e.push_back(i);
	do {
		ps.push_back(e);
	} while (next_permutation(e.begin(), e.end()));
	for (int i = 0; i < ps.size(); i++) {
		for (int j = 0; j < ps[i].size(); j++) {
			cout << ps[i][j] << " ";
		}

		cout << endl;
	}
}
```

### 任务分配问题

```c++
#include<iostream>
#include<vector>
using namespace std;
#define INF 0x3f3f3f3f
vector<vector<int>> perm1(int n) {						//算法1：迭代求0～n-1的全排列
	vector<vector<int>> pm={{0}};						//存放全排列
	for (int i=1;i<n;i++) {										//循环添加2～n
		vector<vector<int>> pm1=pm;
		pm.clear();
		for (auto it=pm1.begin();it!=pm1.end();it++) {
			vector<int> e=(*it);									//取出pm1中一个元素e
			for (int j=e.size();j>=0;j--) {						//在e的每个位置插入i
				vector<int> e1=e;
				auto it=e1.begin()+j;							//求出插入位置
				e1.insert(it,i);										//插入整数i
				pm.push_back(e1);								//添加到pm中
			}
		}
	}
	return pm;
}
void allocate(vector<vector<int>>& c) { //求任务分配问题的最优方案
	int n=c.size();
	vector<vector<int>> pm=perm1(n);
	vector<int> bestx;					//最优分配方案 
	int mincost=INF;						//最小成本 
	for (int f=0;f<pm.size();f++) {		//求每个分配方案的成本
		vector<int> x=pm[f];				//取当前分配方案x 
		int cost=0;
		for (int i=0;i<x.size();i++)	//人员i分配任务ps[f][i] 
			cost+=c[i][x[i]];

		printf("分配方案:x=（");
		for(int k=0;k<x.size();k++)
			printf("%d ",x[k]);
		printf("） 总成本=%d\n",cost);			
			
		if (cost<mincost) {				//比较求最小成本的方案
			mincost=cost;
			bestx=x;
		}
	}
	printf("最优方案:\n");
	for (int i=0;i<bestx.size();i++)
		printf("   人员%d分配任务%d\n",i,bestx[i]);
	printf("   总成本=%d\n",mincost);
}
int main() {
	freopen("abc.out","w",stdout); 
	vector<vector<int>> c={{9,2,7,8},{6,4,3,7},{5,8,1,8},{7,6,9,4}};
	allocate(c);
	return 0;
}
```



### 旅行商问题

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
#define INF 0x3f3f3f3f
void disppath(vector<int>&x,int plen,int s) {	//输出一条路径x
	printf("%d",s);
	for(int i=0;i<x.size();i++)
		printf("->%d",x[i]);
	printf("->%d 路径长度=%d\n",s,plen); 
} 
void TSP(vector<vector<int>> &A,int s) {
	int n=A.size();
	int bestlen=INF;			//存放最短路径长度 
	vector<int> bestx,x;		//bestx存放最短路径 
   	for(int i=0;i<n;i++) {		//将非s的顶点添加到x中 
   		if(i!=s)
   			x.push_back(i);
   	}
    printf("TSP求解\n");
    int cnt=0;						//累计累计数 
  	do {
     	int curlen=0,u=s,j=0;
       	while(j<x.size()) {
          	int v=x[j];
            curlen+=A[u][v];			//对应一条边<u,v>
            u=v;
            j++;
        }
        curlen+=A[u][s];
        printf("  路径%d:   ",++cnt); disppath(x,curlen,s); 
        if(curlen<bestlen) {			//比较求最短路径 
        	bestlen=curlen;
        	bestx=x;
        }
    } while(next_permutation(x.begin(),x.end()));
    printf("  最短路径:"); disppath(bestx,bestlen,s);
}

int main() {
	//freopen("abc.out","w",stdout);
	vector<vector<int>> A={{0,8,5,36}, {6,0,8,5}, {8,9,0,5}, {7,7,8,0}};
	int s=0;
	TSP(A,s);
	return 0;
}

```







### 最大连续子序列和

使用前缀和

```
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int func(vector<int>array,int n) {
	vector<int>psum(n + 1, 0);
	psum[0] = 0;
	for (int i = 1; i <= n; i++) {
		psum[i] = psum[i - 1] + array[i-1];
	}

	int maxsum = 0;
	int cursum = 0;
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j <= n; j++) {
			cursum = psum[j] - psum[i];
			maxsum = max(maxsum, cursum);
		}
	}

	return maxsum;
}
```



优化算法

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int func(vector<int>array,int n) {
	int maxsum = 0;
	int cursum = 0;
	for (int i = 0; i < n; i++) {
		cursum += array[i];
		if (cursum >= maxsum) maxsum = cursum;
		if (cursum < 0) cursum = 0;	
	}

	return max(maxsum,0);
}
```





### **数的质因数分解**

```c++
#include <iostream>
using namespace std;
int a[101] = { 0 };
int main() {
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		if (a[i] == 0) {
			for (int j = i * 2; j <= n; j += i) {
				a[j] = 1;
			}
		}
	}
	//一个数的质因数只能在比这个数小的质数中去找
	int i = 2;
	while (n >= 1&&i<=n) {
		if (a[i] == 0 && n % i == 0) {
			cout << i << " ";
			n = n / i;
		}
		else {
			i++;
		}
	}
}
```



### 有一个边长为n、m的棋盘，求棋盘内有多少个正方形和长方形

枚举正方形的边长就可以得到所有的正方形

方形是由两条横线和两条竖线组成的

选择两条横线和两条竖线排列组合

n+1条横线，m+1条竖线

此算法的时间复杂度是0(n),还有数学的时间复杂度为o(1)的算法

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

long long computeCombinations(int n, int k) {
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));

    for (int i = 0; i <= n; i++) dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            if (i == j) dp[i][j] = 1;
            else {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
    }

    return dp[n][k];
}

int main() {
    int rows, cols;
    cin >> rows >> cols;

    // Calculate the number of squares
    long long numSquares = 0;
    int minSide = min(rows, cols);
    for (int sideLength = 1; sideLength <= minSide; sideLength++) {
        numSquares += (rows + 1 - sideLength) * (cols + 1 - sideLength);
    }

    // Calculate the number of rectangles
    long long numLineCombinationsRows = computeCombinations(rows + 1, 2);
    long long numLineCombinationsCols = computeCombinations(cols + 1, 2);
    long long numRectangles = numLineCombinationsRows * numLineCombinationsCols - numSquares;

    cout << "Number of squares: " << numSquares << endl;
    cout << "Number of rectangles: " << numRectangles << endl;

    return 0;
}

```

### 说谎者的数量

![image-20240718144521697](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718144521697.png)

对于本题，只需要遍历可能说谎的人的数量，比如假定有一个人说谎，再遍历每个人的信息，如果a说至少有两个人说谎，但是实际上假设的是1个人说谎，那么这个人就说谎了，记录说谎的人数++，最后判断说谎的人和假定说谎的人是否相等

![55b3a75ff7bcb8b606ad9af733e52c1](D:\WeChat Files\wxid_aaaljrtur35n22\FileStorage\Temp\55b3a75ff7bcb8b606ad9af733e52c1.jpg)

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int>arr(n+1, 0);
        for (int i = 1; i <= n; i++) {
            cin >> arr[i];
        }
        int flag = 1;

        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = 1; j <= n; j++) {
               
                if (arr[j] > i) cnt++;
            }
            if (cnt == i) {
                flag = 0;
                cout << cnt << endl;
                break;
            }
        }

        if (flag == 1) cout << -1 << endl;
       
    }

    
    return 0;
}

```

### 珠心算测验

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。

某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？

最近老师出了一些测验题，请你帮忙求出答案。

输入格式：

共两行，第一行包含一个整数 n，表示测试题中给出的正整数个数。

第二行有 n个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。

输出格式：

一个整数，表示测验题答案。

对于 100% 的数据，3≤𝑛≤100，测验题给出的正整数大小不超过 10,000。



本题的解题思路是：本题的数据范围比较小，所以只要遍历即可。



```c++
#include <iostream>
#include <vector>
#include <string>
#include<unordered_map>
using namespace std;


int main() {
    int n;
    cin >> n;
    vector<int>arr(n, 0);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    unordered_map<int, bool>is_in;
    for (int i = 0; i < n-1; i++) {
        for (int j = i + 1; j < n; j++) {
            is_in[arr[i] + arr[j]] = true;
        }
    }
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (is_in[arr[i]]) cnt++;
    }

    cout << cnt;
    return 0;
}

```

### 导弹拦截

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718174148777.png" alt="image-20240718174148777" style="zoom: 80%;" />

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718174219904.png" alt="image-20240718174219904" style="zoom: 80%;" />

谁家好人求导弹的最远半径的总和啊神经病，不应该求所有半径总和吗

贪心+枚举

首先假设所有导弹都由一座拦截塔拦截，接着把最远的半径给另一个拦截塔，如果得到的代价比较小，就采用当前做法

主要是，你花了很长时间在求半径总和上但是本题求的是最远半径总和。

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int distance(int la, int lb, int lx, int ly) {
    int x = abs(la - lx);
    int y = abs(lb - ly);
    return x * x + y * y;
}

struct point {
    int x;
    int y;
    int distance;
};

bool compare(point& a, point& b) {
    return a.distance > b.distance;
}
int main() {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    int n;
    cin >> n;
    vector<vector<int>>map(n, vector<int>(2, 0));
    vector<point>distances1;
    int distances2=0;

    long long res = 0;
    for (int i = 0; i < n; i++) {
        cin >> map[i][0] >> map[i][1];
        int temp1 = distance(x1, y1, map[i][0], map[i][1]);

        distances1.push_back({ map[i][0],map[i][1],temp1 });


    }



    sort(distances1.begin(), distances1.end(), compare);
    res = distances1[0].distance;
    for (int i = 0; i < distances1.size()-1;i++) {
        int x = distances1[i].x;
        int y = distances1[i].y;
        int temp;
        if (distances2==0) {
            temp = distance(x2, y2, x, y);
            distances2 = temp;
        }
        else {
           temp = max(distances2, distance(x2, y2, x, y));
           distances2 = temp;
        }

        res = min(res, (long long)distances1[i + 1].distance + temp);

    }

  
    cout << res;


    return 0;
}




```

# 分治法

### 二路归并排序

```c++
#include<iostream>
#include<vector>
using namespace std; 
void disp(vector<int>&a,int s,int t) {		//输出a[s..t]元素
	printf("[ ");
	for (int i=s;i<=t;i++)
		printf("%d ",a[i]);
	printf("]\n");
}
void merge(vector<int>&a,int low,int mid,int high) { //将a[low..mid]和a[mid+1..high]归并为一个有序子序列a[low..high]
	vector<int> tmp(high-low+1);		//分配临时空间
	int i=low,j=mid+1,k=0;
	while (i<=mid && j<=high) {			//两个有序表均未遍历完时循环
		if (a[i]<=a[j]) {				//归并较小元素a[i]
			tmp[k]=a[i];
			i++;k++; 
		}
		else {							//归并较小元素a[j]
			tmp[k]=a[j];
			j++;k++; 
		}
	}
	while (i<=mid) {			//归并有序表1的余下元素
		tmp[k]=a[i];
		i++;k++; 
	}
	while (j<=high) {			//归并有序表2的余下元素
		tmp[k]=a[j];
		j++;k++;
	}
	for (k=0,i=low;i<=high;k++,i++) 		//将tmp元素复制回a中
		a[i]=tmp[k];
}
void mergesort(vector<int>&a,int low,int high) {	//实现a[low..high]的二路归并排序
	if (low<high) {					//子序列有两个或以上元素
		int mid=(low+high)/2;			//取中间位置		
		printf("左序列: ");disp(a,low,mid); 
		mergesort(a,low,mid);			//对a[low..mid]子序列排序
		printf("排序左序列: ");disp(a,low,mid); 

		printf("右序列: ");disp(a,mid+1,high); 
		mergesort(a,mid+1,high);		//对a[mid+1..high]子序列排序
		printf("排序右序列: ");disp(a,mid+1,high); 
		merge(a,low,mid,high);			//将两子序列合并为一个有序序列 
		printf("合并结果: ");disp(a,low,high); 

	}
}
void mergesort(vector<int>&a) {			//a的二路归并算法
	int n=a.size();
	mergesort(a,0,n-1);
}
int main() {
	vector<int> a={2,5,1,7,10,6,9,4,3,8};
	int n=a.size();
	printf("排序前:"); disp(a,0,n-1);
	mergesort(a);
	printf("排序后:"); disp(a,0,n-1);
	return 0;
}

```

### 最大连续子序列和

```c++
#include<iostream>
#include<vector>
using namespace std;
int func(vector<int>Arr, int low, int high) {
	if (low == high) {
		return max(Arr[low], 0);
	}

	int mid = (low + high) / 2;
	int maxleftsum = func(Arr, low, mid);
	int maxrightsum = func(Arr,mid + 1, high);


	int maxleftbordersum =0;
	int maxrightbordersum = 0;

	int leftsum = 0;
	int rightsum = 0;
	for (int i = mid; i >= low; i--) {
		leftsum += Arr[i];
		if(leftsum > maxleftbordersum) maxleftbordersum = leftsum;
	}
	
	for (int i = mid + 1; i <= high; i++) {
		rightsum += Arr[i];
		if (rightsum > maxrightbordersum) maxrightbordersum =rightsum;
	}

	int maxmid = maxleftbordersum + maxrightbordersum;
	int ans = max(max(maxleftsum, maxrightsum), maxmid);
	return max(ans, 0);


}
int main() {
	vector<int>array = { -2,11,-4,13,-5,2 };
	cout << func(array, 0, 5);
}

```

### 棋盘覆盖问题

```c++
#include<iostream>
using namespace std;
#define MAX 1025
int k;							//棋盘大小
int x,y;						//特殊方格的位置
int board[MAX][MAX];
int tile=1;									//L型骨牌的编号,从1开始
void chessboard(int tr,int tc,int dr,int dc,int size) {
	if(size==1) return;						//递归出口
	int t=tile++;							//取一个L型骨，其牌号为tile
	int s=size/2;							//分割棋盘
	//考虑左上角象限
	if(dr<tr+s && dc<tc+s)					//特殊方格在此象限中
		chessboard(tr,tc,dr,dc,s);
	else {									//此象限中无特殊方格
		board[tr+s-1][tc+s-1]=t;				//用t号L型骨牌覆盖右下角
		chessboard(tr,tc,tr+s-1,tc+s-1,s);	//将右下角作为特殊方格继续处理该象限
	}
	//考虑右上角象限
	if(dr<tr+s && dc>=tc+s)  
		chessboard(tr,tc+s,dr,dc,s);		//特殊方格在此象限中 
	else {									//此象限中无特殊方格
		board[tr+s-1][tc+s]=t;					//用t号L型骨牌覆盖左下角
		chessboard(tr,tc+s,tr+s-1,tc+s,s);  	//将左下角作为特殊方格继续处理该象限
	}
	//处理左下角象限
	if(dr>=tr+s && dc<tc+s)				//特殊方格在此象限中
		chessboard(tr+s,tc,dr,dc,s);  
	else { 									//此象限中无特殊方格
		board[tr+s][tc+s-1]=t;  				//用t号L型骨牌覆盖右上角
        chessboard(tr+s,tc,tr+s,tc+s-1,s);	//将右上角作为特殊方格继续处理该象限
   	}
	//处理右下角象限
	if(dr>=tr+s && dc>=tc+s)					//特殊方格在此象限中
		chessboard(tr+s,tc+s,dr,dc,s); 
	else {									//此象限中无特殊方格
		board[tr+s][tc+s]=t;  					//用t号L型骨牌覆盖左上角
		chessboard(tr+s,tc+s,tr+s,tc+s,s);  	//将左上角作为特殊方格继续处理该象限
	}
}
int main() {
	k=3;
	x=1; y=2;
	int size=1<<k;
	chessboard(0, 0, x, y, size);
	for(int i=0; i<size; i++) {					//输出方案
		for(int j=0; j<size;j++)
			printf("%4d",board[i][j]);
		printf("\n");
	}
	return 0;
}

```



### 循环日程安排问题

```c++
#include<iostream>
using namespace std;
#define MAX 101
int a[MAX][MAX];						//存放比赛日程表（行列下标为0的元素不用）
void plan(int k) {
	int n=2;								//n从2^1=2开始
	a[1][1]=1; a[1][2]=2;   			//求解2个选手比赛日程,得到左上角元素
	a[2][1]=2; a[2][2]=1;
	for (int t=1;t<k;t++) {						//迭代处理,依次处理2^2(t=1)…,2^k(t=k-1)个选手
		int tmp=n;								//tmp=2^t
		n=n*2; 								//n=2^(t+1)
		for (int i=tmp+1;i<=n;i++) {			//填左下角元素
			for (int j=1; j<=tmp; j++)
				a[i][j]=a[i-tmp][j]+tmp; 	//左下角元素和左上角元素的对应关系
		}
		for (int i=1; i<=tmp;i++) {				//填右上角元素
			for (int j=tmp+1; j<=n; j++)
				a[i][j]=a[i+tmp][(j+tmp)% n];
		}
		for (int i=tmp+1;i<=n;i++) {			//填右下角元素
			for (int j=tmp+1; j<=n; j++)
				a[i][j]=a[i-tmp][j-tmp];
		}
    }
}
int main() {
	int k=3;
	int n=1<<k;							//n等于2的k次方即n=2^k
	plan(k);							//产生n个选手的比赛日程表
	for(int i=1;i<=n;i++) {				//输出比赛日程表
		for(int j=1; j<=n; j++)
			printf("%4d",a[i][j]);
		printf("\n");
	}
	return 0;
}

```



### 旅行商问题

```c++
#include<iostream>
#include<vector>
#include<set>
using namespace std;
const int INF=0x3f3f3f3f;
void dispset(set<int> &V) {
	printf("{");
	for (auto it=V.begin();it!=V.end();it++)
		printf("%d ",*it);
	printf("}");
}
int TSP(vector<vector<int>> &A,int s,set<int> V,int i) {							//求TSP所有解的路径长度
	int minpathlen=INF;						//最短路径长度
	if (V.size()==0) {						//当V为空时
		printf("计算f({ },%d)\n",i);
		printf("求出f({ },%d),递归出口pathlen=%d\n",i,A[s][i]);
		return A[s][i];
	}
	else {									//当V为不空时
		printf("计算f("); dispset(V); printf(",%d)\n",i);
		for (auto it=V.begin();it!=V.end();it++) {	//扫描集合V中的顶点j
			set<int> tmpV=V;
			int j=*it;
			tmpV.erase(j);					//tmpV=V-{j}
			int pathlen1=TSP(A,s,tmpV,j);
			int pathlen=pathlen1+A[j][i];
			printf("    f("); dispset(tmpV); printf(",%d )",j); printf(",pathlen1=%d\n",pathlen1);
			minpathlen=min(minpathlen,pathlen);
		}
		printf("求出f("); dispset(V); printf(",%d),minpathlen=%d\n",i,minpathlen);
		return minpathlen;
	}
}
void solve(vector<vector<int>> &A,int s) {
	int n=A.size();
	set<int> V;
	for (int i=0;i<n;i++) {
		if(i!=s)
			V.insert(i);
	}
	printf("TSP路径长度=%d\n",TSP(A,s,V,s));	//输出23
}

int main() {
	//freopen("abc.out","w",stdout);
	vector<vector<int>> A={{0,8,5,36}, {6,0,8,5}, {8,9,0,5}, {7,7,8,0}};
	int s=2;
	solve(A,s);
	return 0;
}


```



# 区间问题

|          | 区间求和 | 区间最大值 | 区间修改 | 单点修改 |
| -------- | -------- | ---------- | -------- | -------- |
| 前缀和   | 1        | 0          | 0        | 0        |
| 差分     | 0        | 0          | 1        | 0        |
| 树状数组 | 1        | 1          | 0        | 1        |
| 线段树   | 1        | 1          | 1        | 1        |

## 前缀和

```c++
prefixSum[i]=arr[0]+arr[1]+⋯+arr[i−1]+arr[i]
    
//其中prefixsum[0]=0;
```



###  **求任意区间的和**

```c++
//区间[l,r]等于prefixsum[r]-prefixsum[l-1];
#include<iostream>
using namespace std;
int arr[1010];
int s[10010];
int main() {
	int n, m;
	scanf("%d ", &n,&m);
	for (int i = 1; i <= n; i++) {//下标从一开始，如果下标从零开始要重新设计
		scanf("%d", &arr[i]);
		s[i] = s[i - 1] + arr[i];
	}
	while (m--) {
		int l, r;
		scanf("%d %d", &l, &r);
		printf("%d", s[r] - s[l - 1]);
	}
	return 0;

}
```



### 力扣3179

### 二维前缀和

https://www.bilibili.com/video/BV18P411g7cu/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

```c++
//二维前缀和s[i][j]表示前i行前j列的矩阵元素之和
//i1行,j1列与i2行，j2列之间的矩阵元素之和


#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, m;
    int arr[105][105] = {0}; // 初始化二维数组为0，避免垃圾值
    long long s[106][106] = {0}; // 前缀和数组

    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
        }
    }

    // 构建前缀和数组
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + arr[i][j];
        }
    }

    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        int i1, j1, i2, j2;
        cin >> i1 >> j1 >> i2 >> j2;
        long long result = s[i2][j2] - s[i1-1][j2] - s[i2][j1-1] + s[i1-1][j1-1];
        cout << result << endl; // 每个查询结果之后换行
    }

    return 0;
}

```



### 不太甜的糖果


给定一排长度为n的糖果串，每个糖果有一个甜度，求出一个最短的糖果串使得它的甜度之和大于等于m。

输入格式

第一行包含两个数n和m，第二行有n个数。

输出格式

输出一行，包含一个数，即最短的糖果串的长度。如果找不到这样的糖果串，输出0；

注意糖果子串是连续的

对于本题，有两种解法：滑动数组和前缀和，滑动数组对于特定数据会超时

![image-20240719210428381](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719210428381.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#include <climits> 

using namespace std;

bool check(vector<int>& prefix_sum, int mid, int target) {
    return prefix_sum[mid] < target;
}
int binary_search(vector<int>& prefix_sum, int low,int high,int target) {
    int l = low-1, r = high+1;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check(prefix_sum, mid, target)) l = mid;
        else r = mid;
    }

    if (r!=high+1&&prefix_sum[r]>=target) return r;
    else return -1;

}
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> sweetness(n+1,0);
    int min_Len = INT_MAX;

    for (int i = 1; i <= n; i++) {
        cin >> sweetness[i];
    }

    vector<int>prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + sweetness[i];
    }

    for (int i = 1; i <= n; i++) {
        int target = prefix_sum[i] + m;
        int index = binary_search(prefix_sum, i,n,target);
        if(index!=-1) min_Len = min(min_Len, index - i);
        
    }

    if (min_Len != INT_MAX) cout << min_Len;

    return 0;
}

```



### ACWing1236递增三元组

刷第二遍，看错题目了...

```c++
#include<iostream>
using namespace std;
int n;
int a[100010],b[100010],c[100010];
int cnta[100010],cntc[100010];
int sa[100010],sc[100010];
//用cnta,cntc表示数组a,c对应元素出现的次数，需要注意的是因为数组是顺序的，所以相当于我们排了序
//比如假设数组a是1，2，3，5，5，6（下标从1开始）
//那么cnta对应的是1 1 1 0 2 1
//这下清楚了吧！因为排了序，所以对于特定的b[i],在i前面的就是小于b[i]的
int main(){
    cin>>n;
    long long res=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        cnta[++a[i]]++;
    }
    
    sa[0]=cnta[0];//我终于知道为什么了！因为s[0]一般默认为零，前0项的和嘛，但是这一题的数据可以为0
    //为了避免冲突，++a[i]一定大于零了，所以cnta[0]=0,满足了sa[0]=0;
    for(int i=1;i<100010;i++) sa[i]=sa[i-1]+cnta[i];//注意这里，因为n的取值范围是100000
    //所以cnta[i]的取值范围是0-100000，万一都是一个数呢，比如11111111
    for(int i = 1; i <= n; ++i){
        scanf("%d", &b[i]);
        b[i]++;
    } 
    for(int i=1;i<=n;i++){
        scanf("%d",&c[i]);
        cntc[++c[i]]++;
    }
    sc[0]=cntc[0];
    for(int i=1;i<100010;i++) sc[i]=sc[i-1]+cntc[i];
    for(int i=1;i<=n;i++){
        res+=(long long)sa[b[i]-1]*(sc[100010-1]-sc[b[i]]);
    }
    cout<<res;
    return 0;
    
}
```

### 奶牛弹钢琴

![image-20240720202233987](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240720202233987.png)

![image-20240720202507280](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240720202507280.png)

前缀和数组prefix_sum[i]表示前i个音阶敲打花费的时间，比如对于输入的数据2 3 5

前1个音节花费2

前2个音节花费3

前3个音节花费6

给一个查询时间T，假设T=3找出第一个前缀和大于T的下标，本例为3，则说明T时间的时候我们在敲打第三个音节

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
bool check(vector<int>& prefix_sum,int mid,int target) {
    return prefix_sum[mid] <= target;
}
int binary_search(vector<int>& prefix_sum, int low, int high, int target) {
    int l = low - 1;
    int r = high + 1;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check(prefix_sum,mid,target)) l = mid;
        else r = mid;
    }

    if (r != high + 1 && prefix_sum[r] > target) return r;
    else return -1;

}
int main() {
    int N, Q;
    cin >> N >> Q;
    vector<int>B(N, 0);
    vector<int>prefix_sum(N + 1, 0);
    for (int i = 0; i < N; i++) {
        cin >> B[i];
        prefix_sum[i + 1] = prefix_sum[i] + B[i];
    }

    for (int i = 0; i < Q; i++) {
        int temp;
        cin >> temp;
        cout << binary_search(prefix_sum, 1, N, temp) << endl;
    }
    return 0;
}
```



## 一维差分

差分数组用于快速更新数组的某一段区间内的元素值。差分数组的主要思想是通过记录变化量来间接表示数组的更新。相较于直接更新数组中的每个元素，**差分数组可以在常数时间内对数组进行区间更新。**

1. 对于差分数组`0 0 0 0 0`,对d[1]加一的结果是对原数组区间[1,n-1]都加上1
2. 使用差分数组可以在常数时间内对原数组的某个区间进行更新操作。
3. 差分数组的前缀和是原数组
4. 前缀和数组做一次差分也会返回到原数组
5. 差分数组适用于多次更新，单次查询的场景
6. 对区间[l,r]都加上value，只需要将差分数组：`d[l]+value,d[r+1]-value`,在做前缀和即可得到结果



定义差分数组`d[i]=arr[i]-arr[i-1]`

其中`d[0]=arr[0]`

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> constructDifferenceArray(const vector<int>& arr) {
    int n = arr.size();
    vector<int> diff(n + 1, 0);
    diff[0] = arr[0];
    for (int i = 1; i < n; i++) {
        diff[i] = arr[i] - arr[i - 1];
    }
    return diff;
}

void updateDifferenceArray(vector<int>& diff, int l, int r, int x) {
    diff[l] += x;
    if (r + 1 < diff.size()) {
        diff[r + 1] -= x;
    }
}

vector<int> restoreArrayFromDifferenceArray(const vector<int>& diff) {
    int n = diff.size();
    vector<int> arr(n, 0);
    arr[0] = diff[0];
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i - 1] + diff[i];
    }
    return arr;
}

int main() {
    vector<int> arr = {2, 4, 6, 8, 10};
    vector<int> diff = constructDifferenceArray(arr);

    // Perform update operation: add 3 to the range [1, 3]
    updateDifferenceArray(diff, 1, 3, 3);

    // Restore the updated array
    vector<int> updatedArr = restoreArrayFromDifferenceArray(diff);

    for (int val : updatedArr) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}

```





## 二维差分

https://www.bilibili.com/video/BV1pi4y1j7si/?p=4&spm_id_from=pageDriver&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

`b[i][j]=a[i][j]−a[i−1][j]−a[i][j−1]+a[i−1][j−1]`



1. 对于二维差分数组`b[i][j]`,如果`b[i][j]+1`,会影响到后续的一整块区域



```c++
#include <iostream>
#include <vector>
using namespace std;

// 构造差分数组
void constructDifferenceArray(const vector<vector<int>>& a, vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();

    differenceArray[0][0] = a[0][0];
    for (int i = 1; i < m; i++) differenceArray[i][0] = a[i][0] - a[i - 1][0];
    for (int j = 1; j < n; j++) differenceArray[0][j] = a[0][j] - a[0][j - 1];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            differenceArray[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
        }
    }
}

// 更新差分数组
void updateDifferenceArray(vector<vector<int>>& differenceArray, int x1, int y1, int x2, int y2, int value) {
    differenceArray[x1][y1] += value;
    int m = differenceArray.size();
    int n = differenceArray[0].size();

    if (x2 + 1 < m) {
        differenceArray[x2 + 1][y1] -= value;
    }
    if (y2 + 1 < n) {
        differenceArray[x1][y2 + 1] -= value;
    }
    if (x2 + 1 < m && y2 + 1 < n) {
        differenceArray[x2 + 1][y2 + 1] += value;
    }
}

// 从差分数组恢复原始数组
void restoreArrayFromDifferenceArray(vector<vector<int>>& a, const vector<vector<int>>& differenceArray) {
    int m = a.size();
    int n = a[0].size();
    a[0][0] = differenceArray[0][0];

    for (int j = 1; j < n; j++) {
        a[0][j] = a[0][j - 1] + differenceArray[0][j];
    }
    for (int i = 1; i < m; i++) {
        a[i][0] = a[i - 1][0] + differenceArray[i][0];
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + differenceArray[i][j];
        }
    }
}

int main() {
    vector<vector<int>> a = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int m = a.size();
    int n = a[0].size();
    vector<vector<int>> differenceArray(m, vector<int>(n, 0));

    // 构造初始差分数组
    constructDifferenceArray(a, differenceArray);

    // 更新差分数组
    updateDifferenceArray(differenceArray, 0, 0, 1, 1, 10);

    // 恢复更新后的原数组
    restoreArrayFromDifferenceArray(a, differenceArray);

    // 打印更新后的原数组
    cout << "Updated Original Array:" << endl;
    for (const auto& row : a) {
        for (const auto& elem : row) {
            cout << elem << " ";
        }
        cout << endl;
    }

    return 0;
}

```



## 线段树

**定义**

线段树是一棵二叉树，通常用来存储数组区间的信息。每个节点表示一个区间，节点的值通常表示该区间的一些属性（如区间和、区间最小值等）。线段树的根节点表示整个数组的区间，根节点的两个子节点分别表示数组的左半部分和右半部分，依此类推。

线段树算法中常用到：

1. nodeindex：表示当前节点下标
2. start表示data数组区间左端点下标
3. end表示data数组区间右端点下标
4. leftindex表示当前访问端点左孩子下标
5. rightindex表示当前访问端点右孩子下标 



​      

**用途**

1. **区间查询**：例如，查询数组某个区间内的最小值、最大值、和、乘积等。请注意，区间查询下标是数组下标！！
2. **区间更新**：例如，将数组某个区间内的每个元素都增加一个固定值，或将某个区间内的值全部设为某个值。
3. **动态数据处理**：线段树支持在数据更新的同时，保持快速的查询性能，适合动态数据处理场景。

 		

**时间复杂度**

- 线段树的查询和更新操作的时间复杂度为 𝑂(log⁡𝑛)。
- 线段树的构建时间复杂度为 𝑂(𝑛)。





**懒惰标记线段树**

懒惰标记（Lazy Propagation）是一种优化技术，用于提高线段树处理区间更新操作的效率。它通过推迟更新操作直到真正需要时才进行，从而避免在每次更新时对整个区间进行重复操作。这样可以显著减少更新操作的时间复杂度。

在标准线段树中，每次更新操作都会影响到相关区间的所有节点，导致时间复杂度较高。懒惰标记通过以下方式优化：

1. **延迟更新**：将更新操作记录在懒惰标记数组中，而不立即更新所有相关节点。
2. **传播更新**：在查询或进一步更新操作时，再将之前记录的更新操作应用到相关节点上。



**懒惰标记机制的实现中，在进行线段树的查询和更新操作之前，通常会先检查当前节点是否有懒惰标记。这是为了确保在需要进行查询或更新操作时，首先将延迟更新应用到当前节点上，然后再进行相应的操作，从而保证数据的准确性和一致性。**



### 求和线段树

```c++
#include<iostream>
#include<vector>
#include<numeric>
using namespace std;
#include <vector>
using namespace std;

#include <vector>
#include <iostream>
using namespace std;

class SegmentTree {
private:
    vector<int> Tree;
    vector<int> Lazy;
    vector<int> data;
    int n;

    void BuildTree(int node, int start, int end) {
        if (start == end) {
            Tree[node] = data[start];
        }
        else {
            int mid = (start + end) / 2;
            int leftindex = 2 * node;
            int rightindex = 2 * node + 1;
            BuildTree(leftindex, start, mid);
            BuildTree(rightindex, mid + 1, end);
            Tree[node] = Tree[leftindex] + Tree[rightindex];
        }
    }

    void propagate(int node, int start, int end) {

        if (Lazy[node] != 0) {
            
            Tree[node] += (end - start + 1) * Lazy[node];
            if (start != end) {
                Lazy[node * 2] += Lazy[node];
                Lazy[node * 2 + 1] += Lazy[node];
            }
            Lazy[node] = 0;
        }
    }

    void updateRange(int node, int start, int end, int L, int R, int val) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return;
        }

        if (L <= start && end <= R) {
            //如果当前区间被包含在查询区间中，那么就不继续向下更新，而是选择原路返回，用懒惰标记标记该节点
            //并且给左孩子和右孩子记账，等访问左孩子右孩子的时候，会先查一下该节点有没有父节点留下的帐
            //如果有，就要先更新，也就是本函数开头的propagate函数
            Tree[node] += (end - start + 1) * val;
            if (start != end) {
                Lazy[node * 2] += val;
                Lazy[node * 2 + 1] += val;
            }
            return;
        }

        int mid = (start + end) / 2;
        updateRange(node * 2, start, mid, L, R, val);
        updateRange(node * 2 + 1, mid + 1, end, L, R, val);
        Tree[node] = Tree[node * 2] + Tree[node * 2 + 1];
    }

    int queryRange(int node, int start, int end, int L, int R) {
        propagate(node, start, end);
        if (start > end || start > R || end < L) {
            return 0;
        }

        if (L <= start && end <= R) {
            return Tree[node];
        }

        int mid = (start + end) / 2;
        int leftSum = queryRange(node * 2, start, mid, L, R);
        int rightSum = queryRange(node * 2 + 1, mid + 1, end, L, R);
        return leftSum + rightSum;
    }

    


    //先找到对应节点，更新，后原路更新路径上所有节点的值
    void updateTree(int node, int start, int end, int idx, int val) {
        if (start == end) {
            data[idx] = val;
            Tree[node] = val;
        }
        else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            if (start <= idx && idx <= mid) {
                updateTree(leftChild, start, mid, idx, val);
            }
            else {
                updateTree(rightChild, mid + 1, end, idx, val);
            }
            Tree[node] = Tree[leftChild] + Tree[rightChild];
        }
    }

public:
    SegmentTree(const vector<int>& data) {
        this->data = data;
        this->n = data.size();
        Tree.resize(4 * n);
        Lazy.resize(4 * n, 0);
        BuildTree(1, 0, n - 1);
    }

    void update(int idx, int val) {
        updateTree(0, 0, n - 1, idx, val);
    }

    void updateRange(int L, int R, int val) {
        updateRange(1, 0, n - 1, L, R, val);
    }

  

    int queryRange(int L, int R) {
        return queryRange(1, 0, n - 1, L, R);
    }
};


int main() {
    std::vector<int> data(100);
    iota(data.begin(), data.end(), 1);
    
    SegmentTree segTree(data);
  
    
    return 0;

}
```



### 乘法(根号)线段树

当我们对区间进行同时加和乘的时候，应该有两个懒惰标记

乘法标记：初始值为1

加法标记：初始值为0

在pushdown函数中，首先获得该节点的乘法懒惰标记和加法懒惰标记

然后更新左右孩子节点的懒惰标记

左孩子的乘法懒惰标记等于左孩子乘法懒惰标记乘当前节点的乘法懒惰标记

左孩子的加法懒惰标记等于左孩子加法懒惰标记乘当前节点的乘法懒惰标记值加上当前节点的加法懒惰标记

```c++
#include <vector>
#include <iostream>

using namespace std;

const long long p = 1e9 + 7;

struct SegmentTreeNode {
    long long sum = 0;
    long long mlz = 1; // Multiplicative lazy tag, initially 1
    long long plz = 0; // Additive lazy tag, initially 0
    int l = 0, r = 0;
};

vector<SegmentTreeNode> tree;

// Initialize the segment tree with a given array size
void init(int n) {
    tree.resize(4 * n); // Allocate sufficient space for segment tree
}

// Build the segment tree
void build(vector<int>& arr, int i, int l, int r) {
    tree[i].l = l;
    tree[i].r = r;
    if (l == r) {
        tree[i].sum = arr[l];
        return;
    }
    int mid = (l + r) / 2;
    build(arr, 2 * i, l, mid);
    build(arr, 2 * i + 1, mid + 1, r);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Pushdown function to propagate lazy updates
void pushdown(int i) {
    long long k1 = tree[i].mlz, k2 = tree[i].plz;
    if (tree[i].l != tree[i].r) { // Not a leaf node
        // Update left child
        tree[2 * i].sum = (tree[2 * i].sum * k1 + k2 * (tree[2 * i].r - tree[2 * i].l + 1)) % p;
        tree[2 * i].mlz = (tree[2 * i].mlz * k1) % p;
        tree[2 * i].plz = (tree[2 * i].plz * k1 + k2) % p;

        // Update right child
        tree[2 * i + 1].sum = (tree[2 * i + 1].sum * k1 + k2 * (tree[2 * i + 1].r - tree[2 * i + 1].l + 1)) % p;
        tree[2 * i + 1].mlz = (tree[2 * i + 1].mlz * k1) % p;
        tree[2 * i + 1].plz = (tree[2 * i + 1].plz * k1 + k2) % p;
    }
    tree[i].mlz = 1;
    tree[i].plz = 0;
}

// Update function for range updates (multiplicative and additive)
void update(int i, int l, int r, long long k1, long long k2) {
    if (l <= tree[i].l && tree[i].r <= r) {
        tree[i].sum = (tree[i].sum * k1 + k2 * (tree[i].r - tree[i].l + 1)) % p;
        tree[i].mlz = (tree[i].mlz * k1) % p;
        tree[i].plz = (tree[i].plz * k1 + k2) % p;
        return;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    if (l <= mid) update(2 * i, l, r, k1, k2);
    if (r > mid) update(2 * i + 1, l, r, k1, k2);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % p;
}

// Query function to get the sum of a range
long long query(int i, int l, int r) {
    if (l <= tree[i].l && tree[i].r <= r) {
        return tree[i].sum;
    }
    pushdown(i);
    int mid = (tree[i].l + tree[i].r) / 2;
    long long res = 0;
    if (l <= mid) res = (res + query(2 * i, l, r)) % p;
    if (r > mid) res = (res + query(2 * i + 1, l, r)) % p;
    return res;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    init(n);
    build(arr, 1, 0, n - 1);

    // Example usage: updating range [1, 3] with k1 = 2 (multiplicative) and k2 = 3 (additive)
    update(1, 1, 3, 2, 3);
    cout << query(1, 1, 3) << endl; // Query the sum of range [1, 3]

    return 0;
}

```



### 线段树的应用

1. 区间最值查询和更新
   应用：在给定数组中，查询某个区间内的最小值或最大值，以及在数组的某个位置更新一个值。
   示例：在电商平台中，查询某一时间段内商品的最低价格。
2. 区间和查询和更新
   应用：求数组某个区间内的元素和，以及在某个位置或区间内进行更新操作。
   示例：统计某段时间内网站的总访问量，并能快速更新某天的访问量。
3. 区间乘积查询和更新
   应用：查询数组某个区间内元素的乘积，并支持单点更新。
   示例：在金融系统中，计算某段时间内的投资收益，并能快速更新某天的收益。
4. 区间最大公约数 (GCD) 查询
   应用：查询数组某个区间内的最大公约数。
   示例：在数学分析中，找到某个区间内所有数的最大公约数。
5. 区间最小公倍数 (LCM) 查询
   应用：查询数组某个区间内的最小公倍数。
   示例：在排班系统中，找到某段时间内多个周期任务的共同周期。
6. 区间众数查询
   应用：在数组的某个区间内，查找出现次数最多的元素。
   示例：统计某段时间内最热门的商品。
7. 区间逆序对查询
   应用：计算数组某个区间内的逆序对数量。
   示例：在排序算法的优化中，统计逆序对的数量以决定是否使用归并排序。
8. 区间最小值差查询
   应用：查询某个区间内最小值和次小值之间的差值。
   示例：在比赛成绩分析中，找到某段时间内成绩最接近的两名选手。
9. 动态求解直方图中的最大矩形面积
   应用：求解动态变化的直方图中的最大矩形面积问题。
   示例：在图像处理和分析中，找出图像中最大连通块的面积。
10. 字符串问题
    应用：处理字符串的一些查询和更新操作，如区间字符统计、区间回文判断等。
    示例：在文本编辑器中，统计某段文字中的特定字符出现次数。
11. 区间覆盖问题
    应用：解决区间覆盖问题，如区间涂色、区间覆盖等。
    示例：在地理信息系统（GIS）中，查询某块区域内的覆盖情况。
12. 数据压缩
    应用：利用线段树进行数据压缩和稀疏矩阵的存储。
    示例：在数据压缩算法中，用线段树记录稀疏矩阵的非零元素。
13. 动态排列统计
    应用：统计动态排列中的逆序对、排列的顺序统计等。
    示例：在实时排序系统中，统计动态排序结果的逆序对数量。
14. 多维线段树
    应用：解决多维数据的区间查询和更新问题，如二维线段树。
    示例：在图像处理和分析中，进行二维区域的快速统计和更新。

# 贪心

### [从零开始学贪心算法-CSDN博客](https://blog.csdn.net/qq_32400847/article/details/51336300?ops_request_misc=%7B%22request%5Fid%22%3A%22170970936516800226558001%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170970936516800226558001&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51336300-null-null.142^v99^pc_search_result_base1&utm_term=贪心算法&spm=1018.2226.3001.4187)



贪心算法是特殊的动态规划？？？

贪心算法求硬币，只要硬币之间是整除关系

### 最大兼容区间个数

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
class Action {
public:
	int start;
	int end;
	Action(int s, int e) :start(s), end(e) {}
	bool operator<(const Action& o) const {
		return end <= o.end;
	}
};

void greedy(vector<Action>&Arr) {
	int n = Arr.size();
	vector<bool>flag(n, false);
	sort(Arr.begin(), Arr.end());
	int preend = Arr[0].end;
	flag[0] = true;
	int ans = 1;
	for (int i = 1; i < n; i++) {
		if (Arr[i].start >= preend) {
			flag[i] = true;
			ans++;
			preend = Arr[i].end;
		}
	}

	cout << "求解结果: " << endl;
	cout << "选取的活动: ";
	for (int i = 0; i < n; i++) {
		if (flag[i] == true) {
			cout << "活动" << i << " 开始时间:" << Arr[i].start << " 结束时间:" << Arr[i].end << endl;
		}
	}

	cout << "共" << ans << "个活动";
}
int main() {

}
```



### 给定正整数N，求N个N相乘的个位数

```c++
#include<iostream>
#include<vector>
using namespace std;

int func(int x) {
   vector<int> a(10);
   a[0] = 0;
   a[1] = 1;
   a[2] = 4;
   a[3] = 7;
   a[4] = 6;
   a[5] = 5;
   a[6] = 6;
   a[7] = 3;
   a[8] = 6;
   a[9] = 9;
   return a[x];
}

int main() {
    // 取输入的数
    int n;
    cin >> n;
    
    // 计算个位数
    int ge = n % 10;
    
    // 调用函数并输出结果
    cout << func(ge); 
    
    return 0;
}

```

### 特殊的斐波那契

**有一种fibonacci数列，定义如下：**

**f(0)=7,f(1)=11,f(n)=f(n-1)+f(n-2),给定一个n(n<1000000),请判断f(n)能否被3整除**

(a+b)%3=(a%3+b%3)%3

f(0) = 7 % 3 = 1 

f(1) = 11 % 3 = 2 

f(2) = f(1) + f(0) = 2 + 1 = 3 % 3 = 0

f(3) = f(2) + f(1) = 0 + 2 = 2 

f(4) = f(3) + f(2) = 2 + 0 = 2 

f(5) = f(4) + f(3) = 2 + 2 = 4 % 3 = 1 

f(6) = f(5) + f(4) = 1 + 2 = 3 % 3 = 0 

f(7) = f(6) + f(5) = 0 + 1 = 1

周期为8.

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
using namespace std;
bool func(int m) {
    if (m == 2 || m == 6) {
        return true;
   }
    return false;
    
}

int main() {
    //思路：个位数只和个位数相关
    int n;
    cin >> n;
    int m = n % 8;
   
    cout << func(m); 
    return 0;
}

```



### 求A^B的最后三位表示的整数

```c++
#include <iostream>
using namespace std;

long long fastPowerIterative(long long base, long long exponent) {
    long long result = 1;
    while (exponent > 0) {
        if (exponent % 2 == 1)
            result *= base;
        base *= base;
        exponent /= 2;
    }
    return result;
}

int main() {
    long long base, exponent;
    cout << "请输入底数和指数: ";
    cin >> base >> exponent;
    long long res = fastPowerIterative(base, exponent);
    cout << res % 1000;
    return 0;
}

```

### 力扣1217玩筹码

服了狗屎题目这么简单我不会

### 力扣402移掉k位数字

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240306184035499.png" alt="image-20240306184035499" style="zoom: 67%;" />



考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过 k 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 k个删除次数之前，栈中的序列从栈底到栈顶单调不降。

因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到

1. 栈为空

2. 或者新的栈顶元素不大于当前数字
3. 或者我们已经删除了 kkk 位数字

上述步骤结束后我们还需要针对一些情况做额外的处理：

如果我们删除了 m 个数字且 m<km<km<k，这种情况下我们需要从序列尾部删除额外的 k−mk-mk−m 个数字。

1. 如果最终的数字序列存在前导零，我们要删去前导零。
2. 如果最终数字序列为空，我们应该返回 0。
3. 最终，从栈底到栈顶的答案序列即为最小数。

考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数。为了避免翻转操作，可以使用双端队列代替栈的实现。

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<char> stk;
        for (auto& digit: num) {
            while (stk.size() > 0 && stk.back() > digit && k) {
                stk.pop_back();
                k -= 1;
            }
            stk.push_back(digit);
        }

        for (; k > 0; --k) {
            stk.pop_back();
        }

        string ans = "";
        bool isLeadingZero = true;
        for (auto& digit: stk) {
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};


```

### 力扣605种花问题

1.对于两朵已经种花且中间没有种花的切片:它们之间可以种花的范围是[i+2,j-2],此时可以种花的格子数是j-i-3。假设有k个空格种花，可以种花的个数是（k+1）/2,所以在i,j之间可以种的花是（j-i-2）/2。

2.在第一个种花之前的切片：第一朵下标i,则可以种i/2朵花

3.在最后一朵花到末尾，同上，令最后一朵花的位置是r,花坛总长m,则可以种（m-r-1）/2朵花

基于以上分析，我们可以遍历花坛数组，对于第一种情况，我们设置开头是-1

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count=0;//计数
        int prev=-1;//表示开头
        int m=flowerbed.size();
        for(int i=0;i<m;i++){
            if(flowerbed[i]==1){
                if(prev<0){
                    count+=i/2;     
                }
                else{
                    count+=(i-prev-2)/2;
                }
                prev=i;
            }
        }
        if(prev<0){
            //一朵花也没种
            count+=(m+1)/2;
        }
        else{
            count+=(m-prev-1)/2;
        }

        return count>=n;
    }
       

};


```

### 力扣608验证回文串

我们发现：最外层的两个字母如果不同，一定不是回文串！，如果是，则可以继续遍历内层的字串，这就是贪心的思想。

当我们发现有两个字母不同的时候，**必须删除一个字母**，删除之后，其他序列是回文串，因为最外层已经是回文不用考虑，所以只要判断右边和左边是否有一个是回文串就好。

```
class Solution {
public:
    bool ishuiwen(const string&s,int low,int high){
        for(int i=low,j=high;i<j;++i,--j){
            if(s[i]!=s[j]){
                return false;
            }
        }
        return true;
    }
    bool validPalindrome(string s) {
        //对于一个字符串是都是回文串，可以先判断两端是否是字符串，如果最外部都不是，则一定不是
        int low=0,high=s.size()-1;
        while(low<high){
            char c1=s[low],c2=s[high];
            if(c1==c2){
                low++;
                high--;
            }
            else{
                return ishuiwen(s,low+1,high)||ishuiwen(s,low,high-1);
            }
        }      
        return true;
    }
};
```

### 求总和

题目链接：https://atcoder.jp/contests/abc362/tasks/abc362_c

求数对的最小和min_account     最大和max_account

判断是否成立的条件是：如果最小和大于零，那么怎么添加都不会等于零，如果最大和小于零，那么怎么减少都不会等于零



初始化结果序列：假设每个数对的最小值就是要求的值，现在我的结果序列是每个数对的最小值



我们需要在原先数对的基础上把值增加,我们需要增加的最大值当然是min_accont的相反数，但是还有一个条件限制，每次增加的值不能超过Ri-Li,这是题目限制的，如果在遍历过程中需要增加的值变成0了，直接输出即可

```c++
#include<iostream>
#include<vector>
using namespace std;
//贪心是什么东西
int main() {
	int n;
	cin >> n;
	int min_account=0, max_account=0;
	vector<vector<int>>arr(n,vector<int>(2,0));
	vector<int>result(n, 0);
	for (int i = 0; i < n; i++) {
		cin >> arr[i][0] >> arr[i][1];
		min_account += arr[i][0];
		max_account += arr[i][1];
		result[i] = arr[i][0];
	}

	if (max_account < 0 || min_account>0) cout << "No";
	else {
		cout << "Yes"<<endl;
		int current_account = 0 - min_account;
		for (int i = 0; i < n; i++) {
			if (current_account == 0) break;//小小剪枝
			int temp = min(current_account, arr[i][1] - arr[i][0]);
			result[i] += temp;
			current_account -= temp;
		}

		for (int i = 0; i < n; i++) {
			cout << result[i] << ' ';
		}

	}
}
```

### 力扣100361切蛋糕的最小开销

采用贪心的思想，因为后面我们需要进行的切割动作越来越多，所以后面切割的权值要尽可能小，我们每次选取权值最大的分割线。

如何用代码表示切蛋糕这个动作是本题的难点，画图可知，我们水平切一刀，则垂直方向上就要多切一下，这个是实践得来的

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minCostToCutCake(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
    vector<pair<int, bool>>cost;
    for (int i = 0; i < m-1; i++) {
        cost.push_back({ horizontalCut[i],true });
    }

    for (int i = 0; i < n-1; i++) {
        cost.push_back({ verticalCut[i],false });
    }

    sort(cost.rbegin(), cost.rend());

    int hor = 1, ver = 1;
    int min_cost = 0;

    for (auto i : cost) {
        int temp = i.first;
        if (i.second) {
            min_cost += temp * ver;
            hor++;
        }

        else {
            min_cost += temp * hor;
            ver++;
        }
    }

    return min_cost;
    
    
}

int main() {
    int m = 6, n = 3;
    vector<int> horizontalCut = { 2,3,2,3,1 };
    vector<int> verticalCut = { 1,2 };

    int result = minCostToCutCake(m, n, horizontalCut, verticalCut);
    cout << "最小总开销是: " << result << endl;

    return 0;
}

```

### 力扣54螺旋矩阵

我最讨厌的题目：模拟题啊啊啊啊

具体请看题解第一个，设置左上右下四个边距，每次遍历结束之后就删除边距即可

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int up = 0;
        int down = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;
        vector<int>res;
        while (up <= down && left <= right) {

            for (int i = left; i <= right; i++) res.push_back(matrix[up][i]);
            up++;
            if (up > down || left > right) break;
            for (int i = up; i <= down; i++) res.push_back(matrix[i][right]);
            right--;
            if (up > down || left > right) break;
            for (int i = right; i >= left; i--) res.push_back(matrix[down][i]);
            down--;
            if (up > down || left > right) break;
            for (int i = down; i >= up; i--) res.push_back(matrix[i][left]);
            left++;
            if (up > down || left > right) break;
        }

        return res;
    }
};
```



# 回溯算法

### 求幂集

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> x;							//解向量 
void disp(vector<int> &a) {	//输出一个解
	printf("  {");
	for (int i=0;i<x.size();i++)
		if (x[i]==1)
			printf("%d ",a[i]);
	printf("}");
}
void dfs(vector<int> &a,int i) {	//回溯算法
	if (i>=a.size())
		disp(a);
	else {
		x[i]=1;
		dfs(a,i+1);				//选择a[i]
		x[i]=0;
		dfs(a,i+1);				//不选择a[i]
	}
}
void pset1(vector<int> &a) {		//求幂集算法1
	int n=a.size();
	x=vector<int>(n);
	dfs(a,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("求解结果\n");
	pset1(a);
	return 0;
}


```



若要求输出有序的解，应该用该方法

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> x;												//解向量
void disp(vector<int> &x) {						//输出一个解（子集）
	printf("  {");
	for (int k=0;k<x.size();k++)
		printf("%d ",x[k]);
	printf("}");
}
void dfs(vector<int> &a,int j) {					//回溯算法
	disp(x);													//输出对应的解
	for(int j1=j;j1<a.size();j1++) {					//j1≥i
		x.push_back(a[j1]);
		dfs(a,j1+1);
		x.pop_back();
	}
}
void pset2(vector<int> &a) {					//求幂集算法2
	dfs(a,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("求解结果\n");
	pset2(a);
	return 0;
	return 0;
}


```

### 图的路径搜索

```c++
#include<iostream>
#include<vector>
using namespace std;
const int INF=0x3f3f3f3f; 
int n=5;
vector<vector<int>> A={{0,5,INF,1,INF},{5,0,INF,INF,INF},{INF,INF,0,2,3},{1,INF,2,0,8},{INF,INF,3,8,0}};
vector<vector<int>> ans;			//存放答案
vector<int> x;						//解向量
vector<int> visited;
void dfs(int i,int curlen,int t) {
	if (i==t) {
		ans.push_back(x);
		ans.back().push_back(curlen);
    }
	else {
    	for (int j=0;j<n;j++) {
            if(i==j || A[i][j]==INF) continue;
            if (visited[j]) continue;
            visited[j]=1;
            x.push_back(j);
            curlen+=A[i][j];
            dfs(j,curlen,t);
            curlen-=A[i][j];
            x.pop_back();
            visited[j]=0;
        }
    }
};
void allpath(int s,int t) {
    x.push_back(s);
    visited=vector<int>(n,0);
	visited[s]=1;
    dfs(s,0,t);
    printf("从%d到%d的所有路径:\n"); 
    for(int i=0;i<ans.size();i++) {
    	printf("  路径%d: 长度=%d, 路径:",i+1,ans[i].back());
		for(int j=0;j<ans[i].size()-1;j++)
			printf(" %d",ans[i][j]);
		printf("\n");
	}
}
int main() {
	//freopen("abc.out","w",stdout);
	int s=0,t=4;
	allpath(s,t);	
	return 0;
}
```

### 构造表达式

```c++
#include<iostream>
#include<vector> 
using namespace std;
#define N 9
int a[N];
vector<string> ans;					//存放答案 
char x[N];							//解向量
void dfs(int sum,int prev,int i)
{
	if (i==N) {						//到达一个叶子结点
		if (sum==100) {				//找到一个解
			string s=to_string(a[0]);
			for (int j=1;j<N;j++) {
				if (x[j]!=' ') s+=x[j];
				s+=to_string(a[j]);
			}
			s+="=100";
			ans.push_back(s);
		}
	}
	else {
		x[i]='+';						//位置i插入'+'
		sum+=a[i];						//计算结果
		dfs(sum,a[i],i+1);
		sum-=a[i];						//回溯

		x[i]='-';						//位置i插入'-'
		sum-=a[i];						//计算结果
		dfs(sum,-a[i],i+1);
		sum+=a[i];						//回溯

		x[i]=' ';						//位置i插入' '
		sum-=prev;					//先减去前面的元素值
		int tmp;						//计算新合并值
		if (prev>0)
			tmp=prev*10+a[i];		//如prev=2,a[i]=3,结果为23
		else
			tmp=prev*10-a[i];		//如prev=-2,a[i]=3,结果为-23
		sum+=tmp;						//计算合并结果
		dfs(sum,tmp,i+1);
		sum-=tmp;						//回溯sum
		sum+=prev;
	}
}
void express() {
	for (int i=0;i<N;i++)				//为a赋值为1,2，...,9
		a[i]=i+1;
	dfs(a[0],a[0],1);					//插入位置i从1开始
	printf("求解结果\n");
	for(int i=0;i<ans.size();i++)
		cout << "  (" << i+1 << ") " << ans[i] << endl;	
}
int main() {
	freopen("abc.out","w",stdout);
	express();
	return 0;
}

```

### 图的m着色问题

时间复杂度比较大，原理简单

```c++
#include<iostream>
#include<cstring>
#define MAXN 20				//图最多的顶点个数
int n=4;
int A[MAXN][MAXN]={{0,1,1,1},{1,0,0,0},{1,0,0,1},{1,0,1,0}};
int ans=0;						//全局变量，累计解个数
int x[MAXN];					//全局变量，x[i]表示顶点i的着色
bool judge(int i,int j) {				//判断顶点i是否可以着色j
	for(int k=0;k<n;k++) {
 		if(A[i][k]==1 && x[k]==j)	//存在相同颜色的顶点
     	return false;
 	}
 	return true;
}

void dfs(int m,int i) {				//回溯算法
	if (i>=n)					//达到叶子结点
		ans++;				//着色方案数增1
	else {
		for (int j=0;j<m;j++) {	//试探每一种着色
			x[i]=j;
			if (judge(i,j))		//可以着色j，进入下一个顶点着色
				dfs(m,i+1);
			x[i]=-1;				//回溯
		}
	}
}
void color(int m) {
	memset(x,0xff,sizeof(x));		//x初始化
	dfs(m,0);
	printf("着色方案数:%d\n",ans); 
}
int main() {
	int m=3;
	color(m);
	return 0;
}



```

### 子集和问题

无剪枝的算法：

```c++
#include<iostream>
#include<vector>
using namespace std;
int n,t;
vector<int> a;						//存放所有整数
int cnt=0;							//累计解个数
int tot=0;                         	//累计搜索的结点个数
vector<int> x;						//解向量 
void disp() {				//输出一个解
	printf("  第%d个解,",++cnt);
  	printf("选取的数为: ");
  	for (int i=0;i<x.size();i++) {
  		if (x[i]==1)
     	printf("%d ",a[i]);
 	}
  	printf("\n");
}
void dfs(int cs,int i) { 			//回溯算法
	tot++;
  	if (i>=n) {									//到达一个叶子结点
  		if (cs==t) disp();							//找到一个满足条件的解,输出
 	}
  	else {													//没有到达叶子结点
  		x[i]=1;											//选取整数a[i]
   		dfs(cs+a[i],i+1);
    	x[i]=0;											//不选取整数a[i]
    	dfs(cs,i+1);
	}
}
void subs1(vector<int>&A,int T) {				//求解子集和问题
	n=A.size();
	a=A;
	t=T;
	x=vector<int>(n);
  	printf("求解结果\n");
  	dfs(0,0);											//i从0开始
  	printf("tot=%d\n",tot);
}

int main() {
	int t=8;
	vector<int> a={3,1,5,2};					//存放所有整数
	//int t=3;
	//vector<int> a={1,3,2};					//存放所有整数
	subs1(a,t);
	return 0;
}

```

左剪枝：

```c++
#include<iostream>
#include<vector>
using namespace std;
int n,t;
vector<int> a;						//存放所有整数
int cnt=0;							//累计解个数
int tot=0;                         	//累计搜索的结点个数
vector<int> x;						//解向量 
void disp() {				//输出一个解
	printf("  第%d个解,",++cnt);
  	printf("选取的数为: ");
  	for (int i=0;i<x.size();i++) {
  		if (x[i]==1)
     	printf("%d ",a[i]);
 	}
  	printf("\n");
}
void dfs(int cs,int i) { 			//回溯算法
	tot++;
  	if (i>=n) {									//到达一个叶子结点
  		if (cs==t) disp();							//找到一个满足条件的解,输出
 	}
  	else {													//没有到达叶子结点
		if (cs+a[i]<=t) {								//左孩子结点剪支
     		x[i]=1;										//选取整数a[i]
     		dfs(cs+a[i],i+1);
		}
    	x[i]=0;											//不选取整数a[i]
    	dfs(cs,i+1);
	}
}
void subs2(vector<int>&A,int T) {				//求解子集和问题
	n=A.size();
	a=A;
	t=T;
	x=vector<int>(n);
  	printf("求解结果\n");
  	dfs(0,0);											//i从0开始
  	printf("tot=%d\n",tot);
}

int main() {
	int t=8;
	vector<int> a={3,1,5,2};					//存放所有整数
	//int t=3;
	//vector<int> a={1,3,2};					//存放所有整数
	subs2(a,t);
	return 0;
}

```

右剪枝：

```c++
#include<iostream>
#include<vector>
using namespace std;
int n,t;
vector<int> a;						//存放所有整数
int cnt=0;							//累计解个数
int tot=0;                         	//累计搜索的结点个数
vector<int> x;						//解向量 
void disp() {				//输出一个解
	printf("  第%d个解,",++cnt);
  	printf("选取的数为: ");
  	for (int i=0;i<x.size();i++) {
  		if (x[i]==1)
     	printf("%d ",a[i]);
 	}
  	printf("\n");
}
void dfs(int cs,int rs,int i) { 			//回溯算法
	tot++;
  	if (i>=n) {									//到达一个叶子结点
  		if (cs==t) disp();							//找到一个满足条件的解,输出
 	}
  	else {													//没有到达叶子结点
	  	rs-=a[i];											//求剩余的整数和
	  	string str="dfs("+to_string(cs+a[i])+","+to_string(rs)+","+to_string(i+1)+")";
		cout << str << endl;  	
		if (cs+a[i]<=t) {								//左孩子结点剪支
     		x[i]=1;										//选取整数a[i]
     		dfs(cs+a[i],rs,i+1);
			cout << str << "返回" << endl;
		}
		else
			cout << str << "->cut" << endl;
 
	  	str="dfs("+to_string(cs)+","+to_string(rs)+","+to_string(i+1)+")";
		cout << str << endl;  	
    	if (cs+rs>=t) {									//右孩子结点剪支
     		x[i]=0;										//不选取整数a[i]
      		dfs(cs,rs,i+1);
			cout << str << "返回" << endl;
		}
		else
			cout << str << "->cut" << endl;
	   	rs+=a[i];										//恢复剩余整数和(回溯)
	}
}
void subs3(vector<int>&A,int T) {				//求解子集和问题
	n=A.size();
	a=A;
	t=T;
	x=vector<int>(n);
	int rs=0;												//表示所有整数和
  	for (int j=0;j<n;j++)					//求rs
  		rs+=a[j];
  	printf("求解结果\n");
  	printf("dfs(0,%d,0)\n",rs);
  	dfs(0,rs,0);											//i从0开始
  	printf("tot=%d\n",tot);
}

int main() {
	//int t=8;
	//vector<int> a={3,1,5,2};					//存放所有整数
	int t=3;
	vector<int> a={1,3,2};					//存放所有整数
	subs3(a,t);
	return 0;
}

```

### 简单装载问题

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> w;
int t;
int n;
vector<int> x;									    //解向量
vector<int> bestx;									//存放最优解向量
int bestw=0;										//存放最优解的总重量，初始化为0
int tot=0;                         	 	//累计搜索的结点个数
void dfs(int cw,int rw,int i) { 	//回溯算法
	tot++;
  	if (i>=n) {									//达到一个叶子结点
  		if (cw>bestw) {				          	//找到一个满足条件的更优解
     	bestw=cw;					            //保存更优解
      	bestx=x;
    	}
 	}
  	else {														//尚未找完所有集装箱
  		rw-=w[i];											//求剩余集装箱的重量和
   		if (cw+w[i]<=t) {								//左孩子结点剪支：选择满足条件的集装箱
     	x[i]=1;											//选取集装箱i 
      	cw+=w[i];										//累计当前所选集装箱的重量和
      	dfs(cw,rw,i+1);
      	cw-=w[i];										//恢复当前所选集装箱的重量和(回溯)
    	}
    	if (cw+rw>bestw) {								//右孩子结点剪支
     	x[i]=0;											//不选择集装箱i
      	dfs(cw,rw,i+1);
    	}
    	rw+=w[i];											//恢复剩余集装箱的重量和(回溯)
  	}
}
void loading(vector<int>&W,int T) {							//求解简单装载问题
	w=W;
	t=T;
	n=w.size();
  	int rw=0;
  	for (int i=0;i<n;i++)						//累计全部集装箱的重量和rw
  		rw+=w[i];
	x=vector<int>(n);
	dfs(0,rw,0);										//i从0开始
  	printf("求解结果\n");
  	for (int i=0;i<n;i++) {      			//输出最优解
  		if (bestx[i]==1)
     		printf("  选取第%d个集装箱\n",i);
 	}
  	printf("  总重量=%d\n",bestw);
  	printf("tot=%d\n",tot);
}
int main() {
	vector<int> w={5,2,6,4,3};
	int	t=10;
	loading(w,t);
	return 0;
}

```



### 0/1背包问题

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct Goods {
	int no;  //物品编号
	int w;  //物品重量
	int v;  //物品价值
	Goods(int no, int w, int v) {
		this->no = no;
		this->w = w;
		this->v = v;
	}

	bool operator<(const Goods& s) const {
		return (double)v / w > (double)v / w;
	}
};

vector<Goods>g = { Goods(0,5,4),Goods(1,3,4),Goods(2,2,3),Goods(3,1,1) };
int W=6;  //最大重量
int n=4;
vector<int>x; //解向量
vector<int>bestx;  //存放最优解向量
int bestv = 0;  //存放最大价值
int bestw = 0;
int tot = 0; //累计搜索的节点个数
int cw = 0;  //当前背包总量
int cv = 0;  //当前背包价值

double bound(int i) {
	int rw = W - cw;
	double b = cv;
	int j = i;
	while (j < n && g[j].w < rw) {
		rw -= g[j].w;
		b += g[j].v;
		j++;
	}

	if (j < n) {
		b += (double)g[j].v / g[j].w*rw;
	}

	return b;
}

void dfs(int i) {
	tot++;
	if (i >= n) {
		if (cw <= W && cv > bestv) {
			bestv = cv;
			bestw = cw;
			bestx = x;
		}
	}

	else {
		if (cw + g[i].w <= W) {
			x[i] = 1;
			cw += g[i].w;
			cv += g[i].v;
			dfs(i + 1);
			cw -= g[i].w;
			cv -= g[i].v;

		}

		double b = bound(i + 1);  //不选当前节点的上限函数
		if (b > bestv) {
			x[i] = 0;
			dfs(i + 1);
		}
	}
}

void knap() {

	sort(g.begin(), g.end());
	x = vector<int>(n, 0);
	dfs(0);
	cout << "最佳装填方案：" << endl;
	for (int i = 0; i < n; i++) {
		if (bestx[i] == 1) {
			cout << "选取第" << g[i].no << "个物品" << endl;
		}
	}

	cout << "总重量=" << bestw << "总价值=" << bestv;


}

int main() {
	knap();


}
```

### 完全背包问题

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n=2; 
int w[]={1,2};
int v[]={2,5};
int W=2;
int bestv=0;      						//存放最大价值,初始为0
void dfs(int cw,int cv,int i) {    		//回溯算法
	if(i>=n) {
		printf("叶子:cw=%d,cv=%d,i=%d  ",cw,cv,i); 
  		if(cw<=W && cv>bestv) {      	//找到一个更优解
     		bestv=cv;
     		printf(" => bestcv=%d",bestv);
     	}
     	printf("\n");     	
	}
  	else {
  		string str="dfs1("+to_string(cw)+","+to_string(cv)+","+to_string(i+1)+")";
  		cout << str << endl;
  		dfs(cw,cv,i+1);             	//不选择物品i
  		cout << str<< "返回" << endl;
		printf("i=%d, cw+w[i]=%d,W=%d\n",i,cw+w[i],W); 
   		if(cw+w[i]<=W) {						//剪支
  			str="dfs2("+to_string(cw+w[i])+","+to_string(cv+v[i])+","+to_string(i)+")";
  			cout << str << endl;
     		dfs(cw+w[i],cv+v[i],i);     	//选择物品i，然后继续选择物品i
  			cout << str<< "返回" << endl;
     	}
		printf("i=%d, cw+w[i]=%d,W=%d\n",i,cw+w[i],W);     	
  	  	if(cw+w[i]<=W) {					//剪支
  			str="dfs3("+to_string(cw+w[i])+","+to_string(cv+v[i])+","+to_string(i+1)+")";
  			cout << str << endl;
	     	dfs(cw+w[i],cv+v[i],i+1);   	//选择物品i,然后选下一件
  			cout << str<< "返回" << endl;
	    }
  	}
}
void completeknap1() {					//求完全背包问题
	printf("dfs(0,0,0)\n");
	dfs(0,0,0);
    printf("最大价值=%d\n",bestv);
}
int main() {
	completeknap1();
	return 0;
}

```





```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n=2; 
int w[]={1,2};
int v[]={2,5};
int W=2;
int bestv=0;      						//存放最大价值,初始为0
void dfs(int cw,int cv,int j) {    		//回溯算法
	printf("调用dfs(%d,%d,%d)\n",cw,cv,j); 
	if(cw<=W && cv>bestv) {      		//找到一个更优解
    	bestv=cv;
		printf("叶子: cv=%d,bestv=%d\n",cv,bestv);
    }
    for (int j1=j;j1<n;j1++) {
     		printf("j1=%d, cw+w[j1]=%d,W=%d\n",j1,cw+w[j1],W); 
   			if(cw+w[j1]<=W) {					//剪支
   				string str="j="+to_string(j)+",选择j1="+to_string(j1)+" dfs("+ to_string(cw+w[j1])+","+to_string(cv+v[j1])+","+to_string(j1)+")";
   				cout << str << endl;
     			dfs(cw+w[j1],cv+v[j1],j1);     	//选择物品i，然后继续选择物品i
     			cout << str << "返回" << endl; 
     		}
     		else printf("超重\n"); 
  		}
}
void completeknap2() {					//求完全背包问题
	dfs(0,0,0);
    printf("最大价值=%d\n",bestv);
}
int main() {
	completeknap2();
	return 0;
}

```



### 基于排列问题的回溯算法框架

```c++
#include<iostream>
#include<vector>
using namespace std;
vector<int> x;							//解向量
vector<int> used;						//used[i]表示a[i]是否使用过 
int cnt=0;								//累计排列个数 
void disp() {							//输出一个解
	printf("  %2d {",++cnt);
	for (int i=0;i<x.size()-1;i++)
		printf("%d,",x[i]);
	printf("%d}\n",x.back());
}
void dfs(vector<int> &a,int i) {	//回溯算法
	int n=a.size();
	if (i>=n)
		disp();
	else {
		for(int j=0;j<n;j++) {
			if(used[j]) continue;
			x[i]=a[j];
			used[j]=1;
			dfs(a,i+1);				//选择a[j]
			used[j]=0;
			x[i]=0;
		}
	}
}
void perm1(vector<int> &a) {		//求全排列算法1
	int n=a.size();
	x=vector<int>(n);
	used=vector<int>(n,0);
	dfs(a,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("求解结果\n");
	perm1(a);
	return 0;
}


```



交换法

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
vector<int> x;						//解向量
int cnt=0;							//累计排列个数
void disp() {						//输出一个解
	printf("  %2d {",++cnt);
	for (int i=0;i<x.size()-1;i++)
		printf("%d,",x[i]);
	printf("%d}\n",x.back());
}
void dfs(int i) {	//回溯算法
	int n=x.size();
	if (i>=n)
		disp();
	else {
		for(int j=i;j<n;j++) {
			swap(x[i],x[j]);		//交换a[i]与a[j]
			dfs(i+1);
			swap(x[i],x[j]);		//交换a[i]与a[j]：恢复
		}
	}
}
void perm2(vector<int> &a) {		//求全排列算法2
	int n=a.size();
	x=vector<int>(n);
	for(int i=0;i<n;i++)			//置x=a 
		x[i]=a[i]; 
	dfs(0);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<int> a={1,2,3};
	printf("求解结果\n");
	perm2(a);
	return 0;
}


```



### n皇后问题

需要注意的是如何判断对角线

```c++
#include<iostream>
#include<vector>
using namespace std;
#define MAXN 20					//最多皇后个数
int q[MAXN];					//存放n皇后问题的解(解向量)
int cnt=0;						//累计解个数
void disp(int n) {  			//输出一个解
	printf("  第%d个解:",++cnt);
	for (int i=0;i<n;i++)
		printf("(%d,%d) ",i,q[i]);
	printf("\n");
}
bool valid(int i,int j) {                   	//测试(i,j)位置能否放置皇后
	if (i==0) return true;                      //第一个皇后总是可以放置
    int k=0;
    while (k<i) {                               //k=1～i-1是已放置了皇后的行
       	if ((q[k]==j) || (abs(q[k]-j)==abs(i-k)))
           	return false;
       	k++;
    }
    return true;
}
void dfs(int n,int i) {						  //回溯算法
	if (i>=n)
  		disp(n);								//所有皇后放置结束
  	else {
  		for (int j=i;j<n;j++) {				//在第i行上试探每一个列j
     		swap(q[i],q[j]);					//第i个皇后放置在q[j]列
      		if(valid(i,q[i]))					//剪支
       			dfs(n,i+1);
      		swap(q[i],q[j]);					//回溯
    	}
 	}
}
void queen(int n) {							//求解n皇后问题
  	for(int i=0;i<n;i++)           		//初始化q为0-n-1
  		q[i]=i;
	dfs(n,0);
}
int main() {
	//freopen("abc.out","w",stdout);
	int n=6;								//n存放实际皇后个数
	printf("%d皇后问题求解如下:\n",n);
	queen(n);
	return 0;
}

```



### 任务分配问题

注意下限函数，这种剪枝的思想在回溯算法中很常见

```c++
#include<iostream>
#include<vector>
using namespace std;
const int INF=0x3f3f3f3f;
int n;
vector<vector<int>> c;
vector<int> x;						//解向量
vector<int> bestx;					//最优解向量
int bestc;							//最小成本 
vector<bool> used; 
int bound(int cost,int i) {								//求下界算法
	int minsum=0;
  	for (int i1=i;i1<n;i1++) {								//求c[i..n-1]行中最小元素和
  		int minc=INF;
   		for (int j1=0;j1<n;j1++) {
     		if (used[x[j1]]==false && c[i1][x[j1]]<minc)
       		minc=c[i1][x[j1]];
		}
    	minsum+=minc;
  	}
  	return cost+minsum;
}
void dfs(int cost,int i) {							//回溯算法
  	if (i>=n) {				            			//到达一个叶子结点  		
  		if (cost<bestc) {		        			//比较求最优解
     		bestc=cost;
      		bestx=x;
    	}
  	}
 	else {
  		for (int j=i;j<n;j++) {						//为人员i试探任务x[j]
     		swap(x[i],x[j]);						//为人员i分配任务x[j]
      		used[x[i]]=true;
      		cost+=c[i][x[i]];
      		if(bound(cost,i+1)<bestc)				//剪支
     			dfs(cost,i+1);						//继续为人员i+1分配任务
     		cost-=c[i][x[i]];						//cost回溯
      		used[x[i]]=false;						//used回溯
     		swap(x[i],x[j]);
    	}
	}
}
void allocate(vector<vector<int>> &C) {     		//求解任务分配问题
	c=C;
	n=c.size();
  	x=vector<int>(n);
  	for(int i=0;i<n;i++)							//将x[0..n-1]分别设置为0到n-1值
  		x[i]=i;
  	used=vector<bool>(n,false);
  	bestc=INF;
  	dfs(0,0);										//从人员0开始
  	printf("最优分配方案\n");
  	for (int k=0;k<n;k++)
  		printf("   人员%d分配任务%d\n",k,bestx[k]);
 	printf("   总成本=%d\n",bestc);
}
int main() {
	//freopen("abc.out","w",stdout);
	vector<vector<int>> C={{9,2,7,8},{6,4,3,7},{5,8,1,8},{7,6,9,4}};
	allocate(C);	
	return 0;
}


```



### 旅行商问题

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20241030092947443.png" alt="image-20241030092947443" style="zoom:50%;" />

```c++
#include<iostream>
#include<vector>
#include <limits>
using namespace std;
const int INF = std::numeric_limits<int>::max();
vector<int>x;  //解向量
vector<int>bestx;  //最优解向量
int d;  //路径长度
int bestd = INF;
void dfs(vector<vector<int>>& A, int s, int i,int n) {
	if (i >= n) {
		if (d +A[x[n-1]][s]< bestd) {
			bestd = d + A[x[n - 1]][s];
			bestx = x;
			bestx.push_back(s);
		}
	}
	else {
		for (int j = i; j < n; j++) {
			if (A[x[i - 1]][x[j]] != 0 && A[x[i - 1]][x[j]] != INF) {
				if (d + A[x[i - 1]][x[j]] < bestd) {
					swap(x[i], x[j]);
					d += A[x[i - 1]][x[i]];
					dfs(A, s, i + 1, n);
					d -= A[x[i - 1]][x[i]];
					swap(x[i], x[j]);
				}
			}
		}
	}
}

void TSP(vector<vector<int>>& A, int s) {
	int n = A.size();
	x.push_back(s);
	for (int i = 0; i < n; i++) {
		if (i != s) x.push_back(i);
	}
	d = 0;
	dfs(A, s, 1,n);
	cout << "最短路径:";
	for (int i = 0; i < bestx.size(); i++) {
		if (i == 0) cout << bestx[i];
		else cout << "->" << bestx[i];
	}
	cout << endl << "路径长度：" << bestd;
}
int main() {
	vector<vector<int>> A = { {0,8,5,36},{6,0,8,5},{8,9,0,5},{7,7,8,0} };
	int s = 0; 									//指定起点
	printf("求解结果:\n");
	TSP(A, s);

}
```



### 力扣114二叉树展开为链表

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        // 算法之神保佑！
        // 左子树为空，直接考虑下一个节点
        while (root != nullptr) {
            if (root->left == nullptr) {
                root = root->right;
            } else {
                TreeNode* pre = root->left;
                while (pre->right != nullptr) {
                    pre = pre->right;
                }
                pre->right = root->right;
                root->right = root->left;
                root->left = nullptr;
                root = root->right;
            }
        }
    }
};
```

### ACWing递归实现组合型枚举

分析代码，觉得难点在于怎样表示每次枚举的数都比当前值要大

比如第一个数是3，那么我的下一个数必须在4，5中选

代码中定义了for循环，定义了变量start,解决了该问题

```c++
#include<iostream>
using namespace std;
int n,r;
const int N=21;
int arr[N];
void dfs(int x,int start){
    if(x>r){
        for(int i=1;i<=r;i++){
            cout<<arr[i]<<' ';
        }
        cout<<endl;
        return;
    }
    
    for(int i=start;i<=n;i++){
        arr[x]=i;
        dfs(x+1,i+1);//每次递归一定是下一位，保证数据不重复
        arr[x]=0;
    }
}
int main(){
    cin>>n>>r;
    dfs(1,1);
    return 0;
    
}
```



### ACWing递归实现排列型枚举

递归树依据：一次枚举每个位置应该放哪个数

全排列要求数字不允许重复，但是有些题目：

比如有是个位置，要求我们只填3个数的话，那就可以有重复数字  

```c++
#include<iostream>
using namespace std;
const int N=20;
int n;
int st[N];
int arr[N];
void dfs(int x){
    if(x>n){
        for(int i=1;i<=n;i++){
            cout<<arr[i]<<" ";
        }
        cout<<endl;
    }
    for(int i=1;i<=n;i++){
        if(!st[i]){//如果这个数还没有被选过
            st[i]=1;
            arr[x]=i;
            dfs(x+1);
            st[i]=0;
            arr[x]=0;
        }
    }
}
int main(){
    cin>>n;
    dfs(1);
    return 0;
}
```



### ACWing递归实现指数型枚举

本题设置了三种状态，分别是1选取，2不选，0待定，分析问题时可知每个数字只有这三种情况，所以我们对每个数字枚举这三个值，但是枚举下一个值之前需要恢复现场

```c++
#include<iostream>
using namespace std;
int n;
const int N = 20;
int arr[N];

void dfs(int x) {
    if (x > n) {
        for (int i = 1; i <= n; i++) {
            if (arr[i] == 1) {
                cout << i << ' ';
            }
        }
        cout << endl;
        return;
    }
    
    //记得回溯
    arr[x] = 1;
    dfs(x + 1);
    arr[x] = 0;
    /*
在这个特定的代码中，arr[x] = 0; 这一行可以省略。因为在每次调用 dfs 函数时，arr 数组都会被重置为全零，所以在递归回溯的过程中，arr[x] 的值不会保留到下一次调用 dfs 函数。但是在更复杂的情况下，如果在递归回溯的过程中需要保持 arr 数组的某些特定状态，那么这一行不能省略。*/

    arr[x] = 2;
    dfs(x + 1);
    arr[x] = 0;

}
int main() {
    cin >> n;
    dfs(1);
    return 0;

}
```

### 力扣电话号码的字母组合

注意回溯

```c++
class Solution {
public:
    const vector<string> phoneMap = {"",    "",    "abc",  "def", "ghi",
                                     "jkl", "mno", "pqrs", "tuv", "wxyz"};

    void func(string& digits,int index,string &current,vector<string>&res){
        if(index==digits.size()){
            res.push_back(current);
            return;
        }

        int digit=digits[index]-'0';
        const string& letters = phoneMap[digit];
        for(auto le:letters){
            current.push_back(le);
            func(digits,index+1,current,res);
            current.pop_back();
        }

    }
    vector<string> letterCombinations(string digits) {
         vector<string>res;
        if(digits=="") return res;
        string current;
       
        int n=digits.size();
        func(digits,0,current,res);
        return res;

       
    }
};
```

### 力扣22括号生成

**有效括号的判定条件是：**

任何有效括号字符串的前缀，左括号的数量不少于右括号的数量

最终的左右括号数量相等

我们来重现递归过程：

**第一步**：

- `current = ""`, `left = 0`, `right = 0`
- 可以添加左括号，调用 `backtrack("(", 1, 0, 3, result)`

**第二步**：

- `current = "(", left = 1, right = 0`
- 可以继续添加左括号，调用 `backtrack("((", 2, 0, 3, result)`
- 也可以添加右括号，但 `left` 数量未达到 `n`，优先添加左括号

**第三步**：

- `current = "((", left = 2, right = 0`
- 可以继续添加左括号，调用 `backtrack("(((", 3, 0, 3, result)`

**第四步**：

- `current = "(((", left = 3, right = 0`
- 已经达到最大左括号数，只能添加右括号，调用 `backtrack("((()", 3, 1, 3, result)`

**第五步**：

- `current = "((()", left = 3, right = 1`
- 继续添加右括号，调用 `backtrack("((())", 3, 2, 3, result)`

**第六步**：

- `current = "((())", left = 3, right = 2`
- 继续添加右括号，调用 `backtrack("((()))", 3, 3, 3, result)`

**第七步**（终止条件）：

- `current = "((()))", left = 3, right = 3`
- `current.length() == 2 * n`，将 `"((()))"` 添加到结果列表 `result`

**回溯**（回到第三步）：

- `current = "((", left = 2, right = 0`
- 尝试添加右括号，调用 `backtrack("(()", 2, 1, 3, result)`

**第八步**：

- `current = "(()", left = 2, right = 1`
- 可以继续添加左括号，调用 `backtrack("(()(", 3, 1, 3, result)`

**第九步**：

- `current = "(()(", left = 3, right = 1`
- 已经达到最大左括号数，只能添加右括号，调用 `backtrack("(()()", 3, 2, 3, result)`

**第十步**：

- `current = "(()()", left = 3, right = 2`
- 继续添加右括号，调用 `backtrack("(()())", 3, 3, 3, result)`

**第十一步**（终止条件）：

- `current = "(()())", left = 3, right = 3`
- `current.length() == 2 * n`，将 `"(()())"` 添加到结果列表 `result`

**回溯**（回到第二步）：

- `current = "(", left = 1, right = 0`
- 尝试添加右括号，调用 `backtrack("()", 1, 1, 3, result)`

**第十二步**：

- `current = "()", left = 1, right = 1`
- 可以继续添加左括号，调用 `backtrack("()(", 2, 1, 3, result)`

**第十三步**：

- `current = "()(, left = 2, right = 1`
- 可以继续添加左括号，调用 `backtrack("()((", 3, 1, 3, result)`

**第十四步**：

- `current = "()((", left = 3, right = 1`
- 已经达到最大左括号数，只能添加右括号，调用 `backtrack("()(()", 3, 2, 3, result)`

**第十五步**：

- `current = "()((), left = 3, right = 2`
- 继续添加右括号，调用 `backtrack("()(())", 3, 3, 3, result)`

**第十六步**（终止条件）：

- `current = "()(())", left = 3, right = 3`
- `current.length() == 2 * n`，将 `"()(())"` 添加到结果列表 `result`

**回溯**（回到第十二步）：

- `current = "()", left = 1, right = 1`
- 尝试添加右括号，调用 `backtrack("()()", 2, 2, 3, result)`

**第十七步**：

- `current = "()()", left = 2, right = 2`
- 可以继续添加左括号，调用 `backtrack("()()(", 3, 2, 3, result)`

**第十八步**：

- `current = "()()(", left = 3, right = 2`
- 已经达到最大左括号数，只能添加右括号，调用 `backtrack("()()()", 3, 3, 3, result)`

**第十九步**（终止条件）：

- `current = "()()()", left = 3, right = 3`
- `current.length() == 2 * n`，将 `"()()()"` 添加到结果列表 `result`

```c++
class Solution {
public:
    void ba(string s, int n, int left, int right, vector<string>& res) {
        int len = s.size();
        if (len == 2 * n) {
            res.push_back(s);
            return;
        }
        if (left < n) {
            ba(s + '(', n, left + 1, right, res);
        }

        if (right < left) {
            ba(s + ')', n, left, right + 1, res);
        }
    }
    vector<string> generateParenthesis(int n) {
        // 经典回溯问题
        vector<string> res;
        ba("", n, 0, 0, res);
        return res;
       
    }
};
```

### 力扣40组合总和II

枫老师也是好起来了，都会自己写回溯了

去重逻辑

https://www.bilibili.com/video/BV12V4y1V73A/?spm_id_from=333.788&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

![image-20240718223851548](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718223851548.png)

```c++
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
class Solution {
public:
    void dfs(int sum, vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& res, int n) {
        if (sum > target || index >n) return;
        if (sum == target) {
            res.push_back(current);
            return;
        }

        for (int i = index; i < n; i++) {
            if (i>index && candidates[i] == candidates[i - 1]) continue;
            sum += candidates[i];
            current.push_back(candidates[i]);
            dfs(sum, candidates, target, i+1, current, res, n);
            sum -= candidates[i];
            current.pop_back();

        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>>res;
        int n = candidates.size();
        sort(candidates.begin(), candidates.end());
        vector<int>current;
        int sum = 0;
        int index = 0;
        dfs(sum, candidates, target, index, current, res, n);
        return res;


    
    }
};


int main() {
    vector<int>a = {2,2,6 };
    int target = 8;
    Solution b;
    vector<vector<int>>res;
   
    res=b.combinationSum2(a, target);
    for (auto i : res) {
        for (auto j : i) {
            cout << j << ' ';
        }
        cout << endl;
    }
   
    return 0;
}


```

### 力扣46全排列

<img src="D:\WeChat Files\wxid_aaaljrtur35n22\FileStorage\Temp\31c3c6b720969af1aad9b3d26477fa1.jpg" alt="31c3c6b720969af1aad9b3d26477fa1" style="zoom: 50%;" />

```c++
class Solution {
public:
    void dfs(vector<int>& nums, int n, vector<vector<int>>& res, vector<int>& current, vector<int>& used) {
        if (current.size() == n) {
            res.push_back(current);
            return;
        }

        for (int i = 0; i < n; i++) {
            if (used[i]) continue;
            used[i] = 1;
            current.push_back(nums[i]);
            dfs(nums, n, res, current, used);
            current.pop_back();
            used[i] = 0;
        }

    }
    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        vector<int>used(n, 0);
        vector<vector<int>>res;
        vector<int>current;
        dfs(nums, n, res, current,used);
        return res;
    }
};
```

### 力扣47全排列II

去重逻辑：

![image-20240718225248217](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240718225248217.png)

```c++
class Solution {
public:
    void dfs(vector<int>& nums, int n, vector<vector<int>>& res,
        vector<int>& current, vector<int>& used) {
        if (current.size() == n) res.push_back(current);
           
        

        for (int i = 0; i < n; i++) {
           
            if (i > 0 && nums[i] == nums[i - 1]&&used[i-1]==0) continue;
            if (used[i]) continue;
            used[i] = 1;
            current.push_back(nums[i]);
            dfs(nums, n, res, current, used);
            current.pop_back();
            used[i] = 0;
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        int n = nums.size();
        vector<int> used(n, 0);
        vector<vector<int>> res;
        vector<int> current;
        sort(nums.begin(), nums.end());
        dfs(nums, n, res, current, used);
        return res;
    }
};
```

### 汉诺塔问题

汉诺塔问题的主要思想是：

1. 将 `n-1` 个盘子从源柱子（A）移动到辅助柱子（B）。
2. 将第 `n` 个盘子从源柱子（A）移动到目标柱子（C）。
3. 将 `n-1` 个盘子从辅助柱子（B）移动到目标柱子（C）。

```
void hanoi(int n, char source, char auxiliary, char destination) {
    if (n == 1) {
        cout << source <<" " << "To"<<" " << destination << endl;
        return;
    }

    else {
        hanoi(n - 1, source, destination, auxiliary);


        cout << source <<" " << "To"<<" " << destination << endl;
        hanoi(n - 1, auxiliary, source, destination);

       
    }

 
}
```

### 谷仓的安保

Farmer John给谷仓安装了一个新的安全系统，并且要给牛群中的每一个奶牛安排一个有效的密码。一个有效的密码由L(3 <= L <= 15)个小写字母(来自传统的拉丁字母集'a'...'z')组成，至少有一个元音('a', 'e', 'i', 'o', 或者 'u')，至少两个辅音(除去元音以外的音节)，并且有按字母表顺序出现的字母(例如，'abc'是有效的，而'bac'不是) 。
给定一个期望长度L和C个小写字母，写一个程序，打印出所有的长度为L、能由这些字母组成的有效密码。密码必须按字母表顺序打印出来，一行一个。



第一行: 两个由空格分开的整数，L和C。
第二行: C个空格分开的小写字母，密码是由这个字母集中的字母来构建的。



输出若干行，每一个输出行包括一个长度为L个字符的密码(没有空格)。输出行必须按照字母顺序排列。
如果计算出超过25000个有效密码，你的程序只需输出前25000个有效密码，即使后面还存在有效密码。



```c++
//样例输入
4 6
a t c i s w
    
//样例输出
acis
acit
aciw
acst
acsw
actw
aist
aisw
aitw
astw
cist
cisw
citw
istw
```





```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int L, C;
vector<char> arr(20);
vector<char> current(30);
vector<bool>st(30);
int cnt = 0;


void dfs(int start, int len) {
    if (cnt >= 25000) exit(0);

    if (len == L) {
        int cnt1 = 0, cnt2 = 0;
        for (auto i : current) {
            if (i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u') cnt1++;
            else cnt2++;
        }

        if (cnt1 >= 1 && cnt2 >= 2) {
            for (char c : current) {
                cout << c;
            }
            cout << endl;
            cnt++;
            if (cnt >= 25000) exit(0);
        }
        return;
    }

    for (int i = start; i < C; i++) {
        if (cnt >= 25000) exit(0);
        if (!st[i]) {
            current[len] = arr[i];
            st[i] = 1;
            dfs(i + 1, len + 1);
            st[i] = 0;

        }
    }
}

int main() {
  
    cin >> L >> C;

    for (int i = 0; i < C; i++) cin >> arr[i];

    sort(arr.begin(), arr.begin() + C);
    dfs(0, 0);

    return 0;
}
```

### 八皇后问题

本题是经典回溯模板题，其实和写八个for循环是一样的，只不过回溯写起来方便一些

主要逻辑就是遍历每行，再遍历该行的每一列，如果该行、该列、对角线上都没有皇后，就加一个皇后，再遍历下一行

所以在判断map[i] [j]是否可以存放节点的时候，本行的下一行一定没有皇后，不用判断下面行，因为下面行还没有遍历到，本行下面的两条对角线也没有皇后，所以只判断该列上和左上、右上对角线上是否有皇后即可





```c++
#include<iostream>
using namespace std;

const int N = 10;
int map[N][N] = { 0 };
int cnt = 0;

bool isvalid(int row, int column) {
    for (int i = 1; i < row; i++) {
        if (map[i][column]) return false;
        if (column-(row-i) >= 1 && map[i][column - (row-i)]) return false;
        if (column + (row-i)<= 8 && map[i][column + (row-i)]) return false;
    }
    return true;
}

void dfs(int row) {
    if (row == 9) {
        cnt++;
        cout << "No." <<" "<<cnt << endl;
        for (int i = 1; i <= 8; i++) {
            for (int j = 1; j <= 8; j++) {
                cout << map[i][j] << " ";
            }
            cout << endl;
        }
        return;
    }

    for (int i = 1; i <= 8; i++) {
        if (isvalid(row, i)) {
            map[row][i] = 1;
            dfs(row + 1);
            map[row][i] = 0;
        }
    }
}

int main() {
    dfs(1);
    return 0;
}

```

### 数迷

给出含有N×N个格子的正方形表格，要求每个格子都填上一个**个位数**（范围1～N），使得每行、每列以及同一斜线上的数字都不同。部分格子已经填好数字。求满足题意的方案数。

第一行输入一个整数N (1<=N<=9)。

下来给出一个部分已经填好数字的正方形。总共N行，每行N个字符，‘*’表示空白格子，还没有填数字。

```c++
//输入
5
54*21
3*154
*54*2
4*215
*1***
    
//输出1
```



第一种方法是遍历每一层，检查这一层的每一列，如果需要填数字的话，遍历所有能遍历的数据的可能，再递归调用本层，如果还有需要填数的格子，继续填数字，知道本层填满数字



```c++
#include <iostream>
#include <vector>
using namespace std;

const int N = 10;
vector<string> map(N);
int n;
int cnt = 0;


bool isvalid(int row, int column, char num) {
  
    for (int i = 0; i < n; i++) {
        if (i != column && map[row][i] == num) return false;
        if (i != row && map[i][column] == num) return false;
    }

    for (int i = 1; i < n; i++) {
        if (row + i < n && column + i < n && map[row + i][column + i] == num) return false;
        if (row + i < n && column - i >= 0 && map[row + i][column - i] == num) return false;
        if (row - i >= 0 && column + i < n && map[row - i][column + i] == num) return false;
        if (row - i >= 0 && column - i >= 0 && map[row - i][column - i] == num) return false;
    }

    return true;
}


void dfs(int row) {
    if (row == n) {
        for (int i = 0; i < n; i++) cout << map[i] << endl;
        cnt++;
       
        return;
    }

  
    for (int i = 0; i < n; i++) {
        if (map[row][i] == '*') {
            for (int j = 1; j <= n; j++) {
                char num = j + '0';
                if (isvalid(row, i, num)) {
                    map[row][i] = num;
                    dfs(row); 
                    map[row][i] = '*';  
                }
            }
            return; 
        }
    }

   
    dfs(row + 1);  
    
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> map[i];
    }
    dfs(0);
    cout << cnt;
    return 0;
}

```





第二种方法是遍历每一个要填充的数字，再遍历填数，如果当前可以填数字，则继续遍历下一个空格

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

const int N = 10;
int n;
int res = 0;
int num_cnt = 0;
vector<string> map(N);
vector<pair<int, int>> record;

bool isvalid(char num, int x, int y) {
    for (int i = 0; i < n; i++) {
        if (map[x][i] == num || map[i][y] == num) return false; // 同行或同列
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if ((i + j == x + y || i - j == x - y) && map[i][j] == num) return false; // 对角线
        }
    }
    return true;
}

void dfs(int num) {
    if (num == num_cnt) {
        res++;
        return;
    }

    int x = record[num].first;
    int y = record[num].second;

    for (int i = 1; i <= n; i++) {
        if (isvalid(i + '0', x, y)) {
            map[x][y] = i + '0';
            dfs(num + 1);
            map[x][y] = '*';
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> map[i];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (map[i][j] == '*') {
                record.push_back({i, j});
                num_cnt++;
            }
        }
    }

    dfs(0);
    cout << res;
    return 0;
}

```



# 深度优先

### [云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com)](https://www.luogu.com/paste/vjf2z3hi)

### 递归树

#### 递归树的深度

递归树的深度指的是从根节点（初始函数调用）到最深的叶子节点（最后一次递归调用）所经过的节点数或调用次数。它反映了递归调用的最大嵌套层次。

### 力扣不同路径

问题转化为求二叉树的叶子节点

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<numeric>
using namespace std;

int func(int x,int y,int endx,int endy) {
    if (x > endx || y > endy) return 0;
    if (x == endx && y == endy) return 1;
    return func(x + 1, y,endx,endy) + func(x, y + 1,endx,endy);



}
int main() {
    cout << func(0,0, 2,2);
}
```

$$
对于该递归树，他的深度为(endx-x+endy-y),时间复杂度为2^{endx-x+endy-y}
$$



### 15届蓝桥杯数字接龙

```c++
#include <iostream>
#include <string>
using namespace std;
const int N = 20;
int map[N][N];//地图
bool vis[N][N];//状态数组
string res;//存放答案,输出第一次搜索到的字符串
//搜索不到，输出-1也有分
int dx[8] = {-1,-1,0,1,1,1,0,-1};//方向数组,下标和给定方向一致
int dy[8] = {0,1,1,1,0,-1,-1,-1};

int n, k;
void dfs(int x, int y, int pre, string s, int dep) {
    if (x == n && y == n && dep == n * n) {
        //如果搜索到终点并且搜索深度等于n*n，说明已经搜索到结尾，搜索结束
        if (res.empty()) res = s;//此时为空说明一定是字典序最小的，返回
        return;
    }

    for (int i = 0; i < 8; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a<1 || b<1 || a>n || b>n) continue;
        if (vis[a][b]) continue;

        //防止交叉搜索
        //思想是会出现交叉搜索的是1、3、5、7这四条
        //如果相邻点被标记过，说明被交叉搜索了
        if (i == 1 && vis[x - 1][y] && vis[x][y + 1]) continue;
        else if (i == 3 && vis[x + 1][y] && vis[x][y+1]) continue;
        else if (i == 5 && vis[x+1][y] && vis[x][y-1]) continue;
        else if (i == 7 && vis[x-1][y] && vis[x][y - 1]) continue;

        //保证搜索方向是0，1，2，k-1...
        if ((map[a][b] < k && map[a][b] == pre + 1) || (pre+1==k &&map[a][b]==0)) {
            //开始搜索
            vis[a][b] = true;
            dfs(a, b, map[a][b], s + to_string(i), dep + 1);

            //最优性剪枝
            if (!res.empty()) return;//如果结果字符串非空，逐层返回
            
            vis[a][b] = false;//本题必须引入回溯

        }
    }
}

int main() {
    //首先你要把题目都清楚
    //题目都不清楚怎么模拟呢？
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> map[i][j];
        }
    }

    string emp;
    vis[1][1] = 1;
    
    //参数分别是下标x,y,搜索序列，拼接字符串和搜索深度
    dfs(1, 1, 0, emp, 1);
    if (res.empty()) cout << -1 << endl;
    else cout << res << endl;

    
    return 0;
}

```



### 力扣99恢复二叉搜索树

空间复杂度为0n的做法

```c++
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& nums) {
        if (root == nullptr) {
            return;
        }
        inorder(root->left, nums);
        nums.push_back(root->val);
        inorder(root->right, nums);
    }

    pair<int,int> findTwoSwapped(vector<int>& nums) {
        int n = nums.size();
        int index1 = -1, index2 = -1;
        for (int i = 0; i < n - 1; ++i) {
            if (nums[i + 1] < nums[i]) {
                index2 = i + 1;
                if (index1 == -1) {
                    index1 = i;
                } else {
                    break;
                }
            }
        }
        int x = nums[index1], y = nums[index2];
        return {x, y};
    }
    
    void recover(TreeNode* r, int count, int x, int y) {
        if (r != nullptr) {
            if (r->val == x || r->val == y) {
                r->val = r->val == x ? y : x;
                if (--count == 0) {
                    return;
                }
            }
            recover(r->left, count, x, y);
            recover(r->right, count, x, y);
        }
    }

    void recoverTree(TreeNode* root) {
        vector<int> nums;
        inorder(root, nums);
        pair<int,int> swapped= findTwoSwapped(nums);
        recover(root, 2, swapped.first, swapped.second);
    }
};


```

### 力扣110判断平衡二叉树

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return depth(root)!=-1;
    }
    int depth(TreeNode*root){
        if(root==nullptr) return 0;
        int left =depth(root->left);
        if(left==-1) return -1;
        int right=depth(root->right);
        if(right==-1) return -1;
        return abs(left-right)<2?max(left,right)+1:-1;    
    }
};
```



### 力扣113路径总和

```c++
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return;
        }
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            ret.emplace_back(path);
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();//回溯
    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};


```





### 洛谷p1036选数

```c++
#include<iostream>
using namespace std;
const int N=30;
int n,k;
int arr[N];
int choose[N];
int res=0;

bool is_prime(int sum){
    for(int i=2;i<sum/i;i++){
        if(sum%i==0) return false;
    }
    return true;
}
void dfs(int x,int start){
    
    if(x>k){
        int sum=0;
        for(int i=1;i<=k;i++){
            sum+=choose[i];
        }
        if(is_prime(sum)) res++;
        return;
        
    }
    for(int i=start;i<=n;i++){//用下标表示start，但是实际上是arr[i]
        choose[x]=arr[i];//组合型枚举的简单应用辣啦
        dfs(x+1,i+1);
        choose[x]=0;
    }
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
    }
    //组合数
    dfs(1,1);
    cout<<res;
    return 0;
    
}
```



### 洛谷p1088火星人

//全排列模板

//设置状态数组和答案数组

//同时注意到，因为刚开始遍历的时候不一定是从最小开始，输入了mars数组，我们让i从mars[x]开始遍历

//找到之后可以停止程序

```c++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
int N, M;
int mars[10010];
int st[10010];
int arr[10010];
int res = 0;
int return0 = 0;
void dfs(int x) {
    if (return0 == 1) {
        return;
    }
    if (x > N) {
        res++;
        if (res == M + 1) {
            return0 = 1;
            for (int i = 1; i <= N; i++) {
                printf("%d ", arr[i]);
            }
        }
    }
    for (int i = 1; i <= N; i++) {
        if (res == 0) {
            i = mars[x];
        }
            if (!st[i]) {
                st[i] = 1;
                arr[x] = i;
                dfs(x + 1);
                st[i] = 0;
                arr[x] = 0;
            }
        }
    }

int main() {
    cin >> N;
    cin >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d",&mars[i]);
    }
    dfs(1);
}
```





虽然但是，STL你是我的神，比赛就用你！！！

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int N,M;
	string s="";
	cin>>N;
	cin>>M;
	char ch;
	for(int i=0;i<N;i++){
		cin>>ch;
		s+=ch;
	}
	while(M--){
		next_permutation(s.begin(),s.end());
	}
	cout<<s;
    return 0;
}

```



### 洛谷p2089烤鸡

我们发现数组中的每一个数只有三种状态，和指数型枚举类似

```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 11;
int n;
vector<int>choose(11);
int res = 0;
int sum = 0;
vector<vector<int>>ans;


void dfs(int x)
{
    if (x > 10) {
        if (sum == n) {
            ans.push_back(choose);
            res += 1;
        }              
        return;
    }
    for (int i = 1; i <= 3; i++) {
        choose[x] = i;
        sum += i;
        if (sum <= n) {
            dfs(x + 1);
        }
        sum -= i;
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << res << endl;
    for (auto p : ans) {
        for (int i = 1; i <= 10; i++) {
            cout << p[i] << " ";
        }
        cout << endl;
    }
    
    return 0;
}

```



### p1149火柴棒等式

我真笑了，自认为开1000数据太大了，然后改小了，答案就不对，不要太高傲了啊啊啊啊啊

```c++
#include<iostream>
using namespace std;
int n;

int ans;
int match[1000] = { 6,2,5,5,4,5,6,3,7,6 };
int arr[4];
void dfs(int x,int sum) {
	if (sum > n) return;//剪枝 
	if (x > 3) {
		if (sum == n && arr[1] + arr[2] == arr[3])  ans++;
		return;
		
	}

	for (int i = 0; i < 1000; i++) {
		arr[x] = i;	
		dfs(x + 1,sum+match[i]);
	}


}
int main() {
	cin >> n;
	n -= 4;
	for (int i = 10; i <1000; i++) {
		match[i] = match[i % 10] + match[i / 10];
	}
	dfs(1,0);
	cout << ans;

	return 0;

}
```



### 洛谷p2036

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int n;
bool tl = false;
int difference = INT32_MAX;

int arr[11];
int brr[11];
int choosea[11];
int chooseb[11];

void dfs(int x) {
    if (x > n) {
        int sour = 1, ku = 0;
        for (int i = 1; i <= n; i++) {       
            if (choosea[i] == 1 && chooseb[i] == 1) {
                tl = true;
                sour *= arr[i];
                ku += brr[i];
            }
        }
        if (tl==true) {
            int d = abs(sour - ku);
            difference = min(d, difference);
            tl = false;
        }

        return;

    }

    choosea[x] = 1;
    chooseb[x] = 1;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

    choosea[x] = 2;
    chooseb[x] = 2;
    dfs(x + 1);
    choosea[x] = 0;
    chooseb[x] = 0;

}


int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &arr[i], &brr[i]);
    }
    dfs(1);
    cout << difference;
    return 0;
}
```



### 洛谷p1135

dfs超时，我请问呢，非要卡一个数据呜呜呜

```c++
#include<iostream>
using namespace std;
int N,A,B;
int arr[210];
int res=1e9;
bool st[210];//设置状态
//剪枝，当每层楼只去过一次，是最好的状态
//x代表当前层数，cnt表示按按钮的次数
void dfs(int x,int cnt){
    if(cnt>=res){
        //剪枝
        return ;
    }
    
    if(x<0||x>N) return ;
    if(x==B){
        res=min(res,cnt);
        return;
    }
    
    //bfs的精髓就是暴力搜索
    //所以当x+arr[x]<n的时候都可以进行搜索你
    if(arr[x]+x<=N&&!st[x+arr[x]]){
        st[x+arr[x]]=true;
        dfs(x+arr[x],cnt+1);
        st[x+arr[x]]=false;
    }
    
    if(x-arr[x]>0){
         st[x-arr[x]]=true;
        dfs(x-arr[x],cnt+1);
        st[x-arr[x]]=false;
    }
    
}
int main(){
    cin>>N>>A>>B;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
    }
    
    dfs(A,0);
    if(res==1e9) 
    {cout<<"-1";
    return 0;
    }
    cout<<res;

    return 0;
}

```



### 力扣257二叉树的所有路径

```c++
//使用了深度优先搜索
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string>paths;
        func(root,"",paths);
        return paths;
    }
    void func(TreeNode*root,string path,vector<string>&paths){//这里root没有用引用是因为root不需要修改
        if(root!=nullptr){
            path+=to_string(root->val);
            if(root->left==nullptr&&root->right==nullptr){
                paths.push_back(path);
            }
            else{
                path+="->";
                func(root->left,path,paths);//这里path没有用引用是因为path每次都是+=，构造了一个新的字符串插入到paths中
                func(root->right,path,paths);
            }
        }
    }
};
```



### p1135奇怪的电梯

深度优先搜索的指数型枚举模型，只有上下和未确定三种状态

别人写的dfs

```c++
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k[201],dis[201];
void dfs(int node,int step){
	dis[node]=step;//一定可以更新
	int v=node-k[node];
	if(1<=v&&step+1<dis[v]/*可以更新在搜索*/)//下
		dfs(v,step+1);
	v=node+k[node];
	if(v<=n&&step+1<dis[v])//上
		dfs(v,step+1);
	return;
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
		cin>>k[i];
	dfs(a,0);
	cout<<(dis[b]==0x3f3f3f3f?-1:dis[b]);
	return 0;
}==
```



```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 210;
int a[N];    //每层楼至多走一次为次数最少
int start, end1, n;
bool find1 = false;
int st[N];
int res=1e9;
void dfs(int i, int sum)
{
    if (sum < 1 ||sum > n||i>=res) return;
    else if (sum == end1)
    {
        find1 = true;
        res=min(res,i);
        return;
    }
    else{ 
        if(st[sum]>i||st[sum]==0) 
        {
            st[sum]=i;
            dfs(i + 1, sum + a[sum]);   //电梯上行 
            dfs(i + 1, sum - a[sum]);//电梯下行
        }
        else return;
    }
}
int main()
{
    scanf("%d %d %d", &n, &start, &end1);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    dfs(0, start);
    if (!find1) printf("-1");
    else printf("%d",res);
    return 0;
}
```



### 力扣980不同路径III

dfs解题关键：回溯

# 迷宫模型

1. **状态表示**：首先需要定义迷宫的状态表示。常见的方法是使用二维数组，其中0表示可通行的路径，1表示墙壁或不可通行的区域。同时需要一个起点和终点表示入口和出口的位置。
2. **递归搜索**：从起点开始，按照上、下、左、右四个方向进行递归搜索。每次移动到一个新位置时，都会检查是否到达了终点。如果没有到达终点，则继续从当前位置进行搜索。
3. **回溯条件**：在搜索过程中，如果遇到死路或者已经访问过的位置，就需要进行回溯。这时会返回到前一个位置，尝试其他方向的路径。
4. **记录路径**：为了避免重复走同一条路径，需要记录已经访问过的位置。一种常见的做法是用2来标记已经走过的可通行路径。
5. **求解方法**：除了回溯法，还可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等其他图搜索算法来解决迷宫问题。每种方法都有其优缺点，例如DFS加回溯可能不会直接找到最短路径，而BFS可以找到最短路径，但需要记录更多的节点信息。

### dfs求解迷宫最短路径问题

```c++
#include<iostream>
#include<queue>
#include<vector>
using namespace std;


const int N = 110;
int map[N][N];
bool st[N][N];
int row, colum, endx, endy;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,-1,0,1 };
int res = INT_MAX;
void dfs(int x, int y,int step) {
    //x y代表当前坐标
    if (x == endx && y == endy) {
        res = min(res, step);
        return;
    }

    for (int i = 0; i < 4; i++) {
        int la = x + dx[i];
        int lb = y + dy[i];
        if (st[la][lb] == 1) continue;
        if (la<1 || lb<1 || la>row || lb>colum) continue;
        if (map[la][lb] == 1) continue;
        st[la][lb] = 1;
        dfs(la, lb, step + 1);
        st[la][lb] = 0;
    }
}
int main() {
  
    cin >> row >> colum;
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            cin >> map[i][j];
        }
    }

    endx = row;
    endy = colum;
    st[1][1] = 1;
    dfs(1, 1,0);
    cout << res;
    return 0;
}

```

### dfs加记忆化递归迷宫问题

```c++

```



### bfs求解迷宫最短路径

1. **定义迷宫的大小和状态：** 定义迷宫的大小并确定迷宫中每个位置的状态，如墙壁、可通行路径等。
2. **定义坐标结构体和方向数组：** 定义一个结构体来表示迷宫中每个位置的坐标，同时定义一个方向数组，用来指示每个位置可以移动的方向，如上、右、下、左。
3. **编写合法性检查函数：** 编写一个函数来检查给定的坐标是否合法，即是否在迷宫的范围内且对应的状态为可通行路径。其中有：越界检查，地图检查是否已经访问过，地图检查是否是障碍物，是否是终点检查，如果是终点就要返回。

4. **使用队列进行广度优先搜索：**
   - 创建一个队列，用于保存待探索的位置。
   - 将迷宫的起始位置加入队列中。
   - 进入循环，直到队列为空或者找到了终点。
   - 在每次循环中执行以下操作：
     - 从队列中取出一个位置，即队头的元素，作为当前探索的位置。
     - 判断当前位置是否为终点位置，如果是，则搜索结束，算法成功找到了通向终点的路径，结束循环。
     - 将当前位置标记为已访问过的状态，以避免重复访问。
     - 探索当前位置周围的所有相邻位置，并将未访问过的相邻位置加入队列中。
   - 重复执行以上步骤，直到队列为空（表示没有通向终点的路径）或者找到了终点。
5. **记录路径信息（可选）：** 如果需要记录路径信息，可以在找到终点后进行回溯，从终点开始，根据已经记录的父节点信息逆向回溯到起点，即可得到具体的路径信息。
6. **返回搜索结果：** 如果队列为空，则说明没有找到通向终点的路径，搜索失败；如果找到了终点，则搜索成功，算法结束。

```c++

#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
typedef pair<int, int> PII;

const int N = 110;
char map[N][N];
bool st[N][N];
PII parent[N][N]; // 记录每个点的父节点坐标
int row, colum, endx, endy;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,-1,0,1 };

void bfs(int x, int y) {
    queue<PII> q;
    q.push({ x,y });
    st[x][y] = true;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == endx && t.second == endy) return; // 找到终点直接返回
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a < 1 || a > row || b < 1 || b > colum) continue;
            if (st[a][b] || map[a][b] == '1') continue;
            st[a][b] = true;
            parent[a][b] = t;//该拓展点的父节点是t
            q.push({ a,b });
        }
    }
}

int main() {
    cout << "请输入迷宫的行和列" << endl;
    cin >> row >> colum;
    cout << "请输入迷宫的终点坐标" << endl;
    cin >> endx >> endy;
    cout << "请输入迷宫，其中1表示障碍物，0表示可行" << endl;
    for (int i = 1; i <= row; i++) {
        scanf("%s", map[i] + 1);
    }
    bfs(1, 1);

    if (!st[endx][endy]) {//没有解的话，就没有走过终点，则终点状态为false
        cout << "没有解！" << endl;
        return 0;
    }

    vector<PII> path;
    PII cur = { endx, endy };
    while (cur.first != 0 && cur.second != 0) { // 从终点回溯到起点
        path.push_back(cur);
        cur = parent[cur.first][cur.second];
    }
    reverse(path.begin(), path.end()); // 反转路径，得到从起点到终点的最短路径

    cout << "最短路径为：" << endl;
    for (auto p : path) {
        cout << '(' << p.first << ',' << p.second << ')' << "->";
    }
    cout << '(' << endx << ',' << endy << ')' << endl; // 打印终点

    return 0;
}

```



### 洛谷p1683迷宫模型



```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
const int N = 30;
int W, H;
char map[N][N];
int st[N][N];//记录状态
int res;
int mx[4] = { -1,0,1,0 };
int my[4] = { 0,1,0,-1 };
void dfs(int x, int y) {
    for (int i = 0; i < 4; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx > H || ly < 0 || ly >=W) continue;
        if (st[lx][ly]) continue;
        if (map[lx][ly] != '.')continue;
        st[lx][ly] = 1;
        res++;
        dfs(lx,ly);        
    }
}

int main() {
    int x, y;
    scanf("%d %d", &W, &H);
    for (int i = 0; i < H; i++) {
        scanf("%s", map[i]);
    }
    for (int i = 0; i < H; i++) {
        for (int j = 0; j < W; j++) {
            if (map[i][j] == '@') {
               
                st[i][j] = 1;
                dfs(i, j);
                break;
            }
        }
    }

    printf("%d", ++res);
    return 0;
}
```

### 洛谷p1596洪水填充模型

八连通指的是可以走斜线，好暴力的做法...所以dfs只能用于一些数据较少的地方吧

```c++
#include<iostream>
#include<string>
using namespace std;
const int n = 100;
int N, M;
int mx[] = { 1,1,1,0,0,-1,-1,-1 };
int my[] = { -1,0,1,1,-1,1,0,-1 };
bool st[n][n];
string s[n];
int res;
void dfs(int x, int y) {

    for (int i = 0; i < 8; i++) {
        int lx = x + mx[i];
        int ly = y + my[i];
        if (lx < 0 || lx >= N || ly < 0 || ly >= M) continue;
        if (s[lx][ly] != 'W') continue;
        if (st[lx][ly]) continue;
        st[lx][ly] = true;
        dfs(lx, ly);//不需要回溯，洪水模型，覆水难收
    }

}
int main() {
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> s[i];
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (s[i][j] == 'W' && !st[i][j]) {
                //找到了第一个w
                s[i][j]=true;
                dfs(i, j);
                res++;
            }
        }
    }
    cout << res;
    return 0;
}

```



### ACW1114棋盘问题

对于本题，我们自然想到的是遇到一个可以放棋子的位置，放棋子，然后到其他行并且其他列的地方去找第二个可以放棋子的位置。



```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 10;
int n,k,cnt;
bool st[N];
int res;
string arr[N];//记录答案的数组
void dfs(int x,int cnt) {
    if(cnt==k){
        res++;
        return;
    }
    
    if(x>n) return;
    for (int i = 0; i <n; i++) {
        if(!st[i]&&arr[x][i]=='#'){//这里的i表示列！！
            st[i]=true;
            dfs(x+1,cnt+1);
            st[i]=false;
        }
    }
    
    dfs(x+1,cnt);
}
int main() {
    while( cin >> n>>k,n>0&&k>0){
        for(int i=1;i<=n;i++){
            cin>>arr[i];
        }
        res=0;//注意这里，因为是多组样例输出，所以res要更新
        dfs(1,0);
        cout<<res<<endl;
    }

    return 0;
}

```



### 洛谷p1019

1. 设置一个记录单词使用次数的数组，以便判断单词的使用次数是否大于2
2. 设置一个数组来记录单词之间的可拼接的最短长度，当时是最短拼接长度，每次取重合最短的，可以使单词最长
3. 当开始找到龙的时候，开始暴力搜索

```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 20;
int n;
string arr[N];
int used[N];//每个数组使用的次数
int cnt[N][N];//单词i与单词j的可拼接的长度
int ans;
void dfs(string s, int x) {
    ans = max(int(s.size()), ans);
    used[x]++;//当前单词使用次数加一
    for (int i = 0; i < n; i++) {
        if (cnt[x][i] && used[i] < 2) {//判断条件，如果两个单词之间可以拼接并且这个单词没有使用两次以上
            dfs(s + arr[i].substr(cnt[x][i]), i);
        }
    }

    used[x]--;//回溯，因为要找出最长距离
}
int main() {
    char start;

    cin >> n;
    string dargon;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    cin >> start;//龙头

    //预处理
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            string a = arr[i], b = arr[j];
            for (int k = 1; k < min(a.size(), b.size()); k++) {//注意这里，k必须从1开始取
                //找到一个单词的后缀和另一个单词的前缀相同
                if (a.substr(a.size() - k, k) == b.substr(0, k)) {
                    //第一个找到的一定是最短的，因为默认最短长度是1并且递增
                    cnt[i][j] = k;
                    break;
                }
            }

        }
    }

    for (int i = 0; i < n; i++) {
        if (arr[i][0] == start) {
            dfs(arr[i], i);//分别是龙和当前访问到了哪个单词
        }
    }
    cout << ans;
    return 0;
}
```



### 洛谷p1025

```c++
#include<iostream>
#include<string>
using namespace std;
int n, k;
int res;
int numsum;
int arr[210];
//组合型，但是下一次开始枚举可以是1
void dfs(int x, int start, int numsum) {
    if (x > k) {
        if (numsum == n) {
            res++;     
        }
          return;
    }


    for (int i = start;numsum+i*(k-x+1)<=n; i++) {//因为之后划分的一定大于等于i，如果剩下的位数
        //全是i的话还大于n，一定不符合情况
        //枚举k个数字
        arr[x] = i;
        dfs(x + 1, i, numsum+i);
        arr[x] = 0;
    }
}
int main() {
    cin >> n >> k;
    dfs(1, 1, 0);//从1,1开始枚举
    cout << res;
    return 0;
}

```

### 洛谷P1162

深度优先和广度优先结合哦

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<string>
using namespace std;
typedef  pair<int, int> PII;
queue<PII> q;
const int n = 35;
int N;
int mx[] = { 0,1,0,-1 };
int my[] = { 1,0,-1,0 };
bool st[n][n];//状态数组
int map[n][n];//地图
bool bfs(int x, int y) {
    q.push({ x,y });
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t.first == 1 || t.second == 1 || t.first == N || t.second == N) {
            //到达边界
            return true;//可达
        }
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b] == 1) continue;
            if (st[a][b]) continue;
            //不存在越界问题
            st[a][b] = true;
            q.push({ a,b });
        }
    }
    return false;
}

void dfs(int x, int y) {
        for (int i = 0; i < 4; i++) {
            int a = x + mx[i], b = y + my[i];
            if (map[a][b]==2||map[a][b]==1) continue;
            if (a < 2 || b < 2 || a >= N || b >= N) continue;
            //if (st[a][b]) continue;
            //不存在越界问题
            //st[a][b] = true;
            map[a][b] = 2;
            dfs(a, b);
        }
}
int main() {
    cin >> N;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            scanf("%d", &map[i][j]);
        }
        
    }

    bool flag = false;
    for (int i = 1; i <= N; i++) {
        if (flag == true) break;
        for (int j = 1; j <= N; j++) {
            if (map[i][j] == 0 && i != 1 && i != N && j != 1 && j != N) {
                bool res=bfs(i, j);
               
                if (!res)
                {
                    map[i][j] = 2;
                    dfs(i, j);
                    flag = true;
                    break;
                }
                
            }
        }
    }

    cout << endl;
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            cout << map[i][j] << ' ';
        }
        cout << endl;
         
    }
    return 0;
}



```





# 广度优先

### [云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/sa0zary9)



### 洛谷p2658汽车拉力赛

二分查找+bfs

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
int high[510][510];
int flag[510][510];
bool st[510][510];
typedef pair<int, int>PII;
int x, y;
int row, colum;
int flag_cnt = 0;
PII q[510 * 510];//bfs的队列
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
bool check(int mid) {
    q[0] = { x,y };//入队
    int cnt = 1;
    int hh = 0, tt = 0;
    st[x][y]=true;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i];
            if (a<1 || a>row || b<1 || b>colum) continue;
            if (st[a][b]) continue;
            if (abs(high[a][b] - high[t.first][t.second]) > mid) continue;
            st[a][b] = true;
            q[++tt] = { a,b };
            if (flag[a][b] == 1) {
                cnt++;
                  if (cnt == flag_cnt) return true;   
            }         
        }
    }
    return false;
}

int main() {
    cin >> row >> colum;
    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &high[i][j]);
        }
    }

    for (int i = 1; i <= row; i++) {
        for (int j = 1; j <= colum; j++) {
            scanf("%d", &flag[i][j]);
            
            if (flag[i][j] == 1) {
                flag_cnt++;
                x = i, y = j;
            }
        }
    }

    int l = -1, r = 10000000010;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        memset(q, 0, sizeof q);
        memset(st, false, sizeof st);
        if (check(mid)) r = mid;
        else l = mid;
    }
    cout << r;

    return 0;

}



```

### 洛谷p4554双端队列解决

模拟可知，我们每次都想走费用为零的路，即每次都优先把费用为零的节点入队

```c++
#include<iostream>
#include<deque>
#include<cstring>
using namespace std;
typedef pair<int,int> PII;
int n,m,x1,y1,x2,y2;
string map[510];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
deque<PII>q;
int dis[510][510];
int bfs(int x,int y){
    //入队起点
    q.push_back({x,y});
    dis[x][y]=0;//设置起点距离起点的距离是零
    while(!q.empty()){
        auto t=q.front();//获取当前队头元素
        q.pop_front();//每次优先访问费用为零的节点
        char ch=map[t.first][t.second];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(dis[a][b]>=0) continue;
           
            if(map[a][b]==ch){
                q.push_front({a,b});
                dis[a][b]=dis[t.first][t.second];
            }
            if(map[a][b]!=ch){
                q.push_back({a,b});
                dis[a][b]=dis[t.first][t.second]+1;
            }
          
            if(a==x2&&b==y2) return dis[a][b];
        }
    }
  return -1;
}
int main(){
    while(cin>>n>>m,n||m){//逗号运算符，会执行两个操作数，并返回最后一个操作数的结果作为返回值
        for(int i=0;i<n;i++){
            cin>>map[i];
        }
        
        //每次遍历都需要重新设置距离为没有访问过
        memset(dis,-1,sizeof dis);
        q.clear();
        cin>>x1>>y1>>x2>>y2;
        int res=bfs(x1,y1);
        cout<<res<<endl;
    }
    return 0;
}
```

### p1746离开中山路

```c++
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int,int>PII;
PII q[1010*1010];
char map[1010][1010];
int dis[1010][1010];
int vis[1010][1010];
int mx[]={-1,0,1,0};
int my[]={0,1,0,-1};
int n,x1,y1,x2,y2;
int bfs(){
    memset(dis,-1,sizeof dis);
    memset(vis,-1,sizeof vis);
    q[0]={x1,y1};
    q[1]={x2,y2};
    dis[x1][y1]=0;
    dis[x2][y2]=0;
    vis[x1][y1]=1;
    vis[x2][y2]=2;
    int hh=0,tt=1;
    while(hh<=tt){
        auto t=q[hh++];
        for(int i=0;i<4;i++){
            int a=t.first+mx[i],b=t.second+my[i];
            if(a<1||a>n||b<1||b>n) continue;
            if(map[a][b]=='1') continue;
            if(vis[a][b]+vis[t.first][t.second]==3){
                return dis[a][b]+dis[t.first][t.second]+1;
            }
            if(dis[a][b]>0) continue;
            dis[a][b]=dis[t.first][t.second]+1;
            if(vis[a][b]==-1){
                vis[a][b]=vis[t.first][t.second];
            }
            q[++tt]={a,b};//这里使得队列是交替插入起点和终点的节点的
        }
    }
    return -1;
    
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%s",map[i]+1);
    }
    scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    int res=bfs();
    cout<<res;
    return 0;
}
```



### 洛谷p1379八数码难题

```c++
#include<iostream>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//记录走到该状态需要多少步
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    dist[start] = 0;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        if (t == end1) return dist[t];
        int distance = dist[t];
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//状态压缩,转化为矩阵的下标
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//每次交换上下左右四个位置
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//越界
            int tmp = x2 * 3 + y2;//又转化为字符串下标
            swap(t[a], t[tmp]);//在字符串中将这两个位置互换
            if (!dist.count(t)) {//如果这个字符串没有试过
                dist[t] = distance + 1;//试一试嘛
                q.push(t);
            }
            swap(t[a], t[tmp]);//回溯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    int res = bfs(start);
    cout << res;
    return 0;

}
```



双向队列优化代码

```c++


#include<iostream>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
#include<unordered_map>
using namespace std;
int mx[] = { -1,0,1,0 };
int my[] = { 0,1,0,-1 };
unordered_map<string, int>dist;//记录走到该状态需要多少步
unordered_map<string,int>vis;
queue<string>q;
string end1 = "123804765";
int bfs(string start) {
    q.push(start);
    q.push(end1);
    dist[start] = 0;
    dist[end1]=0;
    vis[start]=1;
    vis[end1]=2;
    
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        int flag=vis[t];//记录当前节点的标记
        int distance = dist[t];//记录当前节点到起点或终点的距离
        
        int a = t.find('0');
        int x1 = a / 3, y1 = a % 3;//状态压缩,转化为矩阵的下标
       
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + mx[i], y2 = y1 + my[i];//每次交换上下左右四个位置
            if (x2 < 0 || x2 >= 3 || y2 < 0 || y2 >= 3) continue;//越界
            int tmp = x2 * 3 + y2;//又转化为字符串下标
            swap(t[a], t[tmp]);//现在的t是拓展的t
            
            if (vis[t]+flag==3){//如果当前节点和拓展节点相遇
                int res1=dist[t];
                swap(t[a],t[tmp]);
                int res2=dist[t];
                return res1+res2+1;
            }
            
            if (!dist.count(t)) {//如果这个字符串没有试过
                dist[t] = distance + 1;//试一试嘛
                vis[t]=flag;
                q.push(t);
            }
   
            swap(t[a], t[tmp]);//回溯
        }
    }
    return -1;

}
int main() {
    string start;
    cin >> start;
    if(start==end1){
        cout<<0;
        return 0;
    }
    int res = bfs(start);
    cout << res;
    return 0;

}
```

###   p2730魔板

```c++
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<string>
#include<unordered_map>
using namespace std;
unordered_map<string, int>dist;//走到当前状态需要几步
unordered_map<string, pair<char, string>>pre;
queue<string>q;
char arr[2][4];

void to_arr(string s) {
    for (int i = 0; i < 8; i++) {
        if (i < 4) {
            arr[0][i] = s[i];
        }
        else arr[1][7-i] = s[i];
    }
}

string To_string() {
    string res;
    for (int i = 0; i < 4; i++) {
        res += arr[0][i];
    }
    for (int i = 3; i >= 0; i--) {
        res += arr[1][i];
    }
    return res;
}

//交换上下两行
string move0(string s) {
    to_arr(s);
    for (int i = 0; i < 4; i++) {
        swap(arr[0][i], arr[1][i]);
    }
    return To_string();
}

//将最右边的一列插入最左边
string move1(string s) {
    to_arr(s);
    int a = arr[0][3], b = arr[1][3];
    for (int i = 3; i >= 1; i--) {
        for (int j = 0; j < 2; j++) {
            arr[j][i] = arr[j][i - 1];
        }
    }
    arr[0][0] = a;
    arr[1][0] = b;
    return To_string();
}

string move2(string s) {
    to_arr(s);
    int a = arr[0][2];
    arr[0][2] = arr[0][1];
    arr[0][1] = arr[1][1];
    arr[1][1] = arr[1][2];
    arr[1][2] = a;
    return To_string();
}



int bfs(string start, string end) {
    q.push(start);
    dist[start] = 0;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        if (t == end) return dist[end];
        string m[3];
        m[0] = move0(t);
        m[1] = move1(t);
        m[2] = move2(t);
        for (int i = 0; i<3; i++) {
            string s = m[i];
            if (!dist.count(s)) {
                dist[s] = dist[t] + 1;
                pre[s] = {i + 'A',t};
                if (s == end) return dist[end];
                q.push(s);
            } 
           
        }
    }
    return -1;
}
int main() {
    int x;

    string end;
    string start;
    for (int i = 0; i < 8; i++) {
        cin >> x;
        start += char(x + '0');
        end += char(i + 1 + '0');
    }

    int res = bfs(start, end);
    cout << res << endl;
    string res2;
    while (end != start) {
        res2 += pre[end].first;
        end = pre[end].second;
    }
    reverse(res2.begin(), res2.end());
    if (res2.size()) {
        cout << res2;
    }
    return 0;
}

```

### p1443马的遍历

bfs有很多种形式啦

```c++
#include<iostream>//P1443
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};//8个方向
queue<pair<int,int> > q;
int f[500][500];//存步数
bool vis[500][500];//走没走过
int main()
{
	int n,m,x,y;
	memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
	cin>>n>>m>>x>>y;
	f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
	while(!q.empty())
	{
		int xx=q.front().first,yy=q.front().second;q.pop();//取队首并出队
		for(int i=0;i<8;i++)
		{
			int u=xx+dx[i],v=yy+dy[i];
			if(u<1||u>n||v<1||v>m||vis[u][v])continue;//出界或走过就不走
		    vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
		}
	}
	for(int i=1;i<=n;i++)
	 {for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);printf("\n");}//注意场宽！！
	return 0;
}
```



### 力扣p1747好奇怪的游戏

遍历了所有的情况，唯独没有想到是数据范围出问题了，牢弟，我想把地球一拳锤爆

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int, int> PII;

int vis[25][25];
int dis[25][25];//及记录距离
int mx[] = { -2,-2,-1,1,2,2,2,2,1,-1,-2,-1 };
int my[] = { -1,-2,-2,-2,-2,-1,1,2,2,2,2,1 };

int bfs(int x, int y) {
    if (x == 1 && y == 2 || x == 2 && y == 1) return 2;
    //终点和起点都是已知的，双向队列
    memset(dis, -1, sizeof dis);
    memset(vis, -1, sizeof vis);
    PII q[25 * 25];//定义列表

    q[0] = { x,y };
    q[1] = { 1,1 };
    dis[x][y] = 0;
    dis[1][1] = 0;
    vis[x][y] = 1;
    vis[1][1] = 2;
    int hh = 0, tt = 1;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 12; i++) {
            int a = t.first + mx[i], b = t.second + my[i];
            if (a<=1 || a>21 || b<=1 || b>21) continue;
          
            if (vis[a][b] + vis[t.first][t.second] == 3) {
                return dis[a][b] + dis[t.first][t.second] + 1;
            }
            if (dis[a][b] > 0) continue;
            dis[a][b] = dis[t.first][t.second] + 1;
            if (vis[a][b] == -1) vis[a][b] = vis[t.first][t.second];
            q[++tt] = { a,b };
        }
    }
    return -1;
}


int main() {
    int x1, y1, x2, y2;
    scanf("%d %d", &x1, &y1);
    scanf("%d %d", &x2, &y2);
    int res1 = bfs(x1, y1);
    int res2 = bfs(x2, y2);
    cout << res1 << endl;
    cout << res2 << endl;
    return 0;

}
```



### 力扣p2385

我求求你了，数据开大一点吧，要不然你又以为是哪个地方写错了然后改半天小丑！











# 图

### 133克隆图

题解1深度优先搜索，题解已经写的很清楚了一个无向图实际在代码中如何存储：

![image-20240506194705392](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240506194705392.png)

题解2广搜，还是要模拟一下才可以！！

### 最短路径问题

狄克斯特拉算法，书上给的算法会超时，使用优先队列

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <climits> // for INT_MAX
using namespace std;

int N, M;

void Dijkstra(vector<vector<pair<int, int>>>& adj, vector<long long>& res, vector<int>& ver) // Dijkstra algorithm
{
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    vector<int> s(N + 1, 0); // S[i] = 1 indicates vertex i is in S, S[i] = 0 indicates vertex i is in U

    res[1] = ver[1]; // Initialize the distance to the source vertex
    pq.push({ res[1], 1 });

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        if (s[u]) continue;
        s[u] = 1;

        for (auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (!s[v] && res[u] + weight + ver[v] < res[v]) {
                res[v] = res[u] + weight + ver[v];
                pq.push({ res[v], v });
            }
        }
    }
}

int main() {
    int a, b, c;
    cin >> N >> M;
    vector<int> ver(N + 1);
    vector<long long> res(N + 1, LLONG_MAX);
    res[1] = 0;

    for (int i = 1; i <= N; i++) {
        cin >> ver[i];
    }

    vector<vector<pair<int, int>>> adj(N + 1); // Adjacency list representation

    for (int i = 0; i < M; i++) {
        cin >> a >> b >> c;
        adj[a].push_back({ b, c });
        adj[b].push_back({ a, c }); // If the graph is undirected
    }

    Dijkstra(adj, res, ver);

    for (int i = 2; i <= N; i++) {
        if (res[i] == LLONG_MAX)
            cout << -1 << " "; // If there's no path to the node, output -1
        else
            cout << res[i] << " ";
    }
    cout << endl;

    return 0;
}

```



# 模拟题

### 花生采摘

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2. 从一棵植株跳到前后左右与之相邻的另一棵植株；
3. 采摘一棵植株下的花生；
4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。



输入格式

第一行包括三个整数，𝑀,𝑁*M*,*N*和𝐾*K*，用空格隔开；表示花生田的大小为𝑀×𝑁(1≤𝑀,𝑁≤20)*M*×*N*(1≤*M*,*N*≤20)，多多采花生的限定时间为𝐾(0≤𝐾≤1000)*K*(0≤*K*≤1000)个单位时间。接下来的𝑀*M*行，每行包括𝑁*N*个非负整数，也用空格隔开；第𝑖+1*i*+1行的第𝑗*j*个整数𝑃𝑖𝑗(0≤𝑃𝑖𝑗≤500)*P**ij*(0≤*P**ij*≤500)表示花生田里植株(𝑖,𝑗)(*i*,*j*)下花生的数目，00表示该植株下没有花生。

输出格式

一个整数，即在限定时间内，多多最多可以采到花生的个数。

样例 #1

```none
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
//输出37
```

我讨厌模拟题啊啊啊啊啊

**找到所有花生植株**：首先需要找到所有有花生的植株，并按花生数量从多到少排序。

**模拟采摘过程**：从第一行跳到有花生的植株，按照花生数量从多到少的顺序移动，记录总时间和采摘的花生数量，直到时间耗尽。

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;
int dx[4] = {-1,0,1,0};
int dy[4] = {0,1,0,-1};
struct peanut {
    int row;
    int col;
    int num;
};

bool com(const peanut& a, const peanut& b) {
    return a.num > b.num;
}
int main() {
    int n, m, k;
    cin >> n >> m >> k;
    vector<peanut>peanut_nums;
    vector<vector<int>>map(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> map[i][j];
            if (map[i][j] != 0) peanut_nums.push_back({ i,j,map[i][j] });
        }
    }

    sort(peanut_nums.begin(), peanut_nums.end(), com);
    int current_row=-1;
    int current_col = -1;
    int timeused = 0;
    int total = 0;


    for (auto p : peanut_nums) {
        int row = p.row;
        int col = p.col;
        if (current_col == -1 && current_row == -1) {
            timeused += row + 1;
        }

        else timeused += abs(current_row - row) + abs(current_col - col);

        timeused += 1;//采摘花费的一秒

        if (timeused + row + 1 > k) break;
        total += p.num;
        current_col = col;
        current_row = row; 
    }
    cout << total;
    return 0;
}

```

### 纪念品分组

贪心加模拟，我讨厌模拟啊啊啊啊

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。

你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

输入格式

共 𝑛+2 行： 第一行包括一个整数 w，为每组纪念品价格之和的上限。 第二行为一个整数 𝑛，表示购来的纪念品的总件数 𝐺。 第 3∼*n*+2 行每行包含一个正整数 𝑃𝑖 表示所对应纪念品的价格。

输出格式

一个整数，即最少的分组数目。

```none
100 
9 
90 
20 
20 
30 
50 
60 
70 
80 
90
//输出6
```

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;

int main() {
    int sum, n;
    cin >> sum >> n;
    vector<int>arr(n, 0);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    auto print = [](int element) {
        cout << element << " ";
        };
    sort(arr.begin(), arr.end());
    int len = arr.size();
    int cnt = 0;
    for (int i = 0, j = len-1; i <= j; ) {
        if (arr[j] + arr[i] > sum) {
            cnt++;
            j--;
        }
        else {
            cnt++;
            i++;
            j--;
        }
    }

    cout << cnt;
    return 0;
}

```

### 寻宝

![image-20240717163455656](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240717163455656.png)

![image-20240717163512260](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240717163512260.png)

```
//输入：
2 3
1 2
0 3
1 4
0 1
1 5
1 2
1
//输出
5
```



对于本题来说，最难的就是如何找到第x个有楼梯的房间

下次再遇到这种问题，你需要画图，一般这种都是一个圆形，一般都需要使用取模运算

比如本题的 a = (a + 1 + m) % m;  // 逆时针方向移动,逆时针顺序，a的趋势是增加的

但是我们对代码进行了优化，因为题目的x的值可能很大，如果很大的话，会超时

所以先得到所有能够直接上楼的房间数量，再取模运算

```c++
#include <iostream>
#include <vector>
#include <string>
#include<algorithm>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    int current_door;
    vector<vector<int>>arr(n * m, vector<int>(2, 0));
    for (int i = 0; i < n * m; i++) {
        cin >> arr[i][0] >> arr[i][1];
    }
    cin >> current_door;
    int current_stair = 1;
    int sum = 0;
    while (current_stair <= n) {
        int temp1 = arr[(current_stair - 1) * m + current_door][0];
        int temp2 = arr[(current_stair - 1) * m + current_door][1];
        if (temp1 == 1) {
            sum = (sum + temp2) % 20123;
            current_stair++;
        }

        else {
            sum = (sum + temp2) % 20123;
            int cnts = 0;
            for (int i = 0; i < m; i++) {
                if (arr[i][0]) cnts++;
            }

            int a = (temp2 % cnts)+current_door;

            //while (cnt < temp2) {
            //    a = (a + 1 + m) % m;  // 逆时针方向移动
            //    if (arr[(current_stair - 1) * m + a][0] == 1) {
            //        cnt++;
            //    }
            //}
            current_door = a;  // 找到第 temp2 个有楼梯的房间
            current_stair++;
        }
    }

    cout << sum;
    return 0;
}

```





### 力扣100297

# 分治思想

### 求棋盘覆盖问题

```
#include <iostream>
#include <cstring> // 引入 memset

int tile = 1;        // 骨牌序号
int board[128][128]; // 二维数组模拟棋盘

void chessBoard(int tr, int tc, int dr, int dc, int size)
{
	if (size == 1)
		return;
	int s = size / 2; // 分割棋盘
	int t = tile++;   // t记录本层骨牌序号

	if (dr < tr + s && dc < tc + s)
	{
		chessBoard(tr, tc, dr, dc, s);
	}
	else
	{
		board[tr + s - 1][tc + s - 1] = t;
		chessBoard(tr, tc, tr + s - 1, tc + s - 1, s);
	}

	if (dr < tr + s && dc >= tc + s)
	{
		chessBoard(tr, tc + s, dr, dc, s);
	}
	else
	{
		board[tr + s - 1][tc + s] = t;
		chessBoard(tr, tc + s, tr + s - 1, tc + s, s);
	}

	if (dr >= tr + s && dc < tc + s)
	{
		chessBoard(tr + s, tc, dr, dc, s);
	}
	else
	{
		board[tr + s][tc + s - 1] = t;
		chessBoard(tr + s, tc, tr + s, tc + s - 1, s);
	}

	if (dr >= tr + s && dc >= tc + s)
	{
		chessBoard(tr + s, tc + s, dr, dc, s);
	}
	else
	{
		board[tr + s][tc + s] = t;
		chessBoard(tr + s, tc + s, tr + s, tc + s, s);
	}
}

int main()
{
	int boardSize, specialRow, specialCol;

	// 用户输入棋盘大小
	std::cout << "请输入棋盘大小 (2^k): ";
	std::cin >> boardSize;

	// 用户输入特殊方块位置
	std::cout << "请输入特殊方块的位置 (行 列): ";
	std::cin >> specialRow >> specialCol;

	// 初始化棋盘
	memset(board, 0, sizeof(board));

	chessBoard(0, 0, specialRow, specialCol, boardSize);

	// 打印棋盘
	for (int i = 0; i < boardSize; i++)
	{
		for (int j = 0; j < boardSize; j++)
		{
			std::cout << board[i][j] << "\t";
		}
		std::cout << "\n\n";
	}
	return 0;
}

```

### 分治法的快速排序求中位数

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

double getKth(vector<int>& a, int s1, int t1, vector<int>& b, int s2, int t2, int k) {
	if (s1 > t1) return b[s2 + k - 1]; // a数组为空
	if (s2 > t2) return a[s1 + k - 1]; // b数组为空
	if (k == 1) return min(a[s1], b[s2]); // 只需要返回较小的元素

	int m1 = (s1 + t1) < (s1 + k / 2 - 1) ? (s1 + t1) : (s1 + k / 2 - 1);
	int m2 = (s2 + t2) < (s2 + k / 2 - 1) ? (s2 + t2) : (s2 + k / 2 - 1);

	if (a[m1] < b[m2]) {
		return getKth(a, m1 + 1, t1, b, s2, t2, k - (m1 - s1 + 1)); // a数组取后半段
	}
	else {
		return getKth(a, s1, t1, b, m2 + 1, t2, k - (m2 - s2 + 1)); // b数组取后半段
	}
}

double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
	int total = a.size() + b.size();
	if (total % 2 == 1) {
		return getKth(a, 0, a.size() - 1, b, 0, b.size() - 1, total / 2 + 1);
	}
	else {
		double left = getKth(a, 0, a.size() - 1, b, 0, b.size() - 1, total / 2);
		double right = getKth(a, 0, a.size() - 1, b, 0, b.size() - 1, total / 2 + 1);
		return (left + right) / 2.0;
	}
}

int main() {
	int n1, n2;
	cout << "请输入数组a、数组b的长度n1、n2: ";
	cin >> n1 >> n2;
	vector<int> a(n1), b(n2);

	cout << "请输入a数组的数据: ";
	for (int i = 0; i < n1; i++) cin >> a[i];
	cout << "请输入b数组的数据: ";
	for (int i = 0; i < n2; i++) cin >> b[i];

	double median = findMedianSortedArrays(a, b);
	cout << "中位数是: " << median << endl;

	return 0;
}
```

# 常用算法

## 并查集

```c++
#include <iostream>
#include <vector>

using namespace std;

class DisjointSet {
private:
    vector<int> parent;

public:
    DisjointSet(int size) {
        parent.resize(size);
        for (int i = 0; i < size; ++i) {
            parent[i] = i; // 初始时每个元素的父节点是自己
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    void unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY; // 合并两个集合
        }
    }
};

int main() {
    DisjointSet ds(5);

    ds.unionSet(0, 1);
    ds.unionSet(2, 3);
    ds.unionSet(0, 4);

    cout << ds.find(3) << endl; // 输出 2，表示节点 3 和节点 2 在同一个集合中

    return 0;
}

```



## 二分查找

### [【算法1-6】二分查找与二分答案 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/training/111#problems)

### 基础二分

【How to avoid pitfalls in Binary Search?】https://www.bilibili.com/video/BV1EW4y1C7vA?vd_source=afced950d3df908879a570bbf5db28f2



```c++
#include <iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
bool is_blue(int num, int x) {
	//具体条件
	if (num <= 5) return true;
	else return false;
}
int main() {
	//假设我要找数组中第一个大于五的数的下标
	int arr[10] = {0};
	for (int i = 0; i < 10; i++) {
		cin >> arr[i];
	}
	int l = -1;
	int r = sizeof(arr) / sizeof(arr[0]);
	int mid;
	while (l + 1 != r) {//判定条件，l+=r说明已经遍历了整个数组
		mid = (l + r) / 2;
		if (is_blue(arr[mid], 5)) l = mid;
		else r = mid;
	}
	cout << r;
	return 0;
}
```



### 二分求立方根

//输入一个数，求它的立方根，要求使用高效的算法，结果保留六位小数

需要注意的是，保留六位小数，则精度要留到1e-8

```c++
#include <iostream>
#include<vector>
using namespace std;

const double EPS = 1e-8;
bool check(double num, double n) {
	return num * num * num - n<EPS;
}
int main() {
	double n;
	cin >> n;
	double l = -100, r = 100;
	double mid;
	for (int i = 0; i < 50; i++) {
		mid = (r + l) / 2;
		if (check(mid, n)) l = mid;
		else r = mid;
	}
	printf("%6lf", l);

	return 0;
}
```

### 洛谷p3853

![image-20240315200520439](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200520439.png)

```c++
/*
对于任意一个给出的“空旷指数”G，我们应该怎样去判断它是否符合题目的意思呢？

我们可以想象，我们已知了这条路上的所有的路标，我们从头开始枚举两两相邻的路标的间距，如果大于G,那么已经不符合G为最大距离的条件了，为了使G满足,我们就可以在前一个路标前面G米处加一个路标，这样与前面一个就符合条件了，再判断新设的路标和后面的路标是否距离小于G,如果不，继续重复操作设置新路标

当新设的路标数已经超过题目所给最大增设值时，如果还有路标不满足G,但已经不能设置新路标了，所以该G值就不满足条件。相反，则G成立。

注意到，如果一个“空旷指数”成立，那么可能存在比它更小的解，但如果一个“空旷指数”不成立，那么答案只能比该值更大*/

//我是如此开心我能接触到如此美妙的算法
#include<iostream>
using namespace std;
int L,N,K;
int arr[100010],s[100010];
bool check(int x){
    int cnt=0;
    for(int i=1;i<=N;i++){
        if(s[i]>x){
            cnt++;
            int num=s[i]-x;
            while(num>x){
                cnt++;
                num-=x;
            }
        }
    }
    
    return cnt<=K;
}


int main(){
    cin>>L>>N>>K;
    int highest=0;
    
    for(int i=1;i<=N;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
        s[i]=arr[i]-arr[i-1];
    }
    
    arr[N+1]=L;
    s[N+1]=arr[N+1]-arr[N];
    int l=0,r=L+1;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    if(check(l)) cout<<l;
    else cout<<r;
    return 0;
}
```



### **最小值最大模型**

![image-20240315200512608](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240315200512608.png)

#### **洛谷p1873**

```c++
#include<iostream>
using namespace std;
int n,m;
int arr[1000010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=max(0,arr[i]-x);
        if(sum>=m) return true;
    }
    return false;
   
  
}
int main(){
    cin>>n>>m;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
  
    else cout<<l;
    return 0;
}
```



#### **洛谷p2440**

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,k;
int arr[100010];
bool check(int x){
    int sum=0;
    for(int i=1;i<=n;i++){
        sum+=arr[i]/x;
        if(sum>=k) return true;
    }
    return false;
}

int main(){
    cin>>n>>k;
    int highest=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&arr[i]);
        highest=max(arr[i],highest);
    }
    int l=0,r=highest;
    int mid;
    while(l+1!=r){
        mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    if(check(r)) cout<<r;
    else cout<<l;
    
    return 0;
}
```



#### **洛谷p2678跳石头**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
int L, N, M;
int arr[50010];

bool check(int x) {
    int cnt = 0;//记录移动石头的次数
    int i = 0, now = 0;//i代表的是当前的石头，i<N+1的原因是我们不能把终点搬走
    while (i < N + 1) {
        i++;
        if (arr[i] - arr[now] < x) cnt++;
        else now = i;
    }
    return cnt <= M;

}
//算法思路
//每次都把最小距离移走，并且随着移动的次数变大，最小跳跃距离是在变大的
//二分，假设中间的值是答案，那么按照比这个答案小的石头一定会被移走，并且移走的石头一定是M个
//所以二分的判断条件就是，移走的石头的个数是不是M，如果大于M，就说明不是答案
//如果我们假设的条件符合，我们还要检查比它小的地方是不是有答案

int main() {
    cin >> L >> N >> M;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &arr[i]);
    }
    arr[N + 1] = L;  //相当于终点 
    int l = 0, r = L + 1;//边界条件
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;//这个是我们假设的答案
        if (check(mid)) l = mid;
        else r = mid;
    }

    if (check(r)) cout << r;
    else cout << l;

}
```

#### ACWing1236递增三元组

需要注意的地方：1.注意数据的数量级，两个10的五次方相乘，得到的是10的十次方，超过int的最大值，所以要开long long

第二个就是**当程序出问题时，如果确信自己的逻辑是，没问题的，就要重新检查一遍，因为很有可能是因为一些小细节出错而不是逻辑出错**

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
int N;
int a[100010];
int b[100010];
int c[100010];
bool check1(int num, int x) {
    return num < x;
}

bool check2(int num, int x) {
    return num <= x;
}
int func1(int num) {
    //找数组中最后一个小于num的下标
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check1(a[mid], num)) l = mid;
        else r = mid;
    }
    return l;

}
int func2(int num) {
    //找数组中第一个大于num的下标
    int l = 0, r = N + 1, mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check2(c[mid], num)) l = mid;
        else r = mid;
    }
    return r;

}
int main() {
    cin >> N;
    LL res = 0;
    for (int i = 1; i <= N; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &b[i]);
    }
    for (int i = 1; i <= N; i++) {
        scanf("%d", &c[i]);
    }

    //二分法
    sort(a+1, a + N+1);
    sort(b+1, b + N+1);
    sort(c+1, c + N+1);
    for (int i = 1; i <= N; i++) {
        LL x = func1(b[i]);
        LL y = func2(b[i]);
        res += (x * (N - y + 1));
    }
    cout << res;
    return 0;
}
```

### 变种二分

#### 力扣33搜索旋转排序数组

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

```

### 数的位置

![image-20240719160307338](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719160307338.png)



```c++
#include <iostream>
#include <vector>

using namespace std;

bool func2(vector<int>& arr, int mid, int x) {
    return arr[mid] < x;
}

bool func3(vector<int>& arr, int mid, int x) {
    return arr[mid] <= x;
}

pair<int, int> func1(vector<int>& arr, int x) {
    int n = arr.size();
    int l1 = -1, r1 = n;
    int l2 = -1, r2 = n;
    int mid;

    // 找起始位置
    while (l1 + 1 != r1) {
        mid = (l1 + r1) / 2;
        if (func2(arr, mid, x)) l1 = mid;
        else r1 = mid;
    }

    // 确保 r1 不越界并且 arr[r1] == x
    if (r1 >= n || arr[r1] != x) r1 = -1;

    // 找终止位置
    while (l2 + 1 != r2) {
        mid = (l2 + r2) / 2;
        if (func3(arr, mid, x)) l2 = mid;
        else r2 = mid;
    }

    // 确保 l2 不越界并且 arr[l2] == x
    if (l2 < 0 || arr[l2] != x) l2 = -1;

    return { r1, l2 };
}

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    for (int i = 0; i < q; i++) {
        int k;
        cin >> k;
        pair<int, int> p = func1(arr, k);
        cout << p.first << " " << p.second << endl;
    }

    return 0;
}

```



## 双指针

[双指针算法-CSDN博客](https://blog.csdn.net/qq_54773252/article/details/122836179?ops_request_misc=%7B%22request%5Fid%22%3A%22171059884416800226527499%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=171059884416800226527499&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122836179-null-null.142^v99^pc_search_result_base1&utm_term=双指针算法&spm=1018.2226.3001.4187)

双指针主要有两种：快慢指针和对撞指针

### 力扣16最接近的三数之和

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        //双指针
        int n=nums.size();
        sort(nums.begin(),nums.end());
        int best=1e7;
        auto update=[&](int cur){
            if(abs(cur-target)<abs(best-target)){
                best=cur;
            }
        };

        for(int i=0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]) continue;//不计算重复情况
            

            //使用双指针
            int j=i+1,k=n-1;
            while(j<k){
                int sum=nums[i]+nums[j]+nums[k];
                if(sum==target) return target;
                update(sum);
                if(sum>target){
                    int k0=k-1;
                    while(j<k0&&nums[k0]==nums[k]) k0--;
                    k=k0;
                }
                else{
                    int j0=j+1;
                    while(j0<k&&nums[j0]==nums[j]) j0++;
                    j=j0;
                }
        }
    }
    return best;

    }
};
```

### 力扣15三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};


```



### 18四数之和

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> quadruplets;
        if (nums.size() < 4) {
            return quadruplets;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        for (int i = 0; i < length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
            for (int j = i + 1; j < length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                int left = j + 1, right = length - 1;
                while (left < right) {
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
};


```



### 洛谷p1102

我们考虑题目要求求出所有`A-B=C`的数对，我们可以先将原数组排序，然后就会发现每个数A，对应的数B一定是一段连续的区间。

然后我们再考虑如何去找到这个区间。

我们显然是要找到这个连续区间的左端点和右端点。

考虑到排序之后序列的有序性，我们枚举每个数，他们的左端点和右端点都是**单调不降**的，因此我们可以用two-pointers，也就是双指针来维护这个东西。

![image-20240316225049443](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240316225049443.png)

代码很简洁。

```c++
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 2e5 + 10;
int n , c;
int a[N];

int main () 
{
	cin >> n >> c;
	for(int i = 1 ; i <= n ; i ++) cin >> a[i];
	sort(a + 1 , a + 1 + n);
	int l = 1, r1 = 1 , r2 = 1;
	ll ans = 0;
	for(l = 1 ; l <= n ; l ++) {
		while(r1 <= n && a[r1] - a[l] <= c) r1 ++;
		while(r2 <= n && a[r2] - a[l] < c ) r2 ++;
		if(a[r2] - a[l] == c && a[r1 - 1] - a[l] == c && r1 - 1 >= 1) 	
			ans += r1 - r2;
	}
	cout << ans;
	return 0;
}
```



### 力扣27移除元素

soooooooeasy!!!!

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int le=nums.size();
        int i=0,j=0;
        while(i<le){
            if(nums[i]==val) j++;
            else nums[i-j]=nums[i];
            i++;
        }
        nums.resize(le-j);
        return le-j;


    }
};
```



### 力扣11盛最多水的容器

由题意可知，容器的高度是由短板决定的，假设初始容器的短板和长版分别在两端

如果向内移动短板，短板的长度有可能变大，虽然容器的宽度变小了，但是仍然可能使得容器的体积变大

如果移动长板，则容器的体积一定变小

由此可知只要在每次移动中移动短板，在判断体积是否变大即可

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int le = height.size();
        int r1 = 0, r2 = le - 1;//短板长板
        int res = 0;
        while(r1<r2){
            if(height[r1]<height[r2]){
                res=max(res,min(height[r1],height[r2])*(r2-r1));
                r1++;
            }
            else{
                 res=max(res,min(height[r1],height[r2])*(r2-r1));
                r2--;
            }
        }
        return res;
    }
};
```

### ACWing1236递增三元组

```c++
//满足条件A-B<0  B-C<0
//枚举B，所以假设每次B的值都是固定的，我们知道Ai的值是最后一个小于B的值，那么Ai之前的值都是小于B的，同理，最后一个小于B的Ci之后的所有元素都是大于B的
//所以我们需要找到这些数

```



```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long LL;
const int N = 1e5+10;
int num[3][N];

int main() {
    int n;
    scanf("%d", &n);
    for(int i = 0; i < 3; ++i) 
        for(int j = 1; j <= n; ++j) 
            scanf("%d", &num[i][j]);
    for(int i = 0; i < 3; ++i)
        sort(num[i]+1, num[i]+n+1);

    LL ans = 0;
    //枚举B，寻找A满足的个数以及C满足的个数相乘
    int a = 1, c = 1;
    for(int i = 1; i <= n; ++i) {
        int key = num[1][i];
        while(a<=n && num[0][a] < key) a++;
        while(c<=n && num[2][c] <= key) c++;

        ans += (LL)(a-1)*(n-c+1);

    }
    cout<<ans<<endl;
    return 0;
}

```



### 力扣80

双指针

## 滑动窗口

判断窗口是否满足

剔除冗余元素

#### 3力扣无重复字符的最长字串

我们使用两个指针维护最长不重复子串，

我们知道，r0-rk之间的字符串是不重复的，则r1-rk之间的字串也是不重复的，这是该题解的基础

当出现重复字符的时候，出列最左边，此时r1-rk一定是不重复的啦

```c++
//滑动窗口
//unordered_set
class Solution {
public:

    int lengthOfLongestSubstring(string s) {
        unordered_set<char>occ;
        int n=s.size();
        int rk=-1,ans=0;//一般滑动数组都用-1作为开始
        for(int i=0;i<n;i++){
            if(i!=0){
                occ.erase(s[i-1]);
            }
            while(rk+1<n&&!occ.count(s[rk+1])){
                occ.insert(s[rk+1]);
                ++rk;
            }
            ans=max(ans,rk-i+1);
        }
        return ans;

    }
};
```

#### 最长连续不重复子序列

定义一个数组来记录每个元素上一次在数组中出现的位置。

我们需要遍历数组的每一个元素，对于当前元素，如果当前元素对应的值上一次出现的位置，就是那个记录位置数组对应的值在最长连续不重复子序列的范围内，说明上次已经有一个这样的元素出现了，则需要更新最长连续不重复子序列，start的位置应该是当前元素的位置

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int>arr(n, 0);
    vector<int>record(100001, -1);
    for (int i = 0; i < n; i++) cin >> arr[i];
    int start = 0, end = 0;
    int max_len = INT_MIN;
    for (; end < n; end++) {
        if (record[arr[end]] >= start) {
            //这个意思是arr[end]上次出现的位置在start之后，说明元素重复
            start = record[arr[end]] + 1;
        }
        
        record[arr[end]] = end;
        max_len = max(max_len, end - start + 1);
        
    }


    return 0;
}

```



### 不太甜的糖果

给你一个数组和一个值m,求最短连续子串之和大于等于m

```c++
//输入
10 15 
5 1 3 5 10 7 4 9 2 8 
//输出
2
//解释：5 10或者10 7
```

```c++
#include <iostream>
#include <vector>
#include <algorithm> 
#include <climits> 

using namespace std;

bool check(vector<int>& prefix_sum, int mid, int target) {
    return prefix_sum[mid] < target;
}
int binary_search(vector<int>& prefix_sum, int low,int high,int target) {
    int l = low-1, r = high+1;
    int mid;
    while (l + 1 != r) {
        mid = (l + r) / 2;
        if (check(prefix_sum, mid, target)) l = mid;
        else r = mid;
    }

    if (r!=high+1) return r;
    else return -1;

}
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> sweetness(n+1,0);
    int min_Len = INT_MAX;

    for (int i = 1; i <= n; i++) {
        cin >> sweetness[i];
    }

    vector<int>prefix_sum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + sweetness[i];
    }

    for (int i = 1; i <= n; i++) {
        int target = prefix_sum[i] + m;
        int index = binary_search(prefix_sum, i,n,target);
        if(index!=-1) min_Len = min(min_Len, index - i);
        
    }

    if (min_Len != INT_MAX) cout << min_Len;

    return 0;
}
```

### 力扣27删除顺序表所有值为x的元素

要求时间复杂度为O（n），空间复杂度为O（1）

快慢指针

快指针找到数组中需要更新的数据

满指针找到需要更新的位置

```c++
//整体建表
void func1(vector<int>& arr, int x) {
	int n = arr.size();
	int k = 0;
	for (int i = 0; i < n; i++) {
		if (arr[i] != x) {
			arr[k] = arr[i];
			k++;
		}		
	}

	arr.resize(k);
}

//元素移动法
void func2(vector<int>& arr, int x) {
	int i = 0;
	int n = arr.size();
	int k = 0;
	while (i < n) {
		if (arr[i] == x) {
			k++;
		}
		else {
			arr[i - k] = arr[i];
		}

		i++;
	}

	arr.resize(n - k);
}
```



### 把数组中奇数放到偶数的前面

```c++
//区间划分法
void func(vector<int>& arr) {
	int i = -1;
	int j = 0;
	int n = arr.size();
	for (j; j < n; j++) {
		if (arr[j] % 2 == 1) {
			i++;
			if (i != j) {
				swap(arr[i], arr[j]);
			}
		}
		
	}
	
}
```



### 力扣26删除有序数组的重复项

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n=nums.size();
        if(n==1) return n;
        int fast=1;
        int slow=0;
        while(fast<n){
           if(nums[fast]==nums[slow]) fast++;
           else{
            slow++;
            nums[slow]=nums[fast];
            fast++;
           }
        }

        return slow+1;

        
    }
};
```

### 判断子序列



给定一个长度为 𝑛*n* 的整数序列 𝑎1,𝑎2,…,𝑎𝑛以及一个长度为 𝑚*m* 的整数序列 𝑏1,𝑏2,…,𝑏𝑚。请你判断 𝑎序列是否为 𝑏序列的子序列。子序列指序列的一部分项按**原有次序排列**而得的序列，例如序列 𝑎1,𝑎3,𝑎5是序列 𝑎1,𝑎2,𝑎3,𝑎4,𝑎5的一个子序列。



第一行包含两个整数 𝑛,𝑚。 第二行包含 𝑛个整数，表示 𝑎1,𝑎2,…,𝑎𝑛。 第三行包含 𝑚个整数，表示 𝑏1,𝑏2,…,𝑏𝑚。



如果 𝑎 序列是 𝑏 序列的子序列，输出一行 `Yes`。 否则，输出 `No`。



利用单调性

```c++
#include <iostream>
#include <vector>
#include<climits>

using namespace std;

int main() {
    int n, m,target;
    cin >> n >> m>>target;
    vector<int>text(n, 0);
    vector<int>pattern(m, 0);
    for (int i = 0; i < n; i++) cin >> text[i];
    for (int i = 0; i < m; i++) cin >> pattern[i];
    int i = 0, j = m - 1;
    while (i < n && m >= 0) {
        if (text[i] + pattern[j] > target) j--;
        else if (text[i] + pattern[j] < target) i++;
        else {
            cout << i << " " << j;
            break;
        }
    }

    return 0;
}

```



## KMP

### kmp1

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
class Solution {
public:
	//如何高效的看出前缀和后缀是否相等
	vector<int>Arry(string pattern)
	{
		int index = 0;
		vector<int> arry(pattern.size(), 0);
		//我们从第一个和第二个字符开始比较，所以index=0,i=1
		//index表示元素下标，并且总是指向最小相同前缀的末端，刚开始匹配没有最小前缀，所以index=0
		for (int i = 1; i < pattern.size();)
		{
			//如果pattern==index,说明出现了最小前缀
			if (pattern[i] == pattern[index])
			{
					
				arry[i] = index + 1;
				index++;
				i++;
			}

			else
			{
				//如果他们的值不一样，说明截止到下标pattern[i]元素出现了不一样的元素
				if (index != 0)
				{
					//回溯到对应数组的值所代表的那一个字符
					index = arry[index - 1];
				}
				else
				{
					//这里的前提是pattern[i]!=pattern[index],并且index=0,说明目前的最小前缀是0
					arry[i] = 0;
					i++;
				}
			}
		}
		return arry;

	}

	int KMP(string text, string pattern)
	{
		vector<int>arry = Arry(pattern);
		int i = 0, j = 0;
		int k = 0;
		while (i < text.size() && j < pattern.size())
		{
			k++;
			if (text[i] == pattern[j])
			{
				i++;
				j++;
			}
			else
			{
				if (j != 0)
				{
					//此时要进行回溯
					//如果j的值不等于零，就把模式串指针移动到arry数组指向的那个最长相同前缀那里
					j = arry[j - 1];
				}
				else
				{
					//如果是零就直接重新遍历模式串
					i++;
				}
			}
		}
		cout << k;
		if (j == pattern.size())
		{
			return i - pattern.size();
		}
		else
		{
			return -1;
		}
	}
	
};

//对于字符串abcabcabc,返回的数组是0 0 0 1 2 3 4 5 6
//前缀函数：字符串最长的相等的真前缀和真后缀的长度
//该算法求的字符串前i（包括i）的子串的前缀函数
vector<int> prefix_function(string s) {
	int n = (int)s.length();
	vector<int> pi(n);
	for (int i = 1; i < n; i++) {
		int j = pi[i - 1];
		while (j > 0 && s[i] != s[j]) j = pi[j - 1];
		if (s[i] == s[j]) j++;
		pi[i] = j;
	}
	return pi;
}

//该算法会找到字符串中所有匹配子串的下标，牛牛牛！！！
vector<int> find_occurrences(string text, string pattern) {
	string cur = pattern + '#' + text;
	int sz1 = text.size(), sz2 = pattern.size();
	vector<int> v;
	vector<int> lps = prefix_function(cur);
	for (int i = sz2 + 1; i <= sz1 + sz2; i++) {
		if (lps[i] == sz2) v.push_back(i - 2 * sz2);
	}
	return v;
}


int main() {
	string text = "abcabcabc";
	string pattern = "abc";
	vector<int>v = find_occurrences(text, pattern);
	for (auto i : v) cout << i << ' ';
	

}



```

### kmp2

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
const int MaxSize = 100;
void getnext(string pattern,int next[]) {
	int n = pattern.size();
	int i = 0, j = -1;
	next[0] = -1;
	while (i < n-1) {
		if (j == -1 || pattern[i] == pattern[j]) {
			i++;
			j++;
			next[i] = j;
		}
		else j = next[j];//j回退
	}	
}

void getnextval(string pattern, int nextval[]) {
	int i = 0, j = -1;
	int n = pattern.size();
	nextval[0] = -1;
	while (i < n - 1) {
		if (j == -1 || pattern[i] == pattern[j]) {
			i++;
			j++;
			if (pattern[i] != pattern[j]) nextval[i] = j;
			else nextval[i] = nextval[j];
		}
		else j = nextval[j];
	}
}

int KMP2(string text, string pattern) {
	int l1 = text.size(), l2 = pattern.size();
	int next[MaxSize];
	getnext(pattern, next);
	int i = 0, j = 0;
	while (i < l1 && j < l2) {
		if (j == -1 || text[i] == pattern[j]) {
			i++;
			j++;
		}
		else j = next[j];
	}
	if (j >= l2) return i - l2;
	else return -1;
}

```



## 遍历顺序问题

```c++
//正序遍历：从上到下，从左到右
int main() {
    for (int i = 0; i <=10; i++) {
        for (int j = 0; j <=10; j++) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}

//倒叙遍历：从下到上，从左到右
int main() {
    for (int i = 10; i >=0; i--) {
        for (int j = 10; j >=0; j--) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}

//从上到下，正三角
int main() {
    for (int i = 0; i <=10; i++) {
        for (int j = 0; j <=i; j++) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}

//本遍历顺序用于（i，j）状态需要从(i+1,j+1)状态得到的时候
int main() {
    for (int i = 10; i >=0; i--) {
        for (int j = 10; j >=i; j--) {
            cout << "("<<i << "," << j <<")" << " ";
        }
        cout << endl;
    }
	return 0;
}
```

## 快速幂算法

https://www.bilibili.com/video/BV16Z4y1M7y1/?spm_id_from=333.337.search-card.all.click

快速幂算法用于计算幂预算，（当n很大的时候，朴素算法的时间复杂度为o(n),这个算法可以进行提速),原理就是把n转化成2的幂运算，再简化,时间复杂度为o(logn)



比如力扣第50道题要求手动搓出pow函数

需要知道的是快速幂对负数仍然适用



//注释，有时候看到自己写的一坨屎居然过了也会扶额苦笑

```c++
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};

```

## 高精度算法

### 高精度加法

高精度加法对比高精度减法简单了好多

1.处理进位问题，carry记录进位，最后要判断进位是否为0，如果不为零，还要加上进位

```c++
#include <iostream>
#include <string>
#include <algorithm>

// 高精度加法函数
std::string highPrecisionAdd(const std::string& num1, const std::string& num2) {
    int len1 = num1.size();
    int len2 = num2.size();
    int maxLength = std::max(len1, len2);

    std::string result;
    int carry = 0; // 进位

    // 从最低位开始逐位相加 
    for (int i = 0; i < maxLength; i++) {
        int digit1 = (i < len1) ? num1[len1 - 1 - i] - '0' : 0;
        int digit2 = (i < len2) ? num2[len2 - 1 - i] - '0' : 0;
        int sum = digit1 + digit2 + carry;
        carry = sum / 10;
        result.push_back(sum % 10 + '0');
    }

    // 最后处理进位
    if (carry) {
        result.push_back(carry + '0');
    }

    // 反转结果字符串
    std::reverse(result.begin(), result.end());

    return result;
}

int main() {
    std::string num1, num2;
    std::cout << "Enter the first large number: ";
    std::cin >> num1;
    std::cout << "Enter the second large number: ";
    std::cin >> num2;

    std::string result = highPrecisionAdd(num1, num2);
    std::cout << "Result of addition: " << result << std::endl;

    return 0;
}

```



### 高精度减法

高精度加法需要解决的问题：

1.如果两个数相等，直接返回0即可

2.如果两个数不等，如何让大的那个数放到前面，并处理负号的问题

3.如何处理借位问题，比如100借位

4.如何处理两个数的位数不一致问题

5.去除前导零

```c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// 字符串减法，用于高精度减法运算
string subtract(string& a, string& b) {
    // 确保 a >= b
    if (a == b) {
        return "0";
    }

    bool flag = false;
    if (a.size() < b.size()) {
        swap(a, b);
        flag = true;
    }

    else if (a.size() == b.size() && a < b) {
        swap(a, b);
        flag = true;
    }

    string result;
    int carry = 0;
    int lenA = a.size();
    int lenB = b.size();

    for (int i = 0; i < lenA; ++i) {
        int numA = a[lenA - 1 - i] - '0';
        int numB = i < lenB ? b[lenB - 1 - i] - '0' : 0;

        int temp = numA - numB - carry;

        if (temp < 0) {
            temp += 10;
            carry = 1;
        }
        else {
            carry = 0;
        }

        result.push_back(temp + '0');
    }
    
    

    // 去除结果中的前导零
    while (result.size() > 1 && result.back() == '0') {
        result.pop_back();
    }
    
    reverse(result.begin(), result.end());

    
    if (flag) result.insert(result.begin(), '-');
    return result;
}

int main() {
    string a, b;
    
    cin >> a;
    //cout << "Enter the subtrahend: ";
    cin >> b;
    cout << "Result: " << subtract(a, b) << endl;
    return 0;
}

```



### 高精度乘法

高精度乘法没有翻转字符串

使用vector数组存储每一位数字，最后记得转化成字符串即可

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string multiple(string a, string b) {
    int la = a.size(), lb = b.size();
    vector<int>result(la + lb, 0); 
    int sum = 0, num = 0;
    for (int i = la - 1; i >= 0; i--) {
        for (int j = lb - 1; j >= 0; j--) {
            num = (a[i] - '0') * (b[j] - '0');
            sum = num + result[i + j + 1];
            result[i + j + 1] = sum % 10;
            result[i + j] += sum / 10;
        }
    }


    string ans;
    int n = result.size();
    for (int i=0; i <n; i++) {
        if (!(ans.empty() && result[i] == 0)) {
            ans.push_back(result[i] + '0');
        }
    }

    return ans.empty() ? 0 : ans;
}
int main() {
    string a, b;
    cin >> a >> b;
    string ans = multiple(a, b);
    cout << ans;
    return 0;
}

```



### 高精度除法

1.高精度除以低精度（逐位试商） 

```c++
#include<iostream>
#include<string>
using namespace std;
string func(string a, string b) {
	long long y = stoll(b);
	int la = a.size();
	string c(la, '0');
	long long sum = 0, carry = 0;
	for (int i = 0; i < la; i++) {
		sum = (carry * 10 + a[i] - '0');
		c[i] = (sum / y)+'0';
		carry = sum % y;
	}

	int i = 0;
	while (c.size()>1&&c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



2.高精度除以高精度

以减法代替除法的运算

```c++
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string result;

	int na = a.size();
	int nb = b.size();

	int i;
	int carry = 0;

	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1]-'0';
		int numb = i < nb ? b[nb - i - 1]-'0' : 0;
		int temp = numa - numb - carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else carry = 0;

		result.push_back(temp + '0');
	}


	while (result.size() > 1 && result.back() == '0') {
		result.pop_back();
	}

	reverse(result.begin(), result.end());
	return result;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	string c;
	int cnt = 0;
	char ch;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			cnt++;
			a = func2(a, temp);
		}
		ch = cnt + '0';
		c += ch;
		cnt = 0;
	}

	//去除前导零
	int i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	return c;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```



### 高精度取模

1.高精度取模低精度

```c++
#include<iostream>
#include<string>
using namespace std;

int main() {
	string a, b;
	cin >> a >> b;
	a += b;
	int result = 0;
	int mod = 1000000007;
	for (auto i : a) {
		result = (result * 10 + (i - '0')) % mod;
	}

	cout << result;
}
```





2高精度取模高精度

```
#include<iostream>
#include<string>
using namespace std;
string func2(string a, string b) {
	string c;

	int na = a.size();
	int nb = b.size();

	int carry = 0;
	int i;
	for (i = 0; i < na; i++) {
		int numa = a[na - i - 1] - '0';
		int numb = i < nb ? b[nb - 1 - i] - '0' : 0;
		int temp = numa - numb-carry;
		if (temp < 0) {
			temp += 10;
			carry = 1;
		}
		else {
			carry = 0;
		}
		c.push_back(temp + '0');

	}

	reverse(c.begin(), c.end());
	i = 0;
	while (c.size() > 1 && c[i] == '0') c.erase(c.begin());
	
	return c;
}

bool issmaller(string x, string y) {
	int lx = x.size(), ly = y.size();
	if (lx < ly) return true;
	else if (lx == ly && x < y) return true;
	return false;
}
string func(string a, string b) {
	if (issmaller(a, b)) return a;
	int la = a.size(), lb = b.size();
	int lc = la - lb + 1;
	for (int i = lc; i > 0; i--) {
		string temp(i - 1, '0');
		temp = b + temp;
		while (!issmaller(a, temp)) {
			a = func2(a, temp);
		}
	}
	return a;
}
int main() {
	string a, b;
	cin >> a >> b;
	cout << func(a, b);

}
```

## 时间问题

### 24小时制转换为12小时制

```c++
#include <iostream>
#include <string>

using namespace std;

string convertTo12HourFormat(int hour) {
    if (hour <= 12) {
        return to_string(hour) + " AM";
    } else {
        return to_string(hour - 12) + " PM";
    }
}

int main() {
    int hour;
    cout << "Enter hour in 24-hour format: ";
    cin >> hour;

    cout << "Time in 12-hour format: " << convertTo12HourFormat(hour) << endl;

    return 0;
}

```

### 时间加减法

**时间加减法可以通过将时间转换为分钟数进行计算，然后再将结果转换回时间格式。**

给一个时间，求该时间提前45分钟的时间

```c++
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    int h, m;
    char colon;
    cin >> h >> colon >> m;

    // 计算当前时间总共的分钟数
    int totalMinutes = h * 60 + m;

    // 计算45分钟之前的时刻
    totalMinutes -= 45;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // 调整到前一天
    }

    // 计算新的小时和分钟
    int newHour = totalMinutes / 60;
    int newMinute = totalMinutes % 60;

    // 输出结果
    cout << newHour << ":" << newMinute / 10 << newMinute % 10 << endl;

    return 0;
}

```



### 时区转换



```c++
#include <iostream>

using namespace std;

// 将给定时间转换为UTC时间
void convertToUTC(int& hour, int& minute, int& offset) {
    // 计算UTC时间
    int totalMinutes = hour * 60 + minute - offset;
    if (totalMinutes < 0) {
        totalMinutes += 24 * 60;  // 调整到前一天
    }
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

// 将UTC时间转换为目标时区的时间
void convertToTimeZone(int& hour, int& minute, int& offset) {
    // 计算目标时区的时间
    int totalMinutes = hour * 60 + minute + offset;
    hour = totalMinutes / 60;
    minute = totalMinutes % 60;
}

int main() {
    int hour, minute, offset, targetOffset;
    cout << "Enter hour and minute: ";
    cin >> hour >> minute;
    cout << "Enter offset of current time zone: ";
    cin >> offset;
    cout << "Enter offset of target time zone: ";
    cin >> targetOffset;

    // 将给定时间转换为UTC时间
    convertToUTC(hour, minute, offset);

    // 将UTC时间转换为目标时区的时间
    convertToTimeZone(hour, minute, targetOffset);

    cout << "Time in target time zone: " << hour << ":" << minute << endl;

    return 0;
}

```



### 时间差

```c++
#include <iostream>

using namespace std;

// 将时间转换为分钟数
int timeToMinutes(int hour, int minute) {
    return hour * 60 + minute;
}

// 计算时间差
void calculateTimeDifference(int hour1, int minute1, int hour2, int minute2, int& diffHour, int& diffMinute) {
    // 将时间转换为分钟数
    int time1 = timeToMinutes(hour1, minute1);
    int time2 = timeToMinutes(hour2, minute2);

    // 计算差值
    int diffMinutes = time2 - time1;
    if (diffMinutes < 0) {
        diffMinutes += 24 * 60;  // 调整到前一天
    }

    // 将差值转换为小时和分钟
    diffHour = diffMinutes / 60;
    diffMinute = diffMinutes % 60;
}

int main() {
    int hour1, minute1, hour2, minute2;
    cout << "Enter first time (hour and minute): ";
    cin >> hour1 >> minute1;
    cout << "Enter second time (hour and minute): ";
    cin >> hour2 >> minute2;

    int diffHour, diffMinute;
    calculateTimeDifference(hour1, minute1, hour2, minute2, diffHour, diffMinute);

    cout << "Time difference: " << diffHour << " hours " << diffMinute << " minutes" << endl;

    return 0;
}

```

