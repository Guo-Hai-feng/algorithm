# 数据结构总览

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240617155750762.png" alt="image-20240617155750762" style="zoom:67%;" />



## 时间复杂度和空间复杂度

https://www.bilibili.com/video/BV13d4y1K74p/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e



int的最大值是2147483648,一般数据给10e9

c++一秒最多能执行的次数是10的8次方

阶乘级别的代码，数据最大给11

对于空间限制128MB,int数组最大3*10E7



![image-20240409202354645](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240409202354645.png)

# 线性表

## 存储密度

存储密度是指节点数据本身所占的存储量和整个节点结构中所占的存储量之比，即：

例如：链表：假设数据域占8个字节，指针域占4个字节，总共12字节。

存储密度=8/12=0.67

一般的：存储密度越大，存储空间的利用率就越高。顺序表的存储密度为1，而链表的存储密度小于一

## 栈

### 栈的性质

1. 栈是一种非常重要的数据结构之一，通常在将递归算法转化成非递归算法的时候需要使用栈

2. $$
   n个不同的元素通过一个栈产生的出栈序列的个数为 \frac{1}{n+1} *\binom{n}{2n}，例如n=4的时候，出栈序列的个数等于14
   $$

   

对于顺序栈：

栈空的条件：top=-1

栈慢的条件：top=MAXSIZE-1



### 代码实现

```c++
typedef struct
{
	ElemType data[MaxSize];
	int top;				//栈指针
} SqStack;	
//顺序栈类型
void InitStack(SqStack*& s)
{
	s = (SqStack*)malloc(sizeof(SqStack));
	s->top = -1;
}
void DestroyStack(SqStack*& s)
{
	free(s);
}
bool StackEmpty(SqStack* s)
{
	return(s->top == -1);
}
bool Push(SqStack*& s, ElemType e)
{
	if (s->top == MaxSize - 1)    //栈满的情况，即栈上溢出
		return false;
	s->top++;
	s->data[s->top] = e;
	return true;
}
bool Pop(SqStack*& s, ElemType& e)
{
	if (s->top == -1)		//栈为空的情况，即栈下溢出
		return false;
	e = s->data[s->top];
	s->top--;
	return true;
}
bool GetTop(SqStack* s, ElemType& e)
{
	if (s->top == -1) 		//栈为空的情况，即栈下溢出
		return false;
	e = s->data[s->top];
	return true;
}
```



### 括号匹配的检验

```c++
#include<stdio.h>

#define MaxSize 10

typedef struct {    // 定义顺序栈
    int data[MaxSize];  // 静态数组存放栈中元素
    int top;    // 栈顶指针：指向目前栈顶元素的位置
} SeqStack;

// 初始化
void InitStack(SeqStack &S) {
    // 初始化栈顶指针，由于在顺序栈中，0表示栈底部的位置
    // 所以初始应赋小于0的值，常用  -1
    S.top = -1;
}

// 判断栈空
bool StackEmpty(SeqStack S) {
    // 空栈条件：栈顶指针等于-1！！！
    // 说明栈中没有任何元素
    if(S.top == -1) {
        return true;
    } else {
        return false;
    }
}

// 进栈操作
// 类似于线性表的插入操作，即“增”操作
// 但由于栈的特殊性，只允许在栈顶进行操作，所以可称为进栈操作
// 即在栈顶增加元素
bool Push(SeqStack &S, char x) {
    // 判断栈是否已满，由于top是静态数组最后一个元素的下标（栈顶元素下标）
    // 所以只需要判断top值是否已经达到静态数组最大长度-1即可
    if(S.top == MaxSize - 1) {
        return false;
    }
    // top指针+1-->下标加一，指向数组后一位
    S.top = S.top + 1;
    // 新元素入栈
    S.data[S.top] = x;
    // 以上操作等价于S.data[++S.top] = x;
    return true;
}

// 出栈操作
// 类似于线性表的删除操作，即“删”操作
// 但由于栈的特殊性，只允许在栈顶进行操作，所以可称为出栈操作
// 即在栈顶弹出元素
bool Pop(SeqStack &S, char &x) {
    // 栈顶指针等于-1，栈为空，不可删除
    if(S.top == -1) {
        return false;
    }
    // 注意：虽然在此处出栈操作栈顶指针减一，可视为删除成功
    // 但实际上数据仍然保留在存储单元中，只是从逻辑上删除了
    // 将栈顶元素赋给x，x为引用变量，可从外部获取弹出的数据
    x = S.data[S.top];
    // 栈顶指针减一
    S.top = S.top - 1;
    // 以上操作等价于x= S.data[S.top--]
    return true;
}

// 算法实现——括号匹配
bool bracketCheck(char str[], int length) {
    SeqStack S;
    // 初始化栈
    InitStack(S);
    // 通过遍历从左往右扫描字符
    for(int i = 0;i < length;i++) {
        // 如果字符是左括号，则压入栈中
        if(str[i] == '(' || str[i] == '[' || str[i] == '{') {
            Push(S, str[i]);
        } else {
            // 如果不是左括号，且栈为空则表示匹配失败
            // 因为栈中即是压入的左括号，如果匹配到右括号时，栈中没有左括号与之匹配，自然就不合理，匹配失败
            if(StackEmpty(S)) {
                return false;
            }
            // 创建临时变量，用于存储栈中所弹出的字符，即左括号
            char topElem;
            // 弹出栈顶元素
            Pop(S, topElem);
            // 如果括号类型不匹配，则视为匹配失败
            if(str[i] == ')' && topElem != '(') {
                return false;
            }
            if(str[i] == ']' && topElem != '[') {
                return false;
            }
            if(str[i] == '}' && topElem != '{') {
                return false;
            }
        }
    }
    
    // 检索完所有括号后，还需检测栈是否为空，如果栈不为空，说明还有未匹配完成项，即匹配失败
    // 栈空则匹配成功
    
    return StackEmpty(S);
}

int main() {
    char a[] = "[([][])]";
    if(bracketCheck(a, 8)) {
        printf("The match is successful");
    }
}

```



### 利用栈求简单表达式的值



```c++
while(从exp读取字符 ch,ch!='\0'){
	ch为数字:将后续的所有数字均依次存放到postexp中,并以字符’标识数字串结束
	ch为左括号'(':将此括号进到Optr栈中;
	ch为右括号')':将Optr中出栈时遇到的第1个左括号'('以前的运算符依次出栈，存放到postexp中,然后将左括号'('出栈;
	ch为'+'或'-':出栈运算符并存放到postexp中,直到栈空或者栈顶为(然后进栈;
	ch为'*'或'/':出栈运算符并存放到postexp中,直到栈空或者栈顶为'(','+','-',然后将ch进栈;
	若exp遍历完毕,则将Optr中的所有运算符依次出栈并存放到postexp中
}
```





例如，中缀表达式 `3 + 4 * 5` 的逆波兰表达式是 `3 4 5 * +`。

在计算逆波兰表达式时，可以使用一个栈来辅助计算。遍历逆波兰表达式，当遇到操作数时，将其压入栈中；当遇到操作符时，弹出栈顶的两个操作数，进行相应的运算，然后将结果再次压入栈中。重复这个过程，直到整个表达式被处理完毕，栈顶即为最终结果。

例如，对于逆波兰表达式 `3 4 5 * +` 的计算过程：

1. 遇到 3，入栈 `[3]`。
2. 遇到 4，入栈 `[3, 4]`。
3. 遇到 5，入栈 `[3, 4, 5]`。
4. 遇到 *，弹出栈顶的两个元素 4 和 5，计算 4 * 5 = 20，将结果 20 入栈 `[3, 20]`。
5. 遇到 +，弹出栈顶的两个元素 3 和 20，计算 3 + 20 = 23，将结果 23 入栈`[23]`。
6. 遇到/，则需要注意，连续两次出栈元素a,b,计算的结果是b/a的值，所以要注意a的值是不是0

最终栈内只剩下一个元素 23，这就是逆波兰表达式的计算结果。

**逆波兰表达式的优点是不需要考虑运算符的优先级和括号的问题，计算过程相对简单。**

```c
//求简单表达式的值
#include <stdio.h>
#include <stdlib.h>
#define MaxSize 100
//---------------------------------------------------------
//--运算符栈基本运算---------------------------------------
//---------------------------------------------------------
typedef struct 
{	char data[MaxSize];			//存放运算符
	int top;					//栈顶指针
} SqStack;
void InitStack(SqStack *&s)		//初始化栈
{	s=(SqStack *)malloc(sizeof(SqStack));
	s->top=-1;
}
void DestroyStack(SqStack *&s)	//销毁栈
{
	free(s);
}
bool StackEmpty(SqStack *s)		//判断栈是否为空
{
	return(s->top==-1);
}
bool Push(SqStack *&s,char e)	//进栈元素e
{	if (s->top==MaxSize-1)
		return false;
	s->top++;
	s->data[s->top]=e;
	return true;
}
bool Pop(SqStack *&s,char &e)	//出栈元素e
{	if (s->top==-1)	
		return false;
	e=s->data[s->top];
	s->top--;
	return true;
}
bool GetTop(SqStack *s,char &e)	//取栈顶元素e
{	if (s->top==-1)	
		return false;
	e=s->data[s->top];
	return true;
}
//---------------------------------------------------------

void trans(char *exp,char postexp[])	//将算术表达式exp转换成后缀表达式postexp
{
	char e;
	SqStack *Optr;						//定义运算符栈
	InitStack(Optr);					//初始化运算符栈
	int i=0;							//i作为postexp的下标
	while (*exp!='\0')					//exp表达式未扫描完时循环
	{	switch(*exp)
		{
		case '(':						//判定为左括号
			Push(Optr,'(');				//左括号进栈
			exp++;						//继续扫描其他字符
			break;
		case ')':						//判定为右括号
			Pop(Optr,e);				//出栈元素e
			while (e!='(')				//不为'('时循环
			{
				postexp[i++]=e;			//将e存放到postexp中
				Pop(Optr,e);			//继续出栈元素e
			}
			exp++;						//继续扫描其他字符
			break;
		case '+':						//判定为加或减号
		case '-':
			while (!StackEmpty(Optr))	//栈不空循环
			{
				GetTop(Optr,e);			//取栈顶元素e
				if (e!='(')				//e不是'('
				{
					postexp[i++]=e;		//将e存放到postexp中
					Pop(Optr,e);		//出栈元素e
				}
				else					//e是'(时退出循环
					break;
			}
			Push(Optr,*exp);			//将'+'或'-'进栈
			exp++;						//继续扫描其他字符
			break;
		case '*':						//判定为'*'或'/'号
		case '/':
			while (!StackEmpty(Optr))	//栈不空循环
			{
				GetTop(Optr,e);			//取栈顶元素e
				if (e=='*' || e=='/')	//将栈顶'*'或'/'运算符出栈并存放到postexp中
				{
					postexp[i++]=e;		//将e存放到postexp中
					Pop(Optr,e);		//出栈元素e
				}
				else					//e为非'*'或'/'运算符时退出循环
					break;
			}
			Push(Optr,*exp);			//将'*'或'/'进栈
			exp++;						//继续扫描其他字符
			break;
		default:				//处理数字字符
			while (*exp>='0' && *exp<='9') //判定为数字
			{	postexp[i++]=*exp;
				exp++;
			}
			postexp[i++]='#';	//用#标识一个数值串结束
		}
	}
	while (!StackEmpty(Optr))	//此时exp扫描完毕,栈不空时循环
	{
		Pop(Optr,e);			//出栈元素e
		postexp[i++]=e;			//将e存放到postexp中
	}
	postexp[i]='\0';			//给postexp表达式添加结束标识
	DestroyStack(Optr);			//销毁栈		
}
//---------------------------------------------------------
//--操作数栈基本运算---------------------------------------
//---------------------------------------------------------
typedef struct 
{	double data[MaxSize];			//存放数值
	int top;						//栈顶指针
} SqStack1;
void InitStack1(SqStack1 *&s)		//初始化栈
{	s=(SqStack1 *)malloc(sizeof(SqStack1));
	s->top=-1;
}
void DestroyStack1(SqStack1 *&s)	//销毁栈
{
	free(s);
}
bool StackEmpty1(SqStack1 *s)		//判断栈是否为空
{
	return(s->top==-1);
}
bool Push1(SqStack1 *&s,double e)	//进栈元素e
{	if (s->top==MaxSize-1)
		return false;
	s->top++;
	s->data[s->top]=e;
	return true;
}
bool Pop1(SqStack1 *&s,double &e)	//出栈元素e
{	if (s->top==-1)	
		return false;
	e=s->data[s->top];
	s->top--;
	return true;
}
bool GetTop1(SqStack1 *s,double &e)	//取栈顶元素e
{	if (s->top==-1)	
		return false;
	e=s->data[s->top];
	return true;
}
//---------------------------------------------------------

double compvalue(char *postexp)	//计算后缀表达式的值
{
	double d,a,b,c,e;
	SqStack1 *Opnd;				//定义操作数栈
	InitStack1(Opnd);			//初始化操作数栈
	while (*postexp!='\0')		//postexp字符串未扫描完时循环
	{	
		switch (*postexp)
		{
		case '+':				//判定为'+'号
			Pop1(Opnd,a);		//出栈元素a
			Pop1(Opnd,b);		//出栈元素b
			c=b+a;				//计算c
			Push1(Opnd,c);		//将计算结果c进栈
			break;
		case '-':				//判定为'-'号
			Pop1(Opnd,a);		//出栈元素a
			Pop1(Opnd,b);		//出栈元素b
			c=b-a;				//计算c
			Push1(Opnd,c);		//将计算结果c进栈
			break;
		case '*':				//判定为'*'号
			Pop1(Opnd,a);		//出栈元素a
			Pop1(Opnd,b);		//出栈元素b
			c=b*a;				//计算c
			Push1(Opnd,c);		//将计算结果c进栈
			break;
		case '/':				//判定为'/'号
			Pop1(Opnd,a);		//出栈元素a
			Pop1(Opnd,b);		//出栈元素b
			if (a!=0)
			{
				c=b/a;			//计算c
				Push1(Opnd,c);	//将计算结果c进栈
				break;
			}
			else
		    {	
				printf("\n\t除零错误!\n");
				exit(0);		//异常退出
			}
			break;
		default:				//处理数字字符
			d=0;				//将连续的数字字符转换成对应的数值存放到d中
			while (*postexp>='0' && *postexp<='9')   //判定为数字字符
			{	
				d=10*d+*postexp-'0';  
				postexp++;
			}
			Push1(Opnd,d);		//将数值d进栈

			break;
		}
		postexp++;				//继续处理其他字符
	}
	GetTop1(Opnd,e);			//取栈顶元素e
	DestroyStack1(Opnd);		//销毁栈		
	return e;					//返回e
}
int main()
{
	char exp[]="(56-20)/(4+2)";
	char postexp[MaxSize];
	trans(exp,postexp);
	printf("中缀表达式:%s\n",exp);
	printf("后缀表达式:%s\n",postexp);
	printf("表达式的值:%g\n",compvalue(postexp));
	return 1;
}
```



## 队列

### 顺序队

#### 顺序队列

1. 初始化front=rear=-1
2. 队空条件：front=rear
3. 队满条件：rear=MAXSIZE-1
4. 元素e进队：rear++,data[rear]=e
5. 元素e出队：front++;e=data[front]



#### 循环队列：

初始化front=rear=0

队空条件：front=rear=0

队满条件：（rear+1）%MAXSIZE=front

进队e:rear=(rear+1)%MAXSIZE，data[rear]=e

出队e:front=(front+1)%MAXSIZE ,e=data[front]

队列元素个数：count=(rear-front+MAXSIZE)%MAXSIZE

### 链队

队空：l.front=l.rear=null

队满：没有

插入元素：1.队列为空l.front=l.rear=对应节点  2.不空：尾插

删除元素：1.队列为空，返回错误  2.队列只有一个元素l.front=l.rear=null  3.其他，头删

```c++
//链队运算算法
#include <stdio.h>
#include <malloc.h>
typedef char ElemType;
typedef struct DataNode
{	
	ElemType data;
	struct DataNode *next;
} DataNode;				//链队数据结点类型
typedef struct
{	
	DataNode *front;
	DataNode *rear;
} LinkQuNode;			//链队类型
void InitQueue(LinkQuNode *&q)
{	
	q=(LinkQuNode *)malloc(sizeof(LinkQuNode));
	q->front=q->rear=NULL;
}
void DestroyQueue(LinkQuNode *&q)
{
	DataNode *p=q->front,*r;//p指向队头数据结点
	if (p!=NULL)			//释放数据结点占用空间
	{	r=p->next;
		while (r!=NULL)
		{	free(p);
			p=r;r=p->next;
		}
	}
	free(p);
	free(q);				//释放链队结点占用空间
}
bool QueueEmpty(LinkQuNode *q)
{
	return(q->rear==NULL);
}
void enQueue(LinkQuNode *&q,ElemType e)
{	DataNode *p;
	p=(DataNode *)malloc(sizeof(DataNode));
	p->data=e;
	p->next=NULL;
	if (q->rear==NULL)		//若链队为空,则新结点是队首结点又是队尾结点
		q->front=q->rear=p;
	else
	{	q->rear->next=p;	//将p结点链到队尾,并将rear指向它
		q->rear=p;
	}
}
bool deQueue(LinkQuNode *&q,ElemType &e)
{	DataNode *t;
	if (q->rear==NULL)		//队列为空
		return false;
	t=q->front;				//t指向第一个数据结点
	if (q->front==q->rear)  //队列中只有一个结点时
		q->front=q->rear=NULL;
	else					//队列中有多个结点时
		q->front=q->front->next;
	e=t->data;
	free(t);
	return true;
}
```



### 求解报数问题

```c++
//顺序队列（环形队列）基本运算算法
#include <stdio.h>
#include <malloc.h>
#define MaxSize 100
typedef int ElemType;
typedef struct
{
	ElemType data[MaxSize];
	int front, rear;		//队首和队尾指针
} SqQueue;

void InitSqueue(SqQueue*& l) {
	l = (SqQueue*)malloc(sizeof(SqQueue));
	l->front = l->rear = 0;
}

bool enqueue(SqQueue*& l, ElemType &e) {
	if ((l->rear + 1) % MaxSize == l->front) return false;
	l->rear = (l->rear + 1) % MaxSize;
	l->data[l->rear] = e;
	return true;
}

bool dequeue(SqQueue*& l, ElemType &e) {
	if (l->front == l->rear) return false;
	l->front = (l->front + 1) % MaxSize;
	e = l->data[l->front];
	return true;
}

bool empty(SqQueue* &l) {
	return l->front == l->rear;
}

void func(int arr[],int n) {
	SqQueue* l;
	InitSqueue(l);
	for (int i = 0; i < n; i++)
		enqueue(l, arr[i]);
	int e;
	while (!empty(l)) {
		dequeue(l, e);
		printf("%d\t", e);
		if (!empty(l)) {
			dequeue(l, e);
			enqueue(l, e);
		}
	}
}
int main() {
	int arr[8] = { 1,2,3,4,5,6,7,8 };

	
	func(arr,8);

}
```



## 双端队列

书本113

## 顺序表

### 代码实现

```c++
#include<iostream>
using namespace std;
#define N 100
typedef int SLDataType;
typedef struct SeqList
{
	SLDataType* list;
	int size;//当前顺序表的大小
}SL;


//创建顺序表
void Initlist(SL* &pstr)
{
	pstr->size = 0;
	pstr->list = (SLDataType*)malloc(N * sizeof(SLDataType));
}


//插入，时间复杂度为O（n）
bool Insert(SL* pstr, int pos, SLDataType data)
{
	if (pos<0 || pos>pstr->size || pstr->size == N) return;
	//size范围内插入，因为顺序表是连续的，不允许中断
	int end = pstr->size;
	while (end > pos + 1) {
		pstr->list[end] = pstr->list[end - 1];
		end--;
	}
	pstr->list[end] = data;
	pstr->size++;
	return true;	
}


//删除，时间复杂度为O（n）
bool DelectData(SL* pstr, int pos)
{
	if (pos<0 || pos>pstr->size) return false;
	int str = pos;
	while (str < pstr->size - 1)
	{
		pstr->list[str] = pstr->list[str + 1];
		str++;
	}
	pstr->size--;

}


//释放空间
void DestoryList(SL* &pstr)
{
	free(pstr);
	pstr = nullptr;
	
}
bool isListEmpty(SL*& pstr) {
	return pstr->size == 0;
}

int ListLength(SL*& pstr) {
	return pstr->size;
}

void PrintList(SL* pstr)
{
	for (int i = 0; i < pstr->size; i++)
	{
		printf("%d\t", pstr->list[i]);
	}
	printf("\n");
}

bool GetElem(SL*& pstr, int i, SLDataType& e) {
	if (i >= 0 && i < pstr->size) {
		e = pstr->list[i];
		return true;
	}
	return false;
}


int main() {

}
```



### 头节点优点

单链表的头节点可能有以下几个作用：

1. **标识链表**：头节点作为链表的起点，通过头指针指向它，可以方便地标识和访问整个链表。无论链表是否为空，头指针都不为空，始终指向头节点。
2. **简化操作**：在带有头节点的单链表中，进行插入、删除等操作时，不需要对头指针进行特殊处理，因为头节点始终存在，这样可以统一操作流程，简化代码实现。
3. **方便处理空链表**：当链表为空时，如果没有头节点，头指针将是NULL。而有了头节点，即使链表为空，头指针也会指向这个头节点，这样可以统一处理空链表和非空链表的情况。
4. **提高安全性**：在遍历或操作链表时，有了头节点可以避免对第一个元素的特殊处理，减少出错的可能性。
5. **便于扩展功能**：在某些情况下，头节点可以用来存储链表的一些额外信息，如链表的长度，这样便于快速获取这些信息而无需遍历整个链表。

### 多项式相加

```c++
#include <iostream>
#include <vector>
using namespace std;

// 函数用于打印多项式
void printPolynomial(const vector<int>& poly) {
    bool first = true;
    for (int i = poly.size() - 1; i >= 0; --i) {
        if (poly[i] != 0) {
            if (!first && poly[i] > 0) cout << " + ";
            else if (poly[i] < 0) cout << " - ";
            cout << abs(poly[i]);
            if (i > 0) cout << "x";
            if (i > 1) cout << "^" << i;
            first = false;
        }
    }
    cout << endl;
}

// 函数用于将两个多项式相加
vector<int> addPolynomials(const vector<int>& poly1, const vector<int>& poly2) {
    // 确定结果多项式的长度
    int maxDegree = max(poly1.size(), poly2.size());
    vector<int> result(maxDegree, 0);

    // 将两个多项式的系数相加
    for (int i = 0; i < maxDegree; ++i) {
        if (i < poly1.size()) result[i] += poly1[i];
        if (i < poly2.size()) result[i] += poly2[i];
    }

    return result;
}

int main() {
    // 多项式 P(x) = 3 + 4x + 2x^2 表示为 [3, 4, 2]
    vector<int> poly1 = { 3, 4, 2 };

    // 多项式 Q(x) = 1 + 2x + 3x^3 表示为 [1, 2, 0, 3]
    vector<int> poly2 = { 1, 2, 0, 3 };

    // 打印输入多项式
    cout << "Polynomial 1: ";
    printPolynomial(poly1);

    cout << "Polynomial 2: ";
    printPolynomial(poly2);

    // 相加多项式
    vector<int> result = addPolynomials(poly1, poly2);

    // 打印结果
    cout << "Result: ";
    printPolynomial(result);

    return 0;
}

```



## 线性表常见算法：

### 有序表的归并算法

书65

### 删除顺序表中值为x的所有节点

书p38



```c++
//整体建表法
//显然目标字串在原字符串中，定义k和i之间的元素全是x，那么只要元素覆盖上去就可以
bool deletelist(list*& l, int i) {
    if (i<0 || i>l->length) {
        return false;
    }
    int j = i;
    for (j; j < l->length-1; j++) {
        l->arr[j] = l->arr[j + 1];
    }
    l->length--;
    return true;
}


//元素移动法
void delnodel2(list*& l, ElemType x) {
    int k = 0, i=0;
    while (i < l->length) {
        if (l->arr[i] == x) {
            k++;
        }
        else {
            l->arr[i-k] = l->arr[i];         
        }
        i++;   
    }
    l->length -= k;  
}


//区间划分法
using namespace std;
void func(vector<int>& array,int x) {
	int k = -1;
	int n = array.size();
	int i = 0;
	while(i < n) {
		if (array[i] != x) {
			k++;
			if (k != i) {
				swap(array[i], array[k]);
			}
		}
		i++;
	}

	array.resize(k+1);

}
    
```





### **将所有奇数移到所有偶数的前面**

```c++
//区间划分法
void move2(list*& l) {
    //用l.arr[0..i]表示存放奇数的奇数区间，i初始为-1表示区间为空
    //如果出现了奇数，区间长度加一，如果i!=j，说明i-j之间全是偶数，此时将第一个偶数与奇数交换
    //使得0-i全是奇数
    int i = -1, j = 0;
    for (j; j < l->length; j++) {
        if (l->arr[j] % 2 != 0) {
            i++;
            if (i != j) {
                swap(l->arr[i], l->arr[j]);
            }
        }
    }
}
```



### 递增序列LA LB LC,LA存放三序列的交集

书68例2.15



### 删除单链表重复节点

p68例2.16

### 双链表翻转

整体建表法，先分开头节点，在头插后面的节点p57例2.9

### 双链表排序

整体见表法，先分开头节点和第一个节点，再遍历后续节点，尾插p57例2.10



### 判断链表是否对称

书59例2.13

## 顺序表和链表的比较

ppt第二章小结

![image-20231017222914807](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231017222914807.png)

# 串、数组和广义表

## 串的匹配算法：BF（暴力）

算法目的：确定主串所含字串第一次出现的位置

模式串长度为m,主串长度为n

该算法最好的时间复杂度是O(m)

平均情况为O(nxm)

```c
int BF(string text, string pattern) {
	int i = 0, j = 0;
	int text_size = text.size();
	int pattern_size = pattern.size();
	while (i < text_size && j < pattern_size) {
		if (text[i] == pattern[j]) {
			i++;
			j++;
		}
		else {
			i = i - j + 1;
			j = 0;
		}
	}

	if (j == pattern_size) return i - j;
	else return -1;
}

```

## 串的匹配算法：KMP

https://oi-wiki.org/string/kmp/



https://www.bilibili.com/video/BV18k4y1m7Ar/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

模式串是在字符串匹配算法中使用的一个概念。在字符串匹配问题中，通常有一个主串（源字符串）和一个模式串（要搜索的字符串）。模式串是我们希望在主串中找到的特定字符串。




主串s的指针i不必回溯，可提速到**O（n+m)**

重点在于不在原字符串中回溯，而是在模式串中回溯。

看最大的相同的前缀和后缀。因为前缀和后缀相同意味着这一段相同的后缀已经在主串中寻找过了并且是匹配的，此时回溯模式串就可以



下此次回溯直接从x和c开始比较即可，我们不需要在主串中进行匹配



```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
class Solution {
public:
	vector<int>Arry(string pattern)
	{
		int index = 0;
		vector<int> arry(pattern.size(), 0);
		for (int i = 1; i < pattern.size();)
		{
			//我们从第一个和第二个字符开始比较，所以index=0,i=1
			if (pattern[i] == pattern[index])
			{
				//回忆以下视频内容，如果它们的值是一样的，代表正在形成相同的前缀
				//所以arr[i]=index+1
				arry[i] = index + 1;
				index++;
				i++;
			}

			else
			{
				//如果他们的值不一样，就要进行回溯
				if (index != 0)
				{
					//回溯到对应数组的值所代表的那一个字符
					index = arry[index - 1];
				}
				else
				{
					//如果是零就直接等于零，不能再减一了
					arry[i] = 0;
					i++;
				}
			}
		}
		return arry;

	}

	int KMP(string text, string pattern)
	{
		vector<int>arry = Arry(pattern);

		int i = 0, j = 0;
		while (i < text.size() && j < pattern.size())
		{
			if (text[i] == pattern[j])
			{
				i++;
				j++;
			}
			else
			{
				if (j != 0)
				{
					//此时要进行回溯
					//如果j的值不等于零，就把模式串指针移动到arry数组指向的那个最长相同前缀那里
					j = arry[j - 1];
				}
				else
				{
					//如果是零就直接重新遍历模式串
					i++;
				}
			}
		}
		if (j == pattern.size())
		{
			return i - pattern.size();
		}
		else
		{
			return -1;
		}
	}
	int strStr(string haystack, string needle) {
		return  KMP(haystack, needle);

	}
};

```





## 矩阵的压缩存储

https://www.bilibili.com/video/BV1nJ411V7bd?p=71&spm_id_from=pageDriver&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

书本165



# 树和二叉树

## 树的基本术语

1. 节点的度与树的度：节点的度是指节点的子树的个数，树的度是指树的节点最大的度
2. 分支节点与叶子节点：树中节点的度不等于0的节点被称为分支节点，度为0的点被称为叶子节点
3. 路径与路径长度：
4. 孩子节点、双亲节点、兄弟节点
5. 节点层次、树的高度：根节点在第一层，树的高度为节点的最大层数
6. 有序树和无序树：
7. 森林

## 树的性质

树的节点个数等于树的所有节点的度数之和+1（加上根节点）


$$
度为m的树中第i层上至多有{m}^{i-1}个节点\\
高度为h的m次树至多有\frac{{m}^{h}-1}{m-1}个节点\\
具有n个节点的m次树的最小高度为\lceil \log_{m}{(n(m-1)+1)} \rceil个节点\\
$$


## 树的存储结构

### 双亲表示法

实现：定义结构数组存放树的节点，每个节点含两个域：

1. 数据域：存放本节点信息

2. 双亲域：存放节点双亲在数组中的位置，根节点没有双亲，设置值为-1，A、B、C的双亲是R，R的下标是0，所以A、B、C的双亲域都是0，D的双亲域是1，说明它的双亲在数组中的坐标是1，即它的双亲是A

    

   

```c
#include <iostream>
#include <vector>

using namespace std;
typedef char type ;

// 定义树的结点
struct TreeNode {
    type data;          // 结点数据
    int parentIndex;   // 双亲结点的数组下标
};

// 创建树的函数
vector<TreeNode> createTree(vector<type> data, vector<int> parents) {
    vector<TreeNode> tree;

    // 创建根结点
    TreeNode root;
    root.data = data[0];
    root.parentIndex = -1;  // 根结点没有双亲
    tree.push_back(root);

    // 创建其他结点
    for (int i = 1; i < data.size(); ++i) {
        TreeNode node;
        node.data = data[i];

        // 检查 parents 数组是否足够长，以防索引越界
        if (i < parents.size()) {
            node.parentIndex = parents[i];
        }
        else {
            cerr << "Warning: Insufficient parent information for node " << i << ". Setting parentIndex to 0." << endl;
            node.parentIndex = 0;  // 默认将双亲设置为根结点
        }

        tree.push_back(node);
    }

    return tree;
}

int main() {
    // 示例数据
    vector<type> inputData = {'R','A','B','C','D','E','F','G','H','K'};
    // 手动输入每个结点的双亲结点的位置信息
    vector<int> parentIndices = { -1, 0, 0, 0, 1, 1, 3, 6, 6, 6 };

    // 创建树
    vector<TreeNode> myTree = createTree(inputData, parentIndices);

    // 输出树的结点信息
    for (int i = 0; i < myTree.size(); ++i) {
        cout << "Node " << i << ": Data=" << myTree[i].data
            << ", ParentIndex=" << myTree[i].parentIndex << endl;
    }

    return 0;
}

```

### 孩子链表



### 孩子兄弟表示法

孩子兄弟表示法实际就是把树转化成二叉树的过程



## 满二叉树

非空满二叉树的特点如下：

1. 叶子节点都在最下一层
2. 只有度为0和度为2的节点

$$
高度为h，则有{2}^{h}-1个节点
$$

## 完全二叉树

1. 叶子节点只可能在最下面两层中出现
2. 最下面一层叶子节点以此排列在最左边

$$
节点个数n=n_0+n_1+n_2\\
节点的度之和为n-1\\
节点数n=n1+2n_2+1\\
节点个数n是奇数的时候，n_1=0,节点个数n是偶数的时候，节点个数n_1=1\\
非空二叉树的第i层上最多有{2}^{i-1}个节点\\
高度为h的二叉树最多有{2}^{h}-1个节点\\
$$

![image-20240620214736659](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240620214736659.png)



## 树和二叉树的转换

### 树转化成二叉树

长子兄弟转化成左孩子

其他兄弟节点转化为长子节点的右孩子

将森林转化为二叉树，已知森林中有n个叶子节点，则二叉树中有n+1个节点无右孩子

### 二叉树转化为树

左孩子恢复为长子关系

右孩子恢复为兄弟关系

## 二叉树的存储结构

### 顺序存储

不适用下标为0的节点，对于任何一个节点i来说，左孩子节点下标为2i,右孩子节点下标为2i+1

适合于满二叉树或者是完全二叉树

缺点：顺序存储的大小固定，容易造成内存浪费。

### 二叉树的链式存储

一个二叉树需要2*n个指针

但是真正用到的指针只有n-1个，因为每个指针指向一个节点，但是没有指针指向根节点



## 二叉树的基本运算

### 二叉树的遍历

#### 先/中/后序遍历递归

时间复杂度是o(n)

```c
//先序遍历
int PreOrderTraverse(BiTree T)
{
	if (T == NULL)
		return OK;
	else
	{
		visit(T);//访问根节点
		PreOrderTraverse(T->lchild);//递归遍历左子树
		PreOrderTraverse(T->rchild);//递归遍历右子树
	}
}

//中序遍历
int InOrderTraverse(BiTree T)
{
	if (T == NULL)
		return OK;
	else
	{		
		InOrderTraverse(T->lchild);//递归遍历左子树
		visit(T);//访问根节点
		InOrderTraverse(T->rchild);//递归遍历右子树
	}
}


//后序遍历
int PostOrderTraverse(BiTree T)
{
	if (T == NULL)
		return OK;
	else
	{
		PostOrderTraverse(T->lchild);//递归遍历左子树
		PostOrderTraverse(T->rchild);//递归遍历右子树
		visit(T);//访问根节点
	}
}
```





#### 迭代中序遍历算法

```c
#include <iostream>
#include <queue>
#include<stack>
#include <vector>
using namespace std;

typedef char element;
struct TreeNode {
    element val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(element x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* constructTree(vector<element>& values) {
    if (values.empty()) return nullptr;

    TreeNode* root = new TreeNode(values[0]);
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;

    while (!q.empty() && i < values.size()) {
        TreeNode* current = q.front();
        q.pop();

        if (values[i] != '#') {
            current->left = new TreeNode(values[i]);
            q.push(current->left);
        }
        ++i;

        if (i < values.size() && values[i] != '#') {
            current->right = new TreeNode(values[i]);
            q.push(current->right);
        }
        ++i;
    }

    return root;
}

void DestoryTree(TreeNode* root) {
    if (root != nullptr) {
        DestoryTree(root->left);
        DestoryTree(root->right);
        delete root;
    }
}

void func(TreeNode* root) {
    if (root == nullptr) {
        cout << "二叉树为空";
        return;
    }
    
    stack<TreeNode*>q;
    TreeNode* p = root->left;
    q.push(root);
    while (!q.empty()||p!=nullptr) {
      //auto t = q.top();
      while (p != nullptr) {
          q.push(p);
          p = p->left;
      }

      auto t = q.top();
      cout << t->val << ' ';
      q.pop();
      p = t->right;
    }
}
// Example usage
int main() {
    vector<element> values = { 'a','b','c','d','e','#','#'};
    TreeNode* root = constructTree(values);
    func(root);
    DestoryTree(root);
    return 0;
}

```

#### 递归先序遍历算法

```c++
void func(TreeNode* root) {
    stack<TreeNode*>s;
    s.push(root);
    while (!s.empty()) {
        auto t = s.top();
        s.pop();
        cout << t->val << ' ';
        if (t->left != nullptr) s.push(t->left);
        if (t->right != nullptr) s.push(t->right);
    }
}
```

#### 递归后序遍历

该算法有一个特点是：栈中保存的是当前访问节点的所有祖先节点（未访问），所有如果有算法要求实现访问所有祖先节点的时候，可以使用后序遍历

```c++
void postTravel(TreeNode* root) {
    TreeNode* p=root, * r;
    stack<TreeNode*>s;
    bool flag;
    do {
        while (p != nullptr) {
            s.push(p);
            p = p->left;
        }

        r = nullptr;    //r指向刚刚访问的节点
        flag = true;    //flag为真表示正在处理栈顶节点
        while (!s.empty() && flag) {
            auto t = s.top();
            if (t->right == r) {
                cout << t->val << ' ';
                s.pop();
                r = t;
            }

            else {
                p = t->right;
                flag = false;
            }
        }


    } while (!s.empty());
    
}
```



#### 层次遍历

层次遍历二叉树是一种广度优先搜索（BFS）的算法，它按照层次的顺序逐层遍历树的节点。具体思想如下：

1. **使用队列：** 从树的根节点开始，将根节点入队列。
2. **循环遍历：** 在一个循环中，从队列中取出一个节点，访问它，并将其子节点（如果有的话）按顺序入队列。
3. **重复步骤：** 重复以上步骤，直到队列为空为止。

这种遍历方式确保了按照树的层次逐层遍历，先处理父节点，然后是它的子节点，以此类推。这样的遍历方式常用于需要按层次分析树结构的问题。

```c
#include <iostream>
#include <queue>
#include<stack>
#include <vector>
using namespace std;

typedef char element;
struct TreeNode {
    element val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(element x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* constructTree(vector<element>& values) {
    if (values.empty()) return nullptr;

    TreeNode* root = new TreeNode(values[0]);
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;

    while (!q.empty() && i < values.size()) {
        TreeNode* current = q.front();
        q.pop();

        if (values[i] != '#') {
            current->left = new TreeNode(values[i]);
            q.push(current->left);
        }
        ++i;

        if (i < values.size() && values[i] != '#') {
            current->right = new TreeNode(values[i]);
            q.push(current->right);
        }
        ++i;
    }

    return root;
}

void DestoryTree(TreeNode* root) {
    if (root != nullptr) {
        DestoryTree(root->left);
        DestoryTree(root->right);
        delete root;
    }
}

void func(TreeNode* root) {
    if (root == nullptr) {
        cout << "二叉树为空";
        return;
    }

    queue<TreeNode*>q;
    q.push(root);
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        cout << t->val << ' ';
        if (t->left != nullptr) {
            q.push(t->left);
        }
        if (t->right != nullptr) {
            q.push(t->right);
        }
    }
    

}
// Example usage
int main() {
    vector<element> values = { 'a','b','c','d','e','#','#'};
    TreeNode* root = constructTree(values);
    func(root);
    DestoryTree(root);
    return 0;
}

```



### 二叉树的建立

1. 先序和中序可以唯一确定一颗二叉树

2. 中序和后序可以唯一确定一颗二叉树

3. 但是先序和后序不能确定一个二叉树

4. $$
   n个节点的先序序列，可以构造\frac1{n+1}*\binom{n}{2n}个二叉树
   $$

   
   $$
   
   $$
   

#### 先序字符串和中序字符串构建二叉树

```c++
TreeNode* CreateBT1(const char* pre, const char* in, int n)
{
    TreeNode* s;  
    const char* p;  
    int k;
    if (n <= 0) return NULL;
    s = (TreeNode*)malloc(sizeof(TreeNode)); 	        //创建根结点
    s->val = *pre;
    for (p = in; p < in + n; p++)	          	//在in中找为pre的位置k
        if (*p == *pre)
            break;
    k = p - in;
    s->left=CreateBT1(pre + 1, in, k);
    s->right=CreateBT1(pre + 1 + k, p + 1, n - k - 1);
    return s;
}

```

#### 中序字符串和后序字符串构建二叉树

```c++

TreeNode* CreateBT1(const char* post, const char* in, int n)
{
    TreeNode* s;  
    const char* p;
    char r;
    int k;
    if (n <= 0) return nullptr;
    r = *(post + n - 1);
    s = (TreeNode*)malloc(sizeof(TreeNode)); 	        //创建根结点
    
    s->val = r;
    for (p = in; p < in + n; p++)	          	//在in中找为pre的位置k
        if (*p == r)
            break;
    k = p - in;
    s->left=CreateBT1(post, in, k);
    s->right=CreateBT1(post + k, p + 1, n - k - 1);
    return s;
}
```



#### 二叉树层次创建

```c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

TreeNode* constructTree(vector<int>& values) {
    if (values.empty()) return nullptr;

    TreeNode* root = new TreeNode(values[0]);
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;

    while (!q.empty() && i < values.size()) {
        TreeNode* current = q.front();
        q.pop();

        if (values[i] != INT_MIN) {
            current->left = new TreeNode(values[i]);
            q.push(current->left);
        }
        ++i;

        if (i < values.size() && values[i] != INT_MIN) {
            current->right = new TreeNode(values[i]);
            q.push(current->right);
        }
        ++i;
    }

    return root;
}

// Example usage
int main() {
    vector<int> values = {3, 9, 20, INT_MIN, INT_MIN, 15, 7};
    TreeNode* root = constructTree(values);
    return 0;
}

```



#### 顺序表二叉树建立链序二叉树

字符串从下标为1开始

```c++
TreeNode* Create(string s,int i,int n) {
    if (i >n) return nullptr;
    if (s[i] == '#') return nullptr;
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->val = s[i];
    root->left = Create(s, 2 * i,n);
    root->right = Create(s, 2 * i + 1,n);
    return root;
}

```



### 复制二叉树

1. 如果是空树，递归结束
2. 否则，申请新节点空间，复制根节点
3. 递归复制左子树
4. 递归复制右子树

```c
TreeNode* Copy(TreeNode *root)
{
    if (root == nullptr) return nullptr;
    else
    {
        TreeNode* copy = (TreeNode*)malloc(sizeof(TreeNode));
        copy->val = root->val;
        copy->left=Copy(root->left);
        copy->right=Copy(root->right);
        return copy;
    }
}
 
```

### 计算二叉树的深度

1. 如果是空树，则深度为0
2. 否则，递归计算左子树的深度为m,递归极端右子树的深度为n，二叉树的深度则为m与n较大的那一个加一

```c
int Depth(BiTree T)
{
	if (T == NULL)
	{
		return 0;
	}
	else
	{
		int m = Depth(T->lchild);
		int n = Depth(T->rchild);
		return m > n ? m + 1 : n + 1;
	}
}
```

### 计算二叉树的节点数

1. 如果是空树，则节点数为0
2. 否则，节点数=左子树节点数+右子树节点数+1

```c
int NodeCount(BiTree T)
{
	if (T == NULL)
	{
		return 0;
	}
	else
	{
		int m = NodeCount(T->lchild);
		int n = NodeCount(T->rchild);
		return m + n + 1;
	}
}
```

### 计算叶子节点数

1. 如果是空树，则节点数为0
2. 否则，节点数=左叶子树节点数+右叶子树节点数

```c

int func(TreeNode* root) {
    if (root == nullptr) return 0;
    else if (root->left == nullptr && root->right == nullptr) {
        cout << root->val << ' ';
        return 1;
    }
    else {
        int m=func(root->left);
       int n= func(root->right);  
       return m + n;
    }

}
```





### 计算二叉树中单分支节点的个数

```c++
int func(TreeNode* root) {
    if (root == nullptr) return 0;
    int s = 0;
    if ((root->left == nullptr && root->right != nullptr) || (root->left != nullptr && root->right == nullptr))
        s++;
    s += func(root->left);
    s += func(root->right);
    return s;
    
}
```





### 销毁二叉树

```c++

void DestoryTree(TreeNode* root) {
    if (root != nullptr) {
        DestoryTree(root->left);
        DestoryTree(root->right);
        delete root;
    }
}
```



### 计算节点x的层次

```c++
int func(TreeNode* root,element x,int level) {
    if (root == nullptr) return 0;
    else if (root->val == x) return level;
    else {
        int l = func(root->left, x,level + 1);
        if (l == 0) return func(root->right, x, level + 1);
        else return l;
    }
}
```

### 计算k层有多少节点

```c++
int func(TreeNode* root,int level,int k) {
    if (root == nullptr) return 0;
    else if (level == k) return 1;
    else {
       
        int m = func(root->left, level + 1,k);
       
        int n = func(root->right, level + 1, k);
        return n + m;
        
    }
}
```

### 计算k层有多少叶子节点

```c++
int func(TreeNode* root, int level, int k) {
    if (root == nullptr) return 0;
    else if (level == k&&root->left==nullptr&&root->right==nullptr) return 1;
    else {

        int m = func(root->left, level + 1, k);

        int n = func(root->right, level + 1, k);
        return n + m;

    }
}
```



### 判断两二叉树是否相似

```c++
bool func(TreeNode* a,TreeNode*b) {
    if (a == nullptr && b == nullptr) return true;
    else if (a == nullptr || b == nullptr) return false;
    else {    
        bool x = func(a->left,b->left);
        bool y = func(a->right,b->right);
        return x && y;
    }
  
}
```

### 寻找节点x的祖先节点

```c++
bool ancestor(TreeNode* b,element x){
    if (b == nullptr) return false;
    else if ((b->left != nullptr && b->left->val==x) ||( b->right!= nullptr && b->right->val == x)) {
        cout << b->val << ' ';
        return true;
    }

    else if (ancestor(b->left, x) || ancestor(b->right, x)) {
        cout << b->val << ' ';
        return true;
    }
    else return false; 
}
```

### 输出所有叶子节点的祖先节点

```c++

void postTravel(TreeNode* root) {
    TreeNode* p=root, * r;
    SqStack* s;
    InitStack(s);
    
    bool flag;
    do {
        while (p != nullptr) {
            Push(s,p);
            p = p->left;
        }

        r = nullptr;    //r指向刚刚访问的节点
        flag = true;    //flag为真表示正在处理栈顶节点
        while (!StackEmpty(s) && flag) {
            GetTop(s,p);
            if (p->right == r) {
                if (p->left == nullptr && p->right == nullptr) {
                    for (int i = s->top; i > 0; i--) {
                        cout << s->data[i]->val << ' ';
                    }
                    cout << s->data[0]->val << endl;
                }

                Pop(s, p);
                r = p;
               
            }

            else {
                p = p->right;
                flag = false;
            }
        }


    } while (!StackEmpty(s));
    
}
```

## 线索二叉树

书本227

## 哈夫曼树

### 哈夫曼树的基本概念

1. $$
   哈夫曼树：在n_0个叶子节点构成的二叉树中，带权路径长度最小的树被称为哈夫曼树或者是最优二叉树。\\满二叉树不一定是最优二叉树
   $$

   

2. **节点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树（充分条件。指存在一些二叉树不是二叉树但是也是最短路径）**

3. 树的带权路径长度WPL：树当中**所有的叶子节点**带权路径长度之和

4. ![image-20231227165845292](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231227165845292.png)

5. 哈夫曼树中权值越大，离树根越进。**具有相同带权节点的哈夫曼树并不唯一**

6. 哈夫曼树的节点度数为0或2，没有度数为1的节点

7. 包含n个叶子节点的哈夫曼树中共有2n-1个节点（包含n个节点的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新节点）

   





### 哈夫曼树的构造算法



<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231111222438944.png" alt="image-20231111222438944" style="zoom: 33%;" />



采用顺序存储结构--一维结构数组

**为了简单，数组下标从1开始**

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231111223148156.png" alt="image-20231111223148156" style="zoom:33%;" />

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231111223414381.png" alt="image-20231111223414381" style="zoom: 33%;" />

```c
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <climits>

#define ERROR -1

typedef struct
{
    int weight;
    int parent, lch, rch;
} HTNode, * HuffmanTree;

// 选择权值最小的两个节点
void select(HuffmanTree HT, int k, int& s1, int& s2) {
    int min1, min2;

    min1 = min2 = INT_MAX;

    for (int i = 1; i <= k; i++) {
        if (HT[i].parent == 0) {
            if (HT[i].weight < min1) {
                min2 = min1;
                s2 = s1;

                min1 = HT[i].weight;
                s1 = i;
            }
            else if (HT[i].weight < min2) {
                min2 = HT[i].weight;
                s2 = i;
            }
        }
    }
}

int InitHuffmanTree(HuffmanTree& HT, int n) {
    int s1, s2;
    if (n <= 1)
        return ERROR;
    int m = 2 * n - 1;

    HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));

    for (int i = 1; i <= m; i++) {
        HT[i].parent = 0;
        HT[i].rch = 0;
        HT[i].lch = 0;
        HT[i].weight = 0;
    }

    for (int i = 1; i <= n; i++) {
        int temp;
        scanf("%d", &temp);
        HT[i].weight = temp;
    }

    for (int i = n + 1; i <= m; i++) {
        select(HT, i - 1, s1, s2);
        HT[s1].parent = i;
        HT[s2].parent = i;

        HT[i].lch = s1;
        HT[i].rch = s2;

        HT[i].weight = HT[s1].weight + HT[s2].weight;
        printf("%d\n", HT[i].weight);
    }

    // 返回根节点的下标
    return m;
}

int main() {
    HuffmanTree HT = nullptr;
    int n;
    std::cout << "Enter the number of elements: ";
    std::cin >> n;

    int root = InitHuffmanTree(HT, n);

    std::cout << "Huffman Tree Initialized." << std::endl;

    // 在这里可以对构造的哈夫曼树进行其他操作

    // 释放内存
    free(HT);
    HT = nullptr;

    return 0;
}

```

`INT_MAX` 是C++标准库中 `<climits>` 头文件中定义的常量，表示整数类型（`int`）的最大值。具体来说，`INT_MAX` 表示的是带符号整数（`int`）的最大可表示的正整数值。

在标准头文件 `<climits>` 中，还有一些其他的常量，如 `INT_MIN` 表示 `int` 类型的最小值，`CHAR_BIT` 表示一个字节中的比特数等。这些常量提供了对基本数据类型的一些限制和特性的访问。使用这些常量可以增强代码的可读性和可移植性，因为它们在不同的系统上具有相同的含义。

示例使用 `INT_MAX` 的情况是在 `select` 函数中，通过初始化 `min1` 和 `min2` 为 `INT_MAX`，然后在循环中找到权值最小和次小的节点。这样的初始值确保在循环中的第一个节点会被正确地设置为最小值。



字符数组存储每个字符得到的哈夫曼编码，数组长度最长是n-1就足够，取n，最后一个位置放\0



### 哈夫曼编码

1. 哈夫曼编码能保证是前缀编码（因为没有一片树叶是另一片树叶的祖先，所以每个叶节点的编码就不可能是其他叶节点编码的前缀）
2. 哈夫曼编码能够保证字符编码总长最短，是最优前缀码（哈夫曼树的带权路径长度最短）

```c++
#include"哈夫曼.h"
void creatHuffmanCode(HuffmanTree HT, HuffmanCode *HC, int n)
//从叶子到根逆向求每一个字符的哈夫曼编码，存储在编码表HC中
{
	//二级指针
	HC = (char**)malloc((n + 1) * sizeof(char*));//分配n个字符编码的头指针矢量
	char* cd = (char*)malloc(n * sizeof(char));//分配临时存放编码的动态数组空间
	cd[n - 1] = '\0';//编码结束符
	for (int i = 1; i <= n; i++)
	{
		int start = n - 1;
		int c = i;
		int f = HT[i].parent;
		while (f != 0)//从叶子节点开始回溯，知道根节点
		{
			--start;
			if (HT[f].lch == c)//节点是左孩子，则生成代码0
				cd[start] = '0';
			else
				cd[start] = '1';//节点是右孩子，则生成代码1
			c = f;
			f = HT[i].parent;
		}//求出第i个字符的编码
		HC[i] = (char*)malloc((n - start) * sizeof(char));//为第i个字符串编码分配空间
		strcpy(HC[i], &cd[start]);//将求得的编码从临时空间复制到HC行列中
	}
	free(cd);//释放临时空间

}
```



### 文件的编码

构建哈夫曼树，通过哈夫曼编码的数字遍历哈夫曼树，直到遇到叶子节点对应的字符

## 并查集

并查集（Disjoint Set）是一种用于处理集合合并与查询连通性问题的**数据结构**。它主要包括两个操作：**查找（Find）和合并（Union）**。

在并查集中，  每个元素都有一个父节点，初始时每个元素的父节点都是自己。查找操作用于查找元素所属的集合，它通过不断向上查找父节点，直到找到根节点来确定集合的代表元素。合并操作用于将两个集合合并为一个集合，它将一个集合的根节点指向另一个集合的根节点。

### **数组表示**：

- 在数组表示中，每个元素都有一个指向其所在集合的代表元素（或者说父节点）的指针。
- 初始时，每个元素的代表元素指针指向自己，表示每个元素都是一个独立的集合。
- 合并操作时，将一个集合的代表元素的指针指向另一个集合的代表元素，即将其中一个集合的根节点指向另一个集合的根节点。
- 查询操作时，通过递归或循环查找到根节点，然后比较根节点是否相同，从而判断两个元素是否属于同一个集合。

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240307232118190.png" alt="image-20240307232118190" style="zoom: 67%;" />

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240307232158810.png" alt="image-20240307232158810" style="zoom:67%;" />

```c++
const int MAXN = 10005;
int parent[MAXN];

// 初始化并查集，每个元素都是一个独立的集合
void init(int n) {
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }
}

// 查找元素所在集合的代表元素
int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]); // 路径压缩
}

// 合并两个集合
void merge(int x, int y) {
    int root_x = find(x);
    int root_y = find(y);
    if (root_x != root_y) {
        parent[root_x] = root_y;
    }
}

// 判断两个元素是否属于同一个集合
bool same(int x, int y) {
    return find(x) == find(y);
}

```



### **树表示**：

- 在树表示中，每个集合用一棵树表示，其中树的根节点作为该集合的代表元素。
- 初始时，每个元素都是一个单节点的树，根节点指向自己。
- 合并操作时，将一棵树的根节点连接到另一棵树的根节点上。
- 查询操作时，通过递归或循环查找到根节点，然后比较根节点是否相同，从而判断两个元素是否属于同一个集合。

![image-20240307232250984](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240307232250984.png)

![image-20240307232310603](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240307232310603.png)

```c++
const int MAXN = 10005;
int parent[MAXN], rank[MAXN];

// 初始化并查集，每个元素都是一个独立的集合
void init(int n) {
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
        rank[i] = 0;
    }
}

// 查找元素所在集合的代表元素
int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]); // 路径压缩
}

// 合并两个集合
void merge(int x, int y) {
    int root_x = find(x);
    int root_y = find(y);
    if (root_x != root_y) {
        if (rank[root_x] < rank[root_y]) {
            parent[root_x] = root_y;
        } else if (rank[root_x] > rank[root_y]) {
            parent[root_y] = root_x;
        } else {
            parent[root_y] = root_x;
            rank[root_x]++;
        }
    }
}

// 判断两个元素是否属于同一个集合
bool same(int x, int y) {
    return find(x) == find(y);
}

```



#### **路径压缩**

![image-20240307232329810](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240307232329810.png)

#### rank

rank（或者称为秩、深度）在树表示的并查集中是用来优化合并操作的一种策略。它的作用主要有两个方面：

1. **合并优化**：在合并两个集合时，rank用于决定将哪个树连接到另一个树上。具体来说，合并时会比较两个树的rank（深度），将rank较小的树连接到rank较大的树上，这样可以降低整个树的深度，减少后续查找操作的时间复杂度。这种方式可以有效避免出现极端情况下树高过大的情况，保证了操作的平均时间复杂度。
2. **平衡树高**：通过合并时对rank的比较，可以尽量保持并查集中树的高度平衡。这样在后续的查找操作中，树的深度较小，查找路径也相对较短，从而提高了查找的效率。保持树的平衡是并查集能够保持高效性能的关键之一。



### 最小生成树

地图上有n个城市，现在想给这个城市之间造路，希望能
让城市之间两两可达。给出了m种供选择的道路，每种选
择是一个三元组(u，v，w)，代表给u城市和v城市之间建
造一条长度为w的道路。
希望最终的道路总长越小越好(成本低)，你能帮帮他吗?





**MST：至少包含一棵树，包含最短路径（反证法）**

**设有一颗最小生成树不包含最短路径，此时加上最短路径，与最小生成树矛盾，去除一个路径，保存最短路径，的证。**

整体来说，Kruskal 算法通过贪心的策略，每次选择权重最小且不会构成环的边加入到最小生成树中，直到生成树包含了所有顶点为止。并查集用于快速判断两个顶点是否在同一个连通分量中，以及合并连通分量。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Edge {
    int from, to, weight;
    Edge(int f, int t, int w) : from(f), to(t), weight(w) {}
};

class DisjointSet {
private:
    vector<int> parent;

public:
    DisjointSet(int size) {
        parent.resize(size);
        for (int i = 0; i < size; ++i) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = rootY;
        }
    }
};

vector<Edge> kruskal(vector<Edge>& edges, int n) {
    vector<Edge> result;
    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
        return a.weight < b.weight;
    });

    DisjointSet ds(n);
    for (const Edge& edge : edges) {
        if (ds.find(edge.from) != ds.find(edge.to)) {
            ds.unionSet(edge.from, edge.to);
            result.push_back(edge);
        }
    }

    return result;
}

int main() {
    int n = 6;
    vector<Edge> edges = {{0, 1, 6}, {0, 2, 1}, {0, 3, 5}, {1, 2, 5}, {1, 4, 3}, {2, 3, 5}, {2, 4, 6}, {2, 5, 4},
                          {3, 5, 2}, {4, 5, 6}};

    vector<Edge> mst = kruskal(edges, n);

    cout << "最小生成树的边：" << endl;
    for (const Edge& edge : mst) {
        cout << edge.from << " - " << edge.to << " 权值：" << edge.weight << endl;
    }

    return 0;
}

```



# 图

## 基本术语

- **顶点 (Vertex)**: 图中的一个基本单位，表示对象。通常用字母 V表示。
- **边 (Edge)**: 连接两个顶点的线，表示对象之间的关系。用 E表示。
- **邻接 (Adjacency)**: 如果两个顶点通过一条边相连，则称它们是邻接的。
- **度 (Degree)**: 与一个顶点相连的边的数量。在有向图中，分为入度 (In-degree) 和出度 (Out-degree)。

- **无向图 (Undirected Graph)**: 边没有方向，表示两个顶点之间的双向关系。
- **有向图 (Directed Graph)**: 边有方向，表示从一个顶点指向另一个顶点的单向关系。
- **加权图 (Weighted Graph)**: 边上有权值，用于表示边的“成本”、“距离”或“容量”等。

- **连通图 (Connected Graph)**: 任意两个顶点之间都有路径的图。
- **连通分量 (Connected Component)**: 无向图中，所有顶点连通的最大子图。
- **强连通 (Strongly Connected)**: 有向图中，任意两个顶点之间都有双向路径。
- **弱连通 (Weakly Connected)**: 有向图中，忽略边的方向后，所有顶点连通。

- **树 (Tree)**: 连通的无环无向图。只有一个节点入度为0，其他节点入度为1
- **生成树 (Spanning Tree)**: 包含图中所有顶点的子图，是一棵树。
- **森林 (Forest)**: 无环无向图，是多棵树的集合。

- **孤立顶点 (Isolated Vertex)**: 没有连接任何边的顶点。

- **完全图 (Complete Graph)**: 任意两个顶点之间都有一条边。
- **稀疏图 (Sparse Graph)**: 边的数量远小于顶点的平方。
- **稠密图 (Dense Graph)**: 边的数量接近顶点的平方。

## 图的性质

| 性质1：无向图的邻接矩阵是对称的                              |
| ------------------------------------------------------------ |
| 性质2：第i个顶点的度：矩阵对应行的1的个数                    |
| 性质3：完全图的邻接矩阵，只有对角线上的元素是0，其他的元素全是1 |
| 性质4：有向图中，计算顶点的出度：第i行元素之和，顶点的入度：第i列的元素之和 |
| 性质5：网（即有权图）的邻接矩阵表示法：矩阵元素不再是1，而是权重，如果两个顶点没有边，则记录权重是无穷 |
| 性质6：图的邻接矩阵是唯一的                                  |

## 图的两种表示

### 邻接矩阵（数组表示法）

顶点表：一维数组，存储n个顶点的信息

邻接矩阵：二维数组，定义为两个顶点的关系

一个图的邻接矩阵表示是唯一的，适合稠密图的表示

```cpp
//图的两种存储结构
#define INF 32767				//定义∞
#define	MAXV 100				//最大顶点个数
typedef char InfoType;

//以下定义邻接矩阵类型
typedef struct
{	int no;						//顶点编号
	InfoType info;				//顶点其他信息
} VertexType;					//顶点类型
typedef struct
{	int edges[MAXV][MAXV];		//邻接矩阵数组
	int n,e;					//顶点数，边数
	VertexType vexs[MAXV];		//存放顶点信息
} MatGraph;						//完整的图邻接矩阵类型

```



### 邻接表

邻接表的表示不唯一

适合稀疏图的表示

```c++
//图的两种存储结构
#define INF 32767				//定义∞
#define	MAXV 100				//最大顶点个数
typedef char InfoType;
//以下定义邻接表类型
typedef struct ANode
{	int adjvex;					//该边的邻接点编号
	struct ANode *nextarc;		//指向下一条边的指针
	int weight;					//该边的相关信息，如权值（用整型表示）
} ArcNode;						//边结点类型
typedef struct Vnode
{	InfoType info;				//顶点其他信息
	ArcNode *firstarc;			//指向第一条边
} VNode;						//邻接表头结点类型
typedef struct 
{	VNode adjlist[MAXV];		//邻接表头结点数组
	int n,e;					//图中顶点数n和边数e
} AdjGraph;						//完整的图邻接表类型
```





### 十字链表法





## DFS遍历图

我们首先需要设置一个数组用来记录访问的节点来避免重复遍历vis数组，当vis[i]=1时说明该节点已经被访问过，vis数组的初值为0

对于初始节点v,首先访问该节点，设置vis[v]=1。

接着判断该节点的firarc指向的节点i是否为空，不为空说明该节点不是孤立节点，则访问该节点,同时设置设置vis[i]=1

接着就是循环的过程，访问i节点的firstarc指向的节点j，并且更新vis数组，直到访问到空节点







## BFS遍历图

与DFS不同的是，广度优先需要使用到队列

并且这里的vis数组不是全局变量

我们只需要把节点编号设置为队列类型就可以了

首先把初始节点v进队，访问该节点，设置vis[v]=1

进入循环，循环条件是队列q不等于空

auto t=q.front()获取当前队列的对头，访问该节点设置vis[t]=1，出队该节点

我们需要访问该节点的first指向的几点，并且循环，直到该节点的next指针为空为止，此时我们进队了队头节点相连的所有节点

循环，直到队列为空



如果使用邻接矩阵，则BFS对于每一行都要遍历，总的时间代价为O（n*n)

对于邻接表，虽然有2e个表节点，但只需要扫描e个节点就可以完成遍历，时间复杂度为o(n+e)



## 生成树

1. **一个图可以有多个不同的生成树**
2. 生成树是图的极小连通子图，一个有n个顶点的连通图的生成树有n-1条边
3. 在生成树中再加一条边必然形成回路
4. 生成树任意两个顶点间的路径唯一
5. 含有n个顶点n-1条边的图不一定是生成树
6. 最小生成树：权值和最小。最小生成树不是唯一的，但是权值唯一



### 普里姆算法

**普利姆算法和边的条数无关，特别适合稠密图求最小生成树**
$$
时间复杂度为o(v^2),v是节点个数
$$


1. **初始化**：选择一个起始顶点v作为起点，其他节点到v的边为侯选边
2. **循环迭代**：重复以下步骤（n-1c次），直到所有顶点都被加入到最小生成树中：
   - 从候选边中挑出权值最小的边加入，设该边两端的节点是v,k将k加入到集合u中
   - 考察当前v-u中的所有节点j，如果有k-j的权值小于当前节点v-j的权值，则用(k,j)取代后者为侯选边
3. **终止条件**：当所有顶点都被加入到最小生成树中时，算法终止。

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240513203409195.png" alt="image-20240513203409195" style="zoom:50%;" />

以上图为例，假设初始节点为编号为0的节点。我们还需要两个数组，lowcost和closest。其中lowcost[j]表示v-u集合中节点j到u集合的权值最小的边，closest保存u中的这个顶点

首先把节点分为了两个集合U和V-U,现在U中只有0节点一个,v有1，2，3，4，5，6

```c++
closest的值为0 0 0 0 0 0 0       //因为所有节点只有到0节点权值最小

lowset的值为0 28 / / / 10 /      //其中第一个表示0到0没有花费，/表示无穷
```

遍历lowset数组，发现是节点为5的编号到U权值最小，把5加入到U中，然后我们遍历邻接数组，发现5-4的权重比0-4的权重小

就要更新此时的数组

```
closet的值为0 0 0 5 0 0
lowcost的值为0 28 / / 25 0 /      //我们把加入最小生成树的5节点的lowset设置为0！！！
```



接着循环，直到所有节点都被加入到最小生成树中







### 克鲁斯卡尔算法

$$
时间复杂度为o(E\log_{v})
$$

**克鲁斯卡尔算法之和边数相关，特别适合稀疏图求最小生成树**

克鲁斯卡尔（Kruskal）算法是一种解决最小生成树（Minimum Spanning Tree，MST）问题的贪心算法。其基本思想是通过逐步选择图中权值最小的边，并且保证所选边不构成环，最终得到一个最小生成树。

我们需要一个Edge数组存放节点和节点之前的权值，然后把这些权值排序，按照从小到大的顺序一次连接节点，如果出现环就舍弃该边，直到有n-1条边为止

我们如何判断有没有环呢？我们给每个节点编号，起初n个节点的编号顺序是0 1 2 ...n

如果我们把1 2节点相连，则1 2节点的编号都变为1，只有当两个节点的编号不一样的时候我们才可以连接两节点，这个可以用并查集快速实现

排序部分我们使用堆排序快速实现

```
typedef struct 
{	
	int u;			//边的起始顶点
    int v;			//边的终止顶点
    int w;			//边的权值
} Edge;
```

[最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Eb41177d1/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e)

## 最短路径

### 单源最短路径-狄克斯特拉算法

![image-20240513212518776](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240513212518776.png)

节点0到其他节点的最短路径，设置dis数组表示其他节点到0节点的最短路径，集合U现在只有0节点一个

```c++
0 4 6 6 / / /     //初始值，其中/表示正无穷
```

我们发现是节点1到0的距离最小，把它加入到集合U中，此时U中有0 1

以1为中间节点，看经过节点1的其他节点到0节点的最短路径有没有发生变化，如果有就更新dis数组

```c++
0 4 5 6 11 / /     //经过节点1，结点和节点4到节点0的最短路径都变了
```

继续，在集合S中找最小节点2，加入到集合U中，看经过节点2其他节点到0节点的最短路径有没有发生改变

```c++
0 4 5 611 10 /      //节点5的dis改变了！
```



循环，直到U集合为空为止





1. 在执行中,一个顶点一旦添加到S中后,其最短路径长度不再改变。
   正是由于具有特点(1),所以 Dijkstra算法不适合含有负权值的带权图求单源最短路
2. **源点到各个顶点的最短路径的长度是递增的**

$$
时间复杂度为o(n^2)
$$



### 多源最短路径--佛洛依德算法

$$
时间复杂度为o(n^3)
$$

佛洛依德算法实际上就是一个三层循环，遍历二维数组的每一个值

我们用A[i][j]表示i到j的最短路径，并且我们计算A-1 A0 A1 A2 AN的值，分别表示把0节点加入进来A[I][J],把1节点加入进来A[I][J]，到最后所有节点都加入进来，A[I][J]就是节点i到节点J的最短路径

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240513224717924.png" alt="image-20240513224717924" style="zoom:50%;" />

### 拓扑排序

[拓扑排序 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/topo/)

```c++
int n, m;
vector<int> G[MAXN];
int in[MAXN];  // 存储每个结点的入度

bool toposort() {
  vector<int> L;
  queue<int> S;
  for (int i = 1; i <= n; i++)
    if (in[i] == 0) S.push(i);
  while (!S.empty()) {
    int u = S.front();
    S.pop();
    L.push_back(u);
    for (auto v : G[u]) {
      if (--in[v] == 0) {
        S.push(v);
      }
    }
  }
  if (L.size() == n) {
    for (auto i : L) cout << i << ' ';
    return true;
  } else {
    return false;
  }
}
```

### AOE网与关键路径

源点x,汇点y

关键路径：从源点到汇点的的所有路径中具有最大路径长度的路径

活动的最早开始时间ve（v：事件v,最早开始时间为事件x到v的最大路径长度

活动的最晚开始时间l(v)：事件v必须开始的事件被称为最晚开始时间



ve(x)=0,ve(y)=关键路径长度

vl(x)=0,vl(y)=关键路径长度

事件的vl逆序推，事件的ve正序推



求关键活动：某活动a两端对应的事件<v,w>，求v的最早开始时间ve(v)，求w的最晚开始时间vl(w)-c(a),其中c(a)是活动a的持续时间

如果vl-ve=0,则事件a是关键活动



对于工期，有四个结论：

1. 缩短某活动的的时间，整个工期不一定会缩短，比如该活动不是关键活动
2. 缩短某一关键活动，整个工期不一定会缩短，比如该活动不是所有关键路径共享的活动
3. 缩短关键路径上共享的关键活动时间，整个工期才可能缩短
4. 缩短关键路径上共享的关键活动时间d天，整个工期时间不一定缩短d天





# 查找

静态查找表：不改变查找表

动态查找表：对查找表进行操作

ASL：平均查找长度

## 线性表的查找

### 顺序查找

ASL是（n+1）/2，假设最坏情况和最好的情况，分别是1次和n次，取平均值

1. 顺序表或者线性链表的静态查找表
2. **表内元素之间无序**

```c
#include<stdio.h>
typedef int KeyType;
typedef struct
{
	KeyType key;//关键字域
	//...其他域
}ElemType;

typedef struct
{
	//顺序表结构定义
	ElemType* R;//表基址
	int length;//表长

}SSTable;//Sequential Search Table

SSTable ST;//定义顺序表ST

#include"search.h"
//顺序表的顺序查找，遍历
int Search_Seq1(SSTable ST, KeyType key)
{
	//下标从1开始
	for (int i = ST.length; i >= 1; i--)
	{
		if (ST.R[i].key == key)
		{
			return i;
		}
	}
	return 0;	
}

```

这种查找的方法，每次查找都要判断是否越界问题

改进:把带查找关键字key存入表头（哨兵，监视哨），可避免查找过程中每一步都要检测是否查找完毕，加快速度

```c
int Search_Seq4(SSTable ST, KeyType key)
{
	ST.R[0].key = key;
	int i = 0;
	for (i = ST.length; ST.R[i].key != key; i--);
	return i;	
}
```

### 折半查找法

$$
ASL_成功的概率是\log_{2}{n+1}-1\\
ASL_失败的概率是\log_{2}{n+1}\\
成功/不成功的平均的比较次数是\left\lceil\log_{2}{n+1}\right\rceil
$$



### 折半查找的判定树

课本317

### 分块查找



```c
#include <iostream>
#include <queue>
#include<stack>
#include <vector>
using namespace std;
struct node {
	vector<int> key;
	vector<int> link;
};
int func(struct node index, int b, vector<int>arr, int n, int k) {
	int s = (n + b - 1) / b;
	int l = 0, r = b - 1;
	int mid;
	while (l <= r) {
		mid = (l + r) / 2;
		if (index.key[mid] < k) l = mid + 1;
		else r = mid - 1;
	}

	int i = index.link[r + 1];
	while (i <= index.link[r + 1] + s - 1 && arr[i] != k) i++;
	if (i <= index.link[r + 1] + s - 1) return i;
	else return 0;

}
int main() {
	struct node index;
	index.key = { 14,34,66,85,100 };
	index.link = { 0,5,10,15,20 };
	vector<int>arr = { 8,14,6,9,10,22,34,18,19,31,40,38,54,66,46,71,78,68,80,85,700,94,88,96,87 };
	cout << func(index, 5, arr, 25, 80);

}

```



### 查找方法的比较

|          | 顺序查找         | 折半查找 | 分块查找         |
| -------- | ---------------- | -------- | ---------------- |
| ASL      | 最大             | 最小     | 中间             |
| 表结构   | 有序表、无序表   | 有序表   | 有序表、无序表   |
| 存储结构 | 顺序表、线性链表 | 顺序表   | 顺序表、线性链表 |

## 树表的查找

### 二叉排序树

**二叉排序树又被称为二叉搜索树，二叉查找树**

定义：二叉搜索树（Binary Search Tree，BST）是一种二叉树数据结构，其中每个节点都有最多两个子节点，左子节点的值小于当前节点的值，而右子节点的值大于当前节点的值。**这个性质使得在二叉搜索树中可以快速地进行查找、插入和删除操作**。

(1)若其左子树非空，则左子树上所有结点的值均小于根结点的值

(2)若其右子树非空，则右子树上所有结点的值均大于根结点的值

(3)其左右子树本身又各是一棵二又排序树

**性质：按照中序遍历是得到的是递增序列**

**二叉排序树的查找分析**

查找操作的效率与二叉排序树的高度密切相关。

- **最优情况**：树是完全平衡的二叉树，高度为 𝑂(log⁡𝑛)，查找时间复杂度为 𝑂(log⁡𝑛)。
- **最差情况**：树退化为链表（即每个节点只有一个子节点），高度为 𝑂(𝑛)，查找时间复杂度为 𝑂(𝑛)。

### **二叉排序树的实现**

```c
#define _CRT_SECURE_NO_WARNINGS
#include"tree.h"

void InOrderTraverse(BiTree T)
{
    if (T != NULL)
    {
        InOrderTraverse(T->lchild);
        printf("%d ", T->data.key);
        InOrderTraverse(T->rchild);
    }
}

//返回的是节点指针
BiTree SearchBST(BiTree T, KeyType key)
{
    if ((!T) || key == T->data.key)
    {
        return T;
    }
    else if (key < T->data.key)
        return SearchBST(T->lchild, key);
    else
        return SearchBST(T->rchild, key);
}


BiTree Createnode(int arr, char ch)
{
    BiTree temp = (BiTree)malloc(sizeof(BiNode));
    if (temp == NULL)
    {
        return NULL;
    }
    temp->data.key = arr;
    temp->data.otherinfo = ch;
    temp->lchild = temp->rchild = NULL;
    return temp;

}


BiTree Insert(BiTree T, int arr, char ch)
{
    if (T == NULL)
    {
        return Createnode(arr, ch);
    }

    if (T->data.key > arr)
    {
        T->lchild = Insert(T->lchild, arr, ch);
    }
    else if (arr > T->data.key)
    {
        T->rchild = Insert(T->rchild, arr, ch);
    }

    return T;
}



void FreeTree(BiTree root)
{
    if (root != NULL)
    {
        FreeTree(root->lchild);
        FreeTree(root->rchild);
        free(root);
    }
}



// 删除节点的函数实现
BiTree DeleteNode(BiTree T, KeyType key)
{
    if (!T)
    {
        printf("Key not found\n");
        return NULL;
    }

    if (key < T->data.key)
    {
        T->lchild = DeleteNode(T->lchild, key);
    }
    else if (key > T->data.key)
    {
        T->rchild = DeleteNode(T->rchild, key);
    }
    else
    {
        // 找到要删除的节点

        // 情况一：无子节点或只有一个子节点
        if (T->lchild == NULL)
        {
            BiTree temp = T->rchild;
            free(T);
            return temp;
        }
        else if (T->rchild == NULL)
        {
            BiTree temp = T->lchild;
            free(T);
            return temp;
        }

        // 情况二：有两个子节点
        BiTree temp = T->rchild;  // 找到右子树的最小节点
        while (temp->lchild != NULL)
        {
            temp = temp->lchild;
        }

        // 将右子树的最小节点的值复制给当前节点
        T->data = temp->data;

        // 删除右子树的最小节点
        T->rchild = DeleteNode(T->rchild, temp->data.key);
    }

    return T;
}

// 在 main 函数中使用 DeleteNode 函数
int main()
{
    int arr[7] = { 45, 24, 53, 45, 12, 24, 90 };
    BiTree T = NULL;

    for (int i = 0; i < 7; i++)
    {
        T = Insert(T, arr[i], 'a');
    }

    printf("Original Binary Search Tree:\n");
    InOrderTraverse(T);

    // 删除节点 45
    KeyType keyToDelete = 45;
    T = DeleteNode(T, keyToDelete);

    printf("\nBinary Search Tree after deleting node with key %d:\n", keyToDelete);
    InOrderTraverse(T);

    FreeTree(T);
    return 0;
}
```

### 二叉排序树节点的删除

删除叶子节点：直接删去该节点

被删除的节点只有左子树或者右子树：用其左子树或者其右子树替换它，其双亲节点对应的指针域改为“指向被删除节点的左子树或者右子树”

被删除的节点既有左子树，又有右子树：以其中序节点的前驱节点替换之，然后再删除该前驱节点;(前驱是左子树中最大的节点)或者是用中序遍历的后续节点替换它，然后再删除后续节点（后续是右子树中最小的节点）



```c
//二叉排序树算法
#include <stdio.h>
#include <malloc.h>
typedef int KeyType;
typedef char InfoType[10];
typedef struct node
{
	KeyType key;              		//关键字项
	InfoType data;             		//其他数据域
	struct node *lchild,*rchild;	//左右孩子指针
} BSTNode;           				//二叉排序树结点类型
BSTNode* InsertBST(BSTNode* bt,KeyType k)	//在二叉排序树bt中插入一个关键字为k的结点
{	if (bt==NULL)								//原树为空
	{	bt=(BSTNode *)malloc(sizeof(BSTNode));	//新建根结点bt 
		bt->key=k; bt->lchild=bt->rchild=NULL;
	}
	else if (k<bt->key) 
		bt->lchild=InsertBST(bt->lchild,k);	//插入到左子树中
	else if(k>bt->key)
		bt->rchild=InsertBST(bt->rchild,k);	//插入到右子树中
	return bt;								//返回插入后二叉排序树的根结点 
}

BSTNode *CreateBST(KeyType A[],int n)	//创建二叉排序树
//返回BST树根结点指针
{	BSTNode *bt=NULL;				//初始时bt为空树
	int i=0;
	while (i<n)
	{	bt=InsertBST(bt,A[i]);			//将关键字A[i]插入二叉排序树bt中
		i++;
	}
	return bt;						//返回建立的二叉排序树的根指针
}

void DispBST(BSTNode *bt)		//输出一棵排序二叉树
{
	if (bt!=NULL)
	{	printf("%d",bt->key);
		if (bt->lchild!=NULL || bt->rchild!=NULL)
		{	printf("(");						//有孩子结点时才输出(
			DispBST(bt->lchild);				//递归处理左子树
			if (bt->rchild!=NULL) printf(",");	//有右孩子结点时才输出,
			DispBST(bt->rchild);				//递归处理右子树
			printf(")");						//有孩子结点时才输出)
		}
	}
}
BSTNode *SearchBST(BSTNode *bt,KeyType k)	//递归算法：在二叉排序树bt中查找关键字为k的结点
{ 
    if (bt==NULL || bt->key==k)      	//递归终结条件
		return bt;
	if (k<bt->key)
       	return SearchBST(bt->lchild,k);  //在左子树中递归查找
    else
     	return SearchBST(bt->rchild,k);  //在右子树中递归查找
}
BSTNode *SearchBST1(BSTNode *bt,KeyType k)	//非递归算法：在二叉排序树bt中查找关键字为k的结点
{ 
	BSTNode* p=bt;
	while(p!=NULL)
    { 	if(p->key==k) break;                 //找到关键字为k的结点p
        else if(k<p->key)
			p=p->lchild;
        else
			p=p->rchild;
    }
    return p;
}

BSTNode *DeleteBST(BSTNode *bt,KeyType k)	//在bt中删除关键字为k的结点
{	if(bt==NULL) return bt;
    BSTNode* p=bt,*f=NULL;      			//f指向被删结点p的双亲结点
    while(p!=NULL)                          //查找被删结点p，其双亲是f结点 
    {
	 	if(p->key==k) break;                 //找到被删结点p时退出循环
    	f=p;
        if(k<p->key)
			p=p->lchild;
        else
			p=p->rchild;
    }
    if(p==NULL) return bt;                        //没有找到被删除结点p，返回bt
    if(p->lchild==NULL && p->rchild==NULL)     		//情况(1)-结点p是叶子结点
    {	if(p==bt)                                   //结点p是根结点
        	bt=NULL;
    	else                                        //结点p不是根结点
        {	if(f->lchild==p)						//结点p是结点f的左孩子 
				f->lchild=NULL;
            else									//结点p是结点f的右孩子
				f->rchild=NULL;
    	}
        free(p);
	}
    else if(p->rchild==NULL)                           //情况(2)-结点p的右子树为空
    {
    	if(f==NULL)	 
	    	bt=bt->lchild;                       		//结点p是根结点bt，用其左孩子替代bt 
    	else                        				//结点p存在双亲f（p不是根结点） 
        {	if(f->lchild==p)							//结点p是结点f的左孩子 
				f->lchild=p->lchild;					//用结点p的左孩子替代结点p 
            else										//结点p是结点f的右孩子
				f->rchild=p->lchild;					//用结点p的左孩子替代结点p
    	}
    	free(p);
	}
    else if (p->lchild==NULL)                            //情况(3)-结点p的左子树为空
    {
    	if(f==NULL)
	        bt=bt->rchild;                  			//结点p是根结点bt，用其右孩子替代bt
		else                        				//结点p存在双亲f（p不是根结点）
        {	if(f->lchild==p)							//结点p是结点f的左孩子 
				f->lchild=p->rchild;					//用结点p的右孩子替代结点p
            else										//结点p是结点f的右孩子
				f->rchild=p->rchild;					//用结点p的右孩子替代结点p
    	}
        free(p);
	}
    else                                                  //情况(4)-结点p有左右孩子的情况
    {	BSTNode* q=p->lchild;                				//q指向结点p的左孩子结点
        f=p;                               					//f指向结点q的双亲结点
        while(q->rchild!=NULL)                   			//找到结点p的左孩子的最右下结点q
        {	f=q;
            q=q->rchild;
    	}
        p->key=q->key;                  		     	//将结点p的值用结点q的值替换
        if(q==f->lchild)								//删除结点q(用结点q的左孩子替代结点q)
			f->lchild=q->lchild;           
        else
			f->rchild=q->lchild;
        free(q);
    }
    return bt;
}

void DestroyBST(BSTNode *&bt)		//销毁二叉排序树bt
{
	if (bt!=NULL)
	{
		DestroyBST(bt->lchild);
		DestroyBST(bt->rchild);
		free(bt);
	}
}
int main()
{
	BSTNode *bt,*p,*f;
	KeyType a[]={5,2,1,6,7,4,8,3,9};
	int n=sizeof(a)/sizeof(a[0]);
	bt=CreateBST(a,n);
	printf("BST:");DispBST(bt);printf("\n");
	int x=5;
	printf("删除%d结点\n",x);
	if (SearchBST(bt,x)!=NULL)
	{
		DeleteBST(bt,x);
		printf("BST:");DispBST(bt);printf("\n");
	}
	DestroyBST(bt);
	return 1;
}

/*
int main()
{
	BSTNode *bt,*p,*f;
	int n=12,x=46;
	KeyType a[]={25,18,46,2,53,39,32,4,74,67,60,11};
	bt=CreateBST(a,n);
	printf("BST:");DispBST(bt);printf("\n");
	printf("删除%d结点\n",x);
	if (SearchBST(bt,x)!=NULL)
	{
		DeleteBST(bt,x);
		printf("BST:");DispBST(bt);printf("\n");
	}
	DestroyBST(bt);
	return 1;
}
*/
```



### 平衡二叉树(AVL)

$$
由n个关键字构造的二叉排序树高度为 \left\lceil\log_{2}{(n+1)}\right\rceil - n，查找效率为O(\log_{2}{n})～O(n)\\
由n个关键字构造的平衡二叉树高度为O(\log_{2}{n}),查找效率为O(\log_{2}{n})
$$

平衡二叉树首先要是二叉排序树

左子树和右子树的高度只差小于等于1

左子树和右子树也需要是平衡二叉树

平衡因子：左子树的高度减去右子树的高度，平衡因子只能是0，-1，1

失衡节点：如果不止一个失衡节点，**就找一个最小的失衡子树，这个节点是失衡节点**

当前二叉树的深度等于左子树的深度和右子树的高度之中比较大的那一个

**平衡二叉树的分析与调整**

![image-20231211210833695](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231211210833695.png)



```c++
#include <iostream>
#include <vector>

class TreeNode {
public:
    int data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

// 中序遍历BST，将节点值存储在数组中
void inorderTraversal(TreeNode* root, std::vector<int>& values) {
    if (root) {
        inorderTraversal(root->left, values);
        values.push_back(root->data);
        inorderTraversal(root->right, values);
    }
}

// 通过中序遍历的有序数组构建平衡树
TreeNode* buildBalancedTree(std::vector<int>& values, int start, int end) {
    if (start > end) {
        return nullptr;
    }

    int mid = (start + end) / 2;
    TreeNode* root = new TreeNode(values[mid]);
    root->left = buildBalancedTree(values, start, mid - 1);
    root->right = buildBalancedTree(values, mid + 1, end);

    return root;
}

// 将BST转化为平衡树
TreeNode* convertToBalancedTree(TreeNode* root) {
    std::vector<int> values;
    inorderTraversal(root, values);

    int n = values.size();
    return buildBalancedTree(values, 0, n - 1);
}

// 辅助函数，打印中序遍历结果
void printInorder(TreeNode* root) {
    if (root) {
        printInorder(root->left);
        std::cout << root->data << " ";
        printInorder(root->right);
    }
}

int main() {
    // 创建一个简单的BST
    TreeNode* bstRoot = new TreeNode(1);
    bstRoot->left = new TreeNode(2);
    bstRoot->right = new TreeNode(3);

    std::cout << "Inorder Traversal of Original BST: ";
    printInorder(bstRoot);
    std::cout << std::endl;

    // 将BST转化为平衡树
    TreeNode* balancedRoot = convertToBalancedTree(bstRoot);

    std::cout << "Inorder Traversal of Balanced Tree: ";
    printInorder(balancedRoot);
    std::cout << std::endl;

    return 0;
}

```





### 红黑树

红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree）。它在每个节点上添加了额外的信息，用于表示节点的颜色（红色或黑色），并通过一定的规则保持树的平衡，从而确保在最坏情况下的操作效率也是对数级别的。

以下是红黑树的主要性质：

1. **节点颜色：** 每个节点要么是红色，要么是黑色。
2. **根节点颜色：** 根节点是黑色的。
3. **叶子节点（NIL节点）颜色：** 所有叶子节点都是黑色的（通常用 NULL 或特殊的 NIL 节点表示）。
4. **相邻节点颜色：** 如果一个节点是红色的，则其子节点必须是黑色的。
5. **路径黑色节点数相等：** 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点，这称为黑高（Black-Height）。

通过这些规则，红黑树保证了在进行插入、删除等操作时，树的高度保持在对数级别，从而保持了查找、插入和删除的性能在最坏情况下的可控范围。

红黑树广泛应用于实现诸如C++ STL中的`std::set`和`std::map`等关联容器，以及数据库索引等领域。

## 散列表(哈希)

**定义：**在计算机科学中，哈希（Hash）是一种将数据映射到固定大小的值的过程。哈希函数将输入（或"键"）转换为一个固定长度的数字或字符串，通常称为哈希码（hash code）或哈希值。哈希函数的设计目标是尽可能减少碰撞，即不同的输入映射到相同的哈希值的情况。



**装填因子**：哈希表中已经存在的元素个数n与哈希表长度m的比值 装填因子越少哈希冲突出现的可能性越少，装填因子在0.6~0.9最佳

**哈希冲突**：是指两个关键字有一个哈希值的情况，具有相同哈希地址的元素被称为同义词



### 哈希函数

### 直接定址法

h(k)=k+c



### 除留余数法

h(k)=k mod p

### 处理冲突的方法

#### 开放地址法

开放地址法又分为线性探测和二次探测



线性探测是出现冲突，就往后找是否有未使用的地址。第一次是d mod p  出现冲突则是  d+1  mod p   第二次则是 d+2  mod p   第三次是d+3  mod p



平方探测是出现冲突，第一次是d mod p  第二次是d+1  mod p  第三次是d-1  mod p 第四次是d+4  mod p  第五次是d-4 mod p



#### 链地址法

#### 哈希表的运算算法（拉链法）

##### 插入及建表算法

```c
//#include <iostream>
//#include <vector>
//#include <list>
//
//template <typename K, typename V>
//class HashNode {
//public:
//    K key;
//    V value;
//    HashNode* next;
//
//    HashNode(const K& key, const V& value) : key(key), value(value), next(nullptr) {}
//};
//
//
//
//template <typename K, typename V>
//class HashTable {
//private:
//    std::vector<HashNode<K, V>*> table;
//    int capacity;
//    int size;
//
//
//    //生成对应哈希桶的下标
//    int hashFunction(const K& key) {
//        return std::hash<K>{}(key) % capacity;
//    }
//
//public:
//    HashTable(int capacity = 10) : capacity(capacity), size(0) {
//        table.resize(capacity, nullptr);
//    }
//
//    ~HashTable() {
//        for (int i = 0; i < capacity; ++i) {
//            HashNode<K, V>* entry = table[i];
//            while (entry != nullptr) {
//                HashNode<K, V>* prev = entry;
//                entry = entry->next;
//                delete prev;
//            }
//        }
//    }
//
//    void insert(const K& key, const V& value) {
//        int hashIndex = hashFunction(key);
//        HashNode<K, V>* prev = nullptr;
//        HashNode<K, V>* entry = table[hashIndex];
//
//        while (entry != nullptr && entry->key != key) {
//            prev = entry;
//            entry = entry->next;
//        }
//
//       
//        if (entry == nullptr) {
//            entry = new HashNode<K, V>(key, value);
//            if (prev == nullptr) {
//                table[hashIndex] = entry;
//            }
//            else {
//                prev->next = entry;
//            }
//            ++size;
//        }
//        else {
//            //已经存在就更新
//            entry->value = value;
//        }
//    }
//
//    V get(const K& key) {
//        int hashIndex = hashFunction(key);
//        HashNode<K, V>* entry = table[hashIndex];
//
//        while (entry != nullptr) {
//            if (entry->key == key) {
//                return entry->value;
//            }
//            entry = entry->next;
//        }
//
//        throw std::runtime_error("Key not found");
//    }
//
//    void remove(const K& key) {
//        int hashIndex = hashFunction(key);
//        HashNode<K, V>* prev = nullptr;
//        HashNode<K, V>* entry = table[hashIndex];
//
//        while (entry != nullptr && entry->key != key) {
//            prev = entry;
//            entry = entry->next;
//        }
//
//        //没找到对应节点
//        if (entry == nullptr) {
//            throw std::runtime_error("Key not found");
//        }
//        else {
//
//            //该节点是桶内第一个节点
//            if (prev == nullptr) {
//                table[hashIndex] = entry->next;
//            }
//            else {
//                prev->next = entry->next;
//            }
//            delete entry;
//            --size;
//        }
//    }
//
//    int getSize() const {
//        return size;
//    }
//
//    bool isEmpty() const {
//        return size == 0;
//    }
//};
//
//int main() {
//    HashTable<std::string, int> hashTable(10);
//
//    hashTable.insert("one", 1);
//    hashTable.insert("two", 2);
//    hashTable.insert("three", 3);
//
//    try {
//        std::cout << "Value for key 'one': " << hashTable.get("one") << std::endl;
//        std::cout << "Value for key 'two': " << hashTable.get("two") << std::endl;
//        std::cout << "Value for key 'three': " << hashTable.get("three") << std::endl;
//
//        hashTable.remove("two");
//        std::cout << "Value for key 'two' after removal: " << hashTable.get("two") << std::endl;
//    }
//    catch (const std::runtime_error& e) {
//        std::cout << e.what() << std::endl;
//    }
//
//    return 0;
//}
//
#include<iostream>
#include<vector>
#include<list>
using namespace std;
template <typename K,typename V>
class HashNode {
public:
	K key;
	V value;
	HashNode* next;
	//成员初始化列表构造方式，它用于在类的构造函数中初始化类的成员变量。
	//在成员初始化列表中，通过逗号分隔每个成员的初始化操作，并以冒号开头，跟在构造函数的声明之后。
	//在这种方式下，不需要在构造函数的函数体中再次赋值。
	HashNode(const K& key, const V& value) : key(key), value(value), next(nullptr) {};   //引用传值就不会有临时变量的产生
};

template <typename K,typename V>
class HashTable {
private:
	vector<HashNode<K, V>*>Table;  //哈希桶
	int capacity;
	int size;

	int HashFunction(const K&key) {
		//std::hash 提供了一个 operator() 成员函数，用于计算给定参数的哈希值。
		return hash<K>{}(key) % capacity;
	}
public:
	HashTable(int capacity = 10) : capacity (capacity), size(0){
		Table.resize(capacity,nullptr);
	}

	~HashTable() {
		for (int i = 0; i < capacity; i++) {
			HashNode<K, V>* entry = Table[i];
			while (entry != nullptr) {
				HashNode<K, V>*prev = entry;
				entry = entry->next;
				delete prev;
			}
		}	
	}

	void insert(const K& key, const V& value) {
		int index = HashFunction(key);
		HashNode<K, V>*entry = Table[index];
		HashNode<K, V>* prev=nullptr;
		while (entry != nullptr&&entry->key!=key) {
			prev = entry;
			entry = entry->next;
		}

		if (entry == nullptr) {//说明该值在哈希桶中不存在，要新建立节点插入
			entry = new HashNode<K, V>(key, value);
			if (prev == nullptr) {
				Table[index] = entry;
			}
			else {
				prev->next = entry;
			}
			++size;
		}

		else {
			entry->value = value;
		}
	}

	V get(const K& key) {
		int index = HashFunction(key);
		HashNode<K, V>* entry = Table[index];
		HashNode<K, V>* prev =nullptr;
		//找到对应节点
		while (entry != nullptr && entry->key != key) {
			prev = entry;
			entry = entry->next;
		}

		if (entry == nullptr) {//说明该值在哈希桶中不存在，要新建立节点插入
			throw runtime_error("key not found");
		}

		else {
			return entry->value;
		}
	}

	void remove(const K& key) {
		int index = HashFunction(key);
		HashNode<K, V>* entry = Table[index];
		HashNode<K, V>* prev = nullptr;
		while (entry != nullptr && entry->key != key) {
			prev = entry;
			entry = entry->next;
		}

		if (entry != nullptr) {
			if (prev == nullptr) {
				Table[index] = entry->next;
			}
			//哈希桶中有该节点
			else {
				prev->next = entry->next;
			}
			delete entry;
			--size;
		}

		else throw runtime_error("key not found");
	}

	//这意味着在调用这个函数时，该函数不能修改调用它的对象的任何非静态成员变量。
	int getSize() const {
		return size;
	}

	bool isEmpty() const {
		return size == 0;
	}
};

int main() {
	HashTable<std::string, int> hashTable(10);

	hashTable.insert("one", 1);
	hashTable.insert("two", 2);
	hashTable.insert("three", 3);

	try {
		cout << "Value for key 'one': " << hashTable.get("one") <<endl;
		cout << "Value for key 'two': " << hashTable.get("two") <<endl;
		cout << "Value for key 'three': " << hashTable.get("three") <<endl;

		hashTable.remove("two");
		cout << "Value for key 'two' after removal: " << hashTable.get("two") <<endl;
	}

	catch (const std::runtime_error& e) {
		cout << e.what() <<endl;
	}

	return 0;
}
```



##### 查找性能分析

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240528113246266.png" alt="image-20240528113246266" style="zoom: 67%;" />



![image-20240528113333359](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240528113333359.png)



#### 时间复杂度：

1. **插入（Insertion）**：平均情况下，对于哈希表的插入操作，哈希算法的时间复杂度为 O(1)。但在最坏情况下，当哈希冲突发生时，插入的时间复杂度可能变为 O(n)，其中 n 是槽位的数量。
2. **查找（Lookup）**：在平均情况下，哈希表查找的时间复杂度也为 O(1)，因为哈希表通过哈希函数直接定位到存储位置。但在发生冲突时，查找的时间复杂度可能会增加。
3. **删除（Deletion）**：与插入类似，平均情况下删除的时间复杂度为 O(1)，但在最坏情况下可能为 O(n)。

#### 空间复杂度：

1. **存储空间**：哈希表的存储空间主要受两个因素影响：槽位的数量和哈希表中实际存储的元素数量。通常情况下，哈希表的空间复杂度为 O(m + n)，其中 m 是槽位的数量，n 是实际存储的元素数量。

### uthash库

#### 使用uthash的基本步骤

1. **包含头文件：** 将 uthash 的头文件 `uthash.h` 包含到你的源文件中。

   ```c
   include "uthash.h"
   ```

2. **定义结构体：** 在你的结构体定义中使用 `UT_hash_handle` 宏，将结构体变为哈希表节点。，此时，这个结构体就变成了一个哈希表的节点

   ```c
   struct hashTable {
       int key;
       UT_hash_handle hh;
   };
   ```

3. **初始化哈希表：** 在你的代码中创建一个指向哈希表头部的指针。

   ```c
   struct hashTable *hashTable = NULL;
   ```

4. **使用宏操作哈希表：** 使用 `HASH_ADD_INT`、`HASH_FIND_INT`、`HASH_DEL`、`HASH_ITER` 等宏进行哈希表的插入、查找、删除和遍历等操作。

   ```c
   struct hashTable *newElement = malloc(sizeof(struct hashTable));
   newElement->key = 42;
   HASH_ADD_INT(hashTable, key, newElement);
   
   struct hashTable *element;
   int searchKey = 42;
   HASH_FIND_INT(hashTable, &searchKey, element);
   
   HASH_DEL(hashTable, element);
   free(element);
   
   struct hashTable *currentElement, *tmp;
   HASH_ITER(hh, hashTable, currentElement, tmp) {
       // 对当前元素进行操作
   }
   
   void freeHashtable() {
       struct hashTable *current_node, *tmp;
       HASH_ITER(hh, hashtable, current_node) {
           HASH_DEL(hashtable, current_node);
           free(current_node);
       }
   }
   
   
   //在程序结束时，需要释放整个哈希表中所有节点的内存。这可以通过遍历哈希表，使用 HASH_DEL 宏删除每个节点，并释放其内存。
   
   //在使用哈希表的程序结束时，调用 freeHashtable 函数可以释放所有节点的内存。
   
   //确保在释放内存之前不再需要相应的数据，并注意释放的顺序以避免悬挂指针的问题。
   ```

5. **编译：** 确保在编译时链接上 uthash 库。

   如果你的项目使用了 Makefile，可以在 Makefile 中添加链接标志，类似于：

   ```c
   your_program: your_program.c uthash.h
       gcc -o your_program your_program.c -I/path/to/uthash
   
   ```

   其中 `/path/to/uthash` 是 uthash 头文件所在的路径。

6. **运行：** 编译成功后，你就可以运行你的程序了。

#### HASH_ADD_INT

`HASH_ADD_INT` 是 uthash 库中用于向哈希表添加元素的宏，适用于整数键值的情况。它的参数包括：

1. **表名（head）：** 这是哈希表的名称，即你之前使用 `HASH_ADD_INT` 宏定义的哈希表的名称。
2. **元素类型的指针（hh）：** 这是指向哈希表句柄的指针，通常是你的数据结构中的一个字段，它用于链接哈希表中的元素。
3. **键名（keyname）：** 这是哈希表中元素的键名，即你的数据结构中的一个字段的名称，它存储了元素的键值。
4. **元素指针（additem）：** 这是指向要添加到哈希表的元素的指针。

在代码中，`HASH_ADD_INT` 的一般用法是：

```c
void add_user(int user_id, char *name) {
    struct my_struct *s;

    s = malloc(sizeof *s);
    s->id = user_id;
    strcpy(s->name, name);
    HASH_ADD_INT(users, id, s);  /* id: name of key field */
}

```

- The first parameter to `HASH_ADD_INT` is the hash table, and the second parameter is the *name* of the key field. Here, this is `id`. The last parameter is a pointer to the structure being added.

#### HASH_FIND_INT

```c
struct my_struct *find_user(int user_id) {
    struct my_struct *s;

    HASH_FIND_INT(users, &user_id, s);  /* s: output pointer */
    return s;
}
/*
Here, the hash table is users, and &user_id points to the key (an integer in this case). Last, s is the output variable of HASH_FIND_INT. The final result is that s points to the structure with the given key, or is NULL if the key wasn’t found in the hash.*/
//会返回相同键值的最后一个节点
```

#### HASH_COUNT

```c
unsigned int num_users;
num_users = HASH_COUNT(users);
printf("there are %u users\n", num_users);

/*Incidentally, this works even if the list head (here, users) is NULL, in which case the count is 0.*/
```

#### HASH_ITER

You can loop over the items in the hash by starting from the beginning and following the `hh.next` pointer.

Iterating over all the items in a hash

```
void print_users() {
    struct my_struct *s;

    for (s = users; s != NULL; s = s->hh.next) {
        printf("user id %d: name %s\n", s->id, s->name);
    }
}
```

There is also an `hh.prev` pointer you could use to iterate backwards through the hash, starting from any known item.



Deletion-safe iteration

In the example above, it would not be safe to delete and free `s` in the body of the *for* loop, (because `s` is dereferenced each time the loop iterates). This is easy to rewrite correctly (by copying the `s->hh.next` pointer to a temporary variable *before* freeing `s`), but it comes up often enough that a deletion-safe iteration macro, `HASH_ITER`, is included. It expands to a `for`-loop header. Here is how it could be used to rewrite the last example:

```
struct my_struct *s, *tmp;
HASH_ITER(hh, users, s, tmp) {
    printf("user id %d: name %s\n", s->id, s->name);
    /* ... it is safe to delete and free s here */
}
```

- `hh`: 这是你的数据结构中用于链接哈希表中元素的句柄字段的名称。在你的结构体中，你可能会有类似于 `UT_hash_handle hh;` 的字段。
- `head`: 这是哈希表的头指针，即哈希表的名称。在 `HASH_ITER` 中，`head` 是哈希表的指针，例如 `users`。
- `s`: 这是一个用于保存当前元素指针的变量。在每次迭代中，`s` 都会指向当前元素。
- `tmp`: 这是一个临时变量，用于在迭代过程中保存下一个元素的指针。你不需要手动定义 `tmp`，它在 `HASH_ITER` 宏内部使用。

在迭代过程中，`HASH_ITER` 宏会将 `s` 指向当前元素，然后将 `tmp` 设置为下一个元素的指针。这样，在下一次迭代中，`s` 就会指向新的当前元素，而 `tmp` 则会保存下一个元素的指针。这个过程会一直重复，直到遍历完整个哈希表。

####  HASH_DEL

```c
void delete_user(struct my_struct *user) {
    HASH_DEL(users, user);  /* user: pointer to deletee */
    free(user);             /* optional; it's up to you! */
}
```

#### 释放空间

注意以下释放空间的时候，不可以只释放头节点，因为哈希表相当于一个邻接表，二级指针需要多次释放

```c
MY* p, * tmpt;
HASH_ITER(hh, hashhead,p, tmpt) {
    HASH_DEL(hashhead, p);
    free(p);
}
```







# 排序排列

## 内排序

**内排序**是指在计算机的内存中进行的排序操作，即所有数据在排序过程中都存放在内存中，不需要借助外部存储（如硬盘、磁带等）。内排序适用于数据量较小、能够完全加载到内存中的情况。与之相对的是**外排序**，当数据量较大，无法一次性全部加载到内存时，需要借助外部存储进行排序操作。

## 稳定排序

排序的稳定性只对结构类型数据排序有意义

稳定的排序算法是指在排序过程中，对于具有相同排序键值的元素，它们在排序后的序列中的相对位置保持不变。换句话说，如果有两个元素A和B，在原始序列中A在B之前，而且它们的排序键值相同，那么在排序后，A仍然会在B之前。

稳定性对于某些应用场景很重要，比如在对多个属性进行排序时，如果希望保持先前的排序顺序，就需要使用稳定的排序算法。一些常见的稳定排序算法包括冒泡排序、插入排序和归并排序。而不稳定的排序算法，例如快速排序，可能会改变相等元素的相对位置。



## 插入排序

插入排序是一种简单直观的排序算法，适用于小规模数据或部分有序的数据。其基本思想是将一个元素插入到已经排好序的部分，不断扩大已排序部分的范围，直到整个数组有序为止。

### 直接插入排序

1. 从第一个元素开始，假定它已经是有序的。
2. 取出下一个元素，在已经排序的部分序列中从后向前扫描。
3. 如果已排序部分的元素大于新元素，则将已排序部分的元素向后移动一位。
4. 重复步骤3，直到找到已排序部分中小于或等于新元素的位置。
5. 将新元素插入到该位置。
6. 重复步骤2-5，直到所有元素均插入完成。



插入排序只能保证前一段序列是有序的，但不能保证前k个数据是最小的前k个



```c++
#include <iostream>
#include <vector>

// 二分查找，找到插入位置


// 优化的插入排序
void optimizedInsertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        if (arr[i - 1] > arr[i]) {
            int j = i - 1;
            int key = arr[i];
            do {
                arr[j + 1] = arr[j];
                j--;
            } while (j >= 0 && arr[j] > key);
            arr[j + 1] = key;
            
        }
      
    }
}

int main() {
    std::vector<int> arr = { 29, 10, 14, 37, 13, 20, 44, 23 };
    std::cout << "Original array: ";
    for (int x : arr) std::cout << x << " ";
    std::cout << std::endl;

    optimizedInsertionSort(arr);

    std::cout << "Sorted array: ";
    for (int x : arr) std::cout << x << " ";
    std::cout << std::endl;

    return 0;
}

```

**算法分析**

适用于基本有序的数组，数据量比较少，又希望是稳定排序的时候可以使用插入排序


| 时间复杂度 |          |          | 空间复杂度 | 稳定性 |
| ---------- | -------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况 | 平均情况 | 辅助存储   |        |
| o(n)       | o(n^2)   | o(n^2)   | o(1)       | 稳定   |



### 折半插入排序

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
void BinSearchInsertSort(vector<int>&array) {
	int n = array.size();
	array.insert(array.begin(), INT_MAX);
	for (int i = 2; i <= n; i++) {
		if (array[i] < array[i-1]) {
			array[0] = array[i];
			int low = 0, high = i, j = i - 1;
			while (low +1 != high) {
				int mid = (low + high) / 2;
				if (array[mid] <= array[0]) low = mid;
				else high = mid;
			}

			for (j; j > low; j--) {
				array[j + 1] = array[j];
			}
			array[j+1] = array[0];	
		}
	}

	array.erase(array.begin());

}
int main() {
	vector<int>array = { 1,5,8,9,4,2,6,5,10,-1 };
	BinSearchInsertSort(array);
	auto printElement = [](int element) {
		cout << element << ' ';
		};

	for_each(array.begin(), array.end(), printElement);

}
```

**算法分析**

适用于数据量中等并且数据接近有序的时候

折半查找比顺序查找要快，所以折半查找插入排序的平均性能比直接插入排序要快

它所需要的关键码比较次数与数组序列的初始排序无关，仅依赖于对象个数
$$
需要经过log2^i +1次关键码比较才能确定它的位置
$$
当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差;
在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少



| 时间复杂度 |          |          | 空间复杂度 | 稳定性 |
| ---------- | -------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况 | 平均情况 | 辅助存储   |        |
| o(n)       | o(n^2)   | o(n^2)   | o(1)       | 稳定   |



### 希尔排序

希尔排序是在插入排序的基础上，我们知道插入排序对于数组已经大致有序的数组来说效率很高，所以我们先让数组变得大致有序。对于数据量比较大的数组来说，利用分块的思想，我们先分块进行插入排序，比如我们先对数组下标为5 10 15 20...进行排序，此时数组变得比以前有序了，接着再对3 6 9 12..进行排序..一次类推，最后对1 2 3 4 5...进行排序

最后一次只需要少量移动增量序列必须是递减的最后一个必须是1
**增量序列应该是互质的**



```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
void InsertSort(vector<int>& array) {
	int n = array.size();
	for (int i = 2; i <= n; i++) {
		if (array[i] < array[i - 1]) {
			array[0] = array[i];
			int j = i - 1;
			for (j; j >= 0 && array[j] > array[0]; j--) {
				array[j + 1] = array[j];
			}
			array[j + 1] = array[0];
		}
	}

	array.erase(array.begin());

}


void Shellnsert(vector<int>& array, int dk) {
	int n = array.size();
	//注意插入排序是从数组的第二个元素开始的
	for (int i = dk + 1; i < n; i++) {
		if (array[i] < array[i - dk]) {
			array[0] = array[i];
			int j = i - dk;
			for (j; j > 0&&array[j]>array[0]; j -= dk) {
				array[j + dk] = array[j];
			}
			array[j + dk] = array[0];
		}
	}
}
void ShellSort(vector<int>&array,int data[],int t) {
	array.insert(array.begin(), INT_MAX);
	for (int i = 0; i < t;i++) {
		Shellnsert(array, data[i]);
	}
	array.erase(array.begin());
}
int main() {
	vector<int>array = { 1,5,8,9,4,2,6,5,10,-1 };
	int data[] = { 5,3,1 };
	ShellSort(array,data,3);
	auto printElement = [](int element) {
		cout << element << ' ';
		};

	for_each(array.begin(), array.end(), printElement);

}
```



**算法分析**

适用于中小规模数据集

| 时间复杂度 |          |          | 空间复杂度 | 稳定性 |
| ---------- | -------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况 | 平均情况 | 辅助存储   |        |
| o(n)       | o(n^2)   | o(n^1.3) | o(1)       | 不稳定 |

**时间复杂度**

通常情况下，希尔排序的时间复杂度在最坏情况下为O(n^2)，在平均情况下为O(n^1.3)左右。

**稳定性**

希尔排序是一种**不稳定的排序**。希尔排序相对于简单的插入排序来说，在大多数情况下，性能都要好得多。尽管希尔排序的时间复杂度难以准确估计，但实际应用中，它通常比插入排序和选择排序更快，特别是对于中等大小的数组。





## 交换排序

### 冒泡排序

冒泡排序k次可以得到最小的前k个元素

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
void func(vector<int>&array) {
	int n = array.size();
	for (int i = 0; i < n-1; i++) {
		for (int j = 0; j < n - 1 - i; j++) {
			if (array[j] > array[j + 1]) {
				int temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;

			}		
		}
	}
}
int main() {
	vector<int>a = { 1,7,3,9,2 };
	func(a);
	auto printElement = [](int element) {
		cout << element << ' ';
		};
	for_each(a.begin(), a.end(), printElement);

}
```

改进的冒泡排序，原理是：如果发现有一次没有进行交换记录，则说明该数列已经是有序的了

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
void func(vector<int>&array) {
	int flag = 1;
	int n = array.size();
	for (int i = 0; i < n-1&&flag==1; i++) {
		flag = 0;
        //冒泡排序会把最大值的值冒到最后，所以这里的上限时n-1-i
		for (int j = 0; j < n - 1 - i; j++) {
			if (array[j] > array[j + 1]) {
				flag = 1;
				int temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;

			}		
		}
	}
}
int main() {
	vector<int>a = { 1,7,3,9,2 };
	func(a);
	auto printElement = [](int element) {
		cout << element << ' ';
		};
	for_each(a.begin(), a.end(), printElement);

}
```

**算法分析**

在数据几乎有序，数据量比较小的时候效果较好



| 时间复杂度 |          |          | 空间复杂度 | 稳定性 |
| ---------- | -------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况 | 平均情况 | 辅助存储   |        |
| o(n)       | o(n^2)   | o(n^2)   | o(1)       | 稳定   |





### 快速排序

关键字：哨兵节点，递归思想

快速排序的步骤如下：

1. **选择基准元素：** 从数组中选择一个元素作为基准元素。通常选择数组的第一个元素、最后一个元素或者中间元素作为基准。
2. **分割阶段：** 将数组中小于基准元素的元素移到基准元素的左边，将大于基准元素的元素移到基准元素的右边。在这一过程之后，基准元素的位置就被确定了。
3. **递归排序：** 对基准元素左右的两个子数组分别递归地应用快速排序。
4. **合并阶段：** 不需要合并操作，因为在分割阶段就已经确定了元素的相对顺序。

下面是一个使用递归实现的简单的快速排序算法（C++代码）：

```c++
#include<bits/stdc++.h>
using namespace std;
int func(vector<int>&arr,int low,int high){
	int i=low,j=high;
	int target=arr[i];
	while(i<j){
		while(i<j&&arr[j]>target) j--;
		arr[i]=arr[j];
		while(i<j&&arr[i]<=target) i++;
		arr[j]=arr[i];
	}
	arr[i]=target;
	return i;	
}

void Sort(vector<int>&arr,int low,int high){
	int pivotloc;
    //判断 low < high 是为了确定当前待排序的子数组是否包含至少两个元素
	if(low<high){
		pivotloc=func(arr,low,high);
		Sort(arr,low,pivotloc-1);
		Sort(arr,pivotloc+1,high);
	}
}

void print(int element){
	cout<<element<<' ';
}
int main() { 
	vector<int>a;
	a.push_back(1);
	a.push_back(3);
	a.push_back(2);
	a.push_back(9);
	a.push_back(5);
	a.push_back(6);
	

	int n=a.size();
	
	Sort(a,0,n-1);

	for_each(a.begin(),a.end(),print);
    return 0;
}
```

**算法分析**

数据越乱排序效果越好，快速排序不是自然排序

实验结果表明，就平均计算时间而言，快速排序是我们所讨论的所有内排序方法中最好的一个，即使是最坏情况时间复杂度也是o(n^2)

快速排序不是原地排序。由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度。(即使不用递归，也需要用用户栈)。在平均情况下:需要O(logn)的栈空间最坏情况下:栈空间可达O(n)。



| 时间复杂度 |          |          | 空间复杂度 | 稳定性 |
| ---------- | -------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况 | 平均情况 | 辅助存储   |        |
| o(nlognn)  | o(n^2)   | o(nlogn) | o(nlogn)   | 不稳定 |

### 快速找到第k小的数字

本算法对于10e7的数据也能过

```c++
#include <iostream>
using namespace std;
const int N = 1e7 + 10;// 数据范围:1≤n≤100000    1≤k≤n
int q[N];
int quick_sort(int q[], int l, int r, int k)
{
    // 区间只有一个元素，且k在区间中，则k即为该元素，直接返回即可

    if (l >= r) return q[l];

    int x = q[(l + r) >> 1], i = l - 1, j = r + 1;
    while (i < j)//迭代
    {
        do i++; 
        while (q[i] < x);
        do j--;
        while (q[j] > x);
        if (i < j)
            swap(q[i], q[j]);
  
    }

    if (j - l + 1 >= k)
        return quick_sort(q, l, j, k);
   
    else return quick_sort(q, j + 1, r, k - (j - l + 1));
}

int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
    for (int i = 0; i < n; i++)
        scanf("%d", &q[i]);
    cout << quick_sort(q, 0, n - 1, k) << endl;
    return 0;
}
```



## 选择排序

### 简单选择排序

```c++
void selectSort(SqList& L) {
	for (int i = 1; i < L.length; i++) {
		int k = i;
		for (int j = i + 1; j <= L.length; j++) {
			if (L.r[j].key < L.r[k].key) {
				k = j;
			}
		}
		if (k != i) {
			RedType temp;
			temp = L.r[i];
			L.r[i] = L.r[k];
			L.r[k] = temp;
		}
	}
}
```

**算法分析**

| 时间复杂度                  |                                   |          | 空间复杂度 | 稳定性 |
| --------------------------- | --------------------------------- | -------- | ---------- | ------ |
| 最好情况                    | 最坏情况                          | 平均情况 | 辅助存储   |        |
| 移动次数0 时间复杂度（n^2） | 移动次数3（n-1）时间复杂度（n^2） | o(n^2)   | o(1)       | 不稳定 |





### 堆排序

[【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e)

**定义：**堆首先是一个完全二叉树。分为大根堆和小根堆

**堆的存储：**节点下标为i,左子节点的下标为2i+1,右子节点的小标为2i+1

**下沉：**用破坏了有序性的节点和它的最大子节点比较，如果小于最大子节点就和最大子节点互换，直到该节点大于它的最大子节点或者到达树的底部，时间复杂度为o(logn),

**上浮：**树的最后一个元素破坏了堆序性，每次都让该节点和父节点比较，如果大于则交换，直到到达父节点或者小于父节点。时间复杂度为o(logn)

**建堆**

| 方法                   | 操作                                                         | 时间复杂度 |
| ---------------------- | ------------------------------------------------------------ | ---------- |
| 自顶向下建堆法（上浮） | 将新元素放到堆的最后，然后进行上浮操作                       | o(nlogn)   |
| 自下而上建堆法（下滤） | 先建立完全二叉树，再从倒数第二排开始，对每个父节点进行下滤操作，直到根节点操作完毕 | o(n)       |

**具体应用**

|          | 操作         | 具体实现                                                 | 时间复杂度 |
| -------- | ------------ | -------------------------------------------------------- | ---------- |
| 优先队列 | 弹出最小元素 | 弹出根节点，再把最后一个元素放到根节点，接着进行下滤操作 | o(logn)    |
|          | 插入操作     | 节点放到最后再上浮                                       | o(logn)    |



**堆排序**：先建立堆，再一次弹出根节点

大根堆得到的序列是正序的，小根堆得到的序列是逆序的



**算法实现原理**

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Heapify function to maintain heap property
template <typename T>
void heapify(vector<T>& array, int n, int i) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // left = 2*i + 1
    int right = 2 * i + 2; // right = 2*i + 2

    // If left child is larger than root
    if (left < n && array[left] > array[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && array[right] > array[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(array[i], array[largest]);

        // Recursively heapify the affected sub-tree
        heapify(array, n, largest);
    }
}

// Main function to do heap sort
template <typename T>
void HeapSort(vector<T>& array) {
    int n = array.size();

    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(array, n, i);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(array[0], array[i]);

        // call max heapify on the reduced heap
        heapify(array, i, 0);
    }
}

int main() {
    vector<int> array = {12, 11, 13, 5, 6, 7};
    HeapSort(array);

    cout << "Sorted array is \n";
    for (int i = 0; i < array.size(); ++i)
        cout << array[i] << " ";
    cout << endl;

    return 0;
}

```



**算法分析**

堆排序的主要小号在建立初始堆和调整建新堆时进行的反复筛选上。对元素个数比较多的情况比较有效

| 时间复杂度 |            |          | 空间复杂度 | 稳定性 |
| ---------- | ---------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况   | 平均情况 | 辅助存储   |        |
| o(nlogn)   | o（nlogn） | o(nlogn) | o(n^2)     | 不稳定 |

## 归并排序（二路归并）

https://www.bilibili.com/video/BV1Pt4y197VZ/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

归并排序（Merge Sort）是一种基于分治法（Divide and Conquer）的有效、稳定的排序算法。

归并排序将待排序的序列分成若干个子序列，分别对每个子序列进行排序，然后再将已排序的子序列合并成一个最终的排序序列。

基本流程：

​	**分解（Divide）**：将当前序列从中间位置分成两个子序列，分别对两个子序列递归进行归并排序。

​	**解决（Conquer）**：当子序列长度为1时，认为子序列已排好序。

​	**合并（Combine）**：将两个已排序的子序列合并成一个排序序列。



![image-20240719105726541](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240719105726541.png)



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 归并排序辅助函数：合并两个有序数组
void MergeArray(vector<int>& array, int low, int mid, int high) {
    vector<int>temp(array.size(), 0);
    int left = low, right = mid + 1, pos = low;

    while (left <= mid && right <= high) {
        if (array[left] <= array[right])
            temp[pos++] = array[left++];
        else
            temp[pos++] = array[right++];
    }

    while (left <= mid)
        temp[pos++] = array[left++];
    while (right <= high)
        temp[pos++] = array[right++];

    for (int i = low; i <=high; ++i)
        array[i] = temp[i];
}

// 归并排序主函数
void MergeSort(vector<int>& array, int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        MergeSort(array, low, mid);
        MergeSort(array, mid + 1,high);
        MergeArray(array, low, mid,high);
    }
}

int main() {
    auto print = [](int element) {
        cout << element << ' ';
        };

    vector<int> array = { 3, 6, 8, 4, 2, 1, 0, 7, 3, 2, 6 };
    int n = array.size();
    vector<int>temp(n, 0);
    MergeSort(array, 0, n - 1);
    for_each(array.begin(), array.end(), print);
    cout << endl;

    return 0;
}

```



**算法分析**

| 时间复杂度 |            |          | 空间复杂度 | 稳定性 |
| ---------- | ---------- | -------- | ---------- | ------ |
| 最好情况   | 最坏情况   | 平均情况 | 辅助存储   |        |
| o(nlogn)   | o（nlogn） | o(nlogn) | o(n)       | 稳定   |

## 基数排序

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较进行排序。基数排序有两种方法：LSD（Least Significant Digit）从最低位开始排序，MSD（Most Significant Digit）从最高位开始排序。常用的是LSD方法。

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int getmax(vector<int>& arry) {
	int maxval = arry[0];
	for (auto i : arry) {
		if (maxval < i) maxval = i;
	}
	return maxval;
}
void radixSort(vector<int>& arry) {
	int maxval = getmax(arry);
	int exp = 1;
	vector<queue<int>>backet(10);
	while (maxval / exp > 0) {
		for (auto i : arry) {
			int index = (i / exp) % 10;
			backet[index].push(i);
		}

		int j = 0;
		for (int i = 0; i < 10; i++) {
			while (!backet[i].empty()) {
				arry[j++] = backet[i].front();
				backet[i].pop();
			}
			
		}

		exp *= 10;
	}
}
int main() {
	vector<int>arry = { 1,90,6,54,77,3,40 };

	radixSort(arry);
	auto print = [](int element) {
		cout << element << ' ';
		};

	for_each(arry.begin(), arry.end(), print);

}

```



## 计数排序

https://www.bilibili.com/video/BV1sU4y1R7pm/?spm_id_from=333.337.search-card.all.click&vd_source=25a8d1bf110f4d8aa4824f6d3ec8640e

## 各种排序的比较



![image-20240102162342175](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20240102162342175.png)













